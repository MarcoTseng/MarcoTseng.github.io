(self.webpackChunkai_project=self.webpackChunkai_project||[]).push([[179],{956:function(){(function(){"use strict";var Ze;function At(b){var C=0;return function(){return C<b.length?{done:!1,value:b[C++]}:{done:!0}}}var ee="function"==typeof Object.defineProperties?Object.defineProperty:function(b,C,T){return b==Array.prototype||b==Object.prototype||(b[C]=T.value),b},en=function Ye(b){b=["object"==typeof globalThis&&globalThis,b,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var C=0;C<b.length;++C){var T=b[C];if(T&&T.Math==Math)return T}throw Error("Cannot find global object")}(this);function je(b,C){if(C)e:{var T=en;b=b.split(".");for(var D=0;D<b.length-1;D++){var P=b[D];if(!(P in T))break e;T=T[P]}(C=C(D=T[b=b[b.length-1]]))!=D&&null!=C&&ee(T,b,{configurable:!0,writable:!0,value:C})}}function hn(b){return(b={next:b})[Symbol.iterator]=function(){return this},b}function Xe(b){var C=typeof Symbol<"u"&&Symbol.iterator&&b[Symbol.iterator];return C?C.call(b):{next:At(b)}}function We(b){if(!(b instanceof Array)){b=Xe(b);for(var C,T=[];!(C=b.next()).done;)T.push(C.value);b=T}return b}je("Symbol",function(b){function T(W,B){this.g=W,ee(this,"description",{configurable:!0,writable:!0,value:B})}if(b)return b;T.prototype.toString=function(){return this.g};var D="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",P=0;return function C(W){if(this instanceof C)throw new TypeError("Symbol is not a constructor");return new T(D+(W||"")+"_"+P++,W)}}),je("Symbol.iterator",function(b){if(b)return b;b=Symbol("Symbol.iterator");for(var C="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),T=0;T<C.length;T++){var D=en[C[T]];"function"==typeof D&&"function"!=typeof D.prototype[b]&&ee(D.prototype,b,{configurable:!0,writable:!0,value:function(){return hn(At(this))}})}return b});var Ae,gt="function"==typeof Object.create?Object.create:function(b){function C(){}return C.prototype=b,new C};if("function"==typeof Object.setPrototypeOf)Ae=Object.setPrototypeOf;else{var j;e:{var Se={};try{Se.__proto__={a:!0},j=Se.a;break e}catch{}j=!1}Ae=j?function(b,C){if(b.__proto__=C,b.__proto__!==C)throw new TypeError(b+" is not extensible");return b}:null}var ce=Ae;function fe(b,C){if(b.prototype=gt(C.prototype),b.prototype.constructor=b,ce)ce(b,C);else for(var T in C)if("prototype"!=T)if(Object.defineProperties){var D=Object.getOwnPropertyDescriptor(C,T);D&&Object.defineProperty(b,T,D)}else b[T]=C[T];b.na=C.prototype}function Me(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.u=this.o=0,this.j=null}function Le(b){if(b.l)throw new TypeError("Generator is already running");b.l=!0}function Ht(b,C){b.j={da:C,ea:!0},b.g=b.o||b.u}function _t(b,C,T){return b.g=T,{value:C}}function Vn(b){this.g=new Me,this.h=b}function Gr(b,C,T,D){try{var P=C.call(b.g.i,T);if(!(P instanceof Object))throw new TypeError("Iterator result "+P+" is not an object");if(!P.done)return b.g.l=!1,P;var W=P.value}catch(B){return b.g.i=null,Ht(b.g,B),Ct(b)}return b.g.i=null,D.call(b.g,W),Ct(b)}function Ct(b){for(;b.g.g;)try{var C=b.h(b.g);if(C)return b.g.l=!1,{value:C.value,done:!1}}catch(T){b.g.h=void 0,Ht(b.g,T)}if(b.g.l=!1,b.g.j){if(C=b.g.j,b.g.j=null,C.ea)throw C.da;return{value:C.return,done:!0}}return{value:void 0,done:!0}}function Bt(b){this.next=function(C){return Le(b.g),b.g.i?C=Gr(b,b.g.i.next,C,b.g.s):(b.g.s(C),C=Ct(b)),C},this.throw=function(C){return Le(b.g),b.g.i?C=Gr(b,b.g.i.throw,C,b.g.s):(Ht(b.g,C),C=Ct(b)),C},this.return=function(C){return function Rs(b,C){Le(b.g);var T=b.g.i;return T?Gr(b,"return"in T?T.return:function(D){return{value:D,done:!0}},C,b.g.return):(b.g.return(C),Ct(b))}(b,C)},this[Symbol.iterator]=function(){return this}}function le(b){return function zt(b){function C(D){return b.next(D)}function T(D){return b.throw(D)}return new Promise(function(D,P){!function W(B){B.done?D(B.value):Promise.resolve(B.value).then(C,T).then(W,P)}(b.next())})}(new Bt(new Vn(b)))}Me.prototype.s=function(b){this.h=b},Me.prototype.return=function(b){this.j={return:b},this.g=this.u},je("Promise",function(b){function C(B){this.h=0,this.i=void 0,this.g=[],this.s=!1;var X=this.j();try{B(X.resolve,X.reject)}catch(oe){X.reject(oe)}}function T(){this.g=null}function D(B){return B instanceof C?B:new C(function(X){X(B)})}if(b)return b;T.prototype.h=function(B){if(null==this.g){this.g=[];var X=this;this.i(function(){X.l()})}this.g.push(B)};var P=en.setTimeout;T.prototype.i=function(B){P(B,0)},T.prototype.l=function(){for(;this.g&&this.g.length;){var B=this.g;this.g=[];for(var X=0;X<B.length;++X){var oe=B[X];B[X]=null;try{oe()}catch(ve){this.j(ve)}}}this.g=null},T.prototype.j=function(B){this.i(function(){throw B})},C.prototype.j=function(){function B(ve){return function(Be){oe||(oe=!0,ve.call(X,Be))}}var X=this,oe=!1;return{resolve:B(this.D),reject:B(this.l)}},C.prototype.D=function(B){if(B===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(B instanceof C)this.H(B);else{e:switch(typeof B){case"object":var X=null!=B;break e;case"function":X=!0;break e;default:X=!1}X?this.A(B):this.o(B)}},C.prototype.A=function(B){var X=void 0;try{X=B.then}catch(oe){return void this.l(oe)}"function"==typeof X?this.I(X,B):this.o(B)},C.prototype.l=function(B){this.u(2,B)},C.prototype.o=function(B){this.u(1,B)},C.prototype.u=function(B,X){if(0!=this.h)throw Error("Cannot settle("+B+", "+X+"): Promise already settled in state"+this.h);this.h=B,this.i=X,2===this.h&&this.G(),this.B()},C.prototype.G=function(){var B=this;P(function(){if(B.C()){var X=en.console;typeof X<"u"&&X.error(B.i)}},1)},C.prototype.C=function(){if(this.s)return!1;var B=en.CustomEvent,X=en.Event,oe=en.dispatchEvent;return typeof oe>"u"||("function"==typeof B?B=new B("unhandledrejection",{cancelable:!0}):"function"==typeof X?B=new X("unhandledrejection",{cancelable:!0}):(B=en.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,B),B.promise=this,B.reason=this.i,oe(B))},C.prototype.B=function(){if(null!=this.g){for(var B=0;B<this.g.length;++B)W.h(this.g[B]);this.g=null}};var W=new T;return C.prototype.H=function(B){var X=this.j();B.M(X.resolve,X.reject)},C.prototype.I=function(B,X){var oe=this.j();try{B.call(X,oe.resolve,oe.reject)}catch(ve){oe.reject(ve)}},C.prototype.then=function(B,X){function oe(lt,He){return"function"==typeof lt?function(Je){try{ve(lt(Je))}catch(ze){Be(ze)}}:He}var ve,Be,ct=new C(function(lt,He){ve=lt,Be=He});return this.M(oe(B,ve),oe(X,Be)),ct},C.prototype.catch=function(B){return this.then(void 0,B)},C.prototype.M=function(B,X){function oe(){switch(ve.h){case 1:B(ve.i);break;case 2:X(ve.i);break;default:throw Error("Unexpected state: "+ve.h)}}var ve=this;null==this.g?W.h(oe):this.g.push(oe),this.s=!0},C.resolve=D,C.reject=function(B){return new C(function(X,oe){oe(B)})},C.race=function(B){return new C(function(X,oe){for(var ve=Xe(B),Be=ve.next();!Be.done;Be=ve.next())D(Be.value).M(X,oe)})},C.all=function(B){var X=Xe(B),oe=X.next();return oe.done?D([]):new C(function(ve,Be){function ct(Je){return function(ze){lt[Je]=ze,0==--He&&ve(lt)}}var lt=[],He=0;do{lt.push(void 0),He++,D(oe.value).M(ct(lt.length-1),Be),oe=X.next()}while(!oe.done)})},C});var O="function"==typeof Object.assign?Object.assign:function(b,C){for(var T=1;T<arguments.length;T++){var D=arguments[T];if(D)for(var P in D)Object.prototype.hasOwnProperty.call(D,P)&&(b[P]=D[P])}return b};je("Object.assign",function(b){return b||O}),je("Object.is",function(b){return b||function(C,T){return C===T?0!==C||1/C==1/T:C!=C&&T!=T}}),je("Array.prototype.includes",function(b){return b||function(C,T){var D=this;D instanceof String&&(D=String(D));var P=D.length;for(0>(T=T||0)&&(T=Math.max(T+P,0));T<P;T++){var W=D[T];if(W===C||Object.is(W,C))return!0}return!1}}),je("String.prototype.includes",function(b){return b||function(C,T){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(C instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(C,T||0)}}),je("Array.prototype.keys",function(b){return b||function(){return function re(b,C){b instanceof String&&(b+="");var T=0,D=!1,P={next:function(){if(!D&&T<b.length){var W=T++;return{value:C(W,b[W]),done:!1}}return D=!0,{done:!0,value:void 0}}};return P[Symbol.iterator]=function(){return P},P}(this,function(C){return C})}});var Ie=this||self;function Ne(b,C){b=b.split(".");var D,T=Ie;b[0]in T||typeof T.execScript>"u"||T.execScript("var "+b[0]);for(;b.length&&(D=b.shift());)b.length||void 0===C?T=T[D]&&T[D]!==Object.prototype[D]?T[D]:T[D]={}:T[D]=C}function wt(){throw Error("Invalid UTF8")}function xt(b,C){return C=String.fromCharCode.apply(null,C),null==b?C:b+C}var Ut,An,Kt=typeof TextDecoder<"u",nr=typeof TextEncoder<"u",vn={},wn=null;function xn(b){var C;void 0===C&&(C=0),ym(),C=vn[C];for(var T=Array(Math.floor(b.length/3)),D=C[64]||"",P=0,W=0;P<b.length-2;P+=3){var B=b[P],X=b[P+1],oe=b[P+2],ve=C[B>>2];T[W++]=ve+(B=C[(3&B)<<4|X>>4])+(X=C[(15&X)<<2|oe>>6])+(oe=C[63&oe])}switch(ve=0,oe=D,b.length-P){case 2:oe=C[(15&(ve=b[P+1]))<<2]||D;case 1:T[W]=C[(b=b[P])>>2]+C[(3&b)<<4|ve>>4]+oe+D}return T.join("")}function Cr(b){var C=b.length,T=3*C/4;T%3?T=Math.floor(T):-1!="=.".indexOf(b[C-1])&&(T=-1!="=.".indexOf(b[C-2])?T-2:T-1);var D=new Uint8Array(T),P=0;return function xi(b,C){function T(oe){for(;D<b.length;){var ve=b.charAt(D++),Be=wn[ve];if(null!=Be)return Be;if(!/^[\s\xa0]*$/.test(ve))throw Error("Unknown base64 encoding at char: "+ve)}return oe}ym();for(var D=0;;){var P=T(-1),W=T(0),B=T(64),X=T(64);if(64===X&&-1===P)break;C(P<<2|W>>4),64!=B&&(C(W<<4&240|B>>2),64!=X&&C(B<<6&192|X))}}(b,function(W){D[P++]=W}),P!==T?D.subarray(0,P):D}function ym(){if(!wn){wn={};for(var b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),C=["+/=","+/","-_=","-_.","-_"],T=0;5>T;T++){var D=b.concat(C[T].split(""));vn[T]=D;for(var P=0;P<D.length;P++){var W=D[P];void 0===wn[W]&&(wn[W]=P)}}}}var Fa,bm="function"==typeof Uint8Array;function jd(b){return bm&&null!=b&&b instanceof Uint8Array}function Ci(b){if(this.L=b,null!==b&&0===b.length)throw Error("ByteString should be constructed with non-empty values")}var qu="function"==typeof Uint8Array.prototype.slice,jo=0;function Ku(b,C){return Error("Invalid wire type: "+b+" (at position "+C+")")}function Gd(){return Error("Failed to read varint, encoding is invalid.")}function Ma(b,C){C=void 0!==(C=void 0===C?{}:C).v&&C.v,this.h=null,this.g=this.i=this.j=0,this.v=C,b&&Pa(this,b)}function Pa(b,C){b.h=function lv(b,C){if(b.constructor===Uint8Array)return b;if(b.constructor===ArrayBuffer)return new Uint8Array(b);if(b.constructor===Array)return new Uint8Array(b);if(b.constructor===String)return Cr(b);if(b.constructor===Ci)return!C&&(C=b.L)&&C.constructor===Uint8Array?C:(C=null==(C=b.L)||jd(C)?C:"string"==typeof C?Cr(C):null,(b=b.L=C)?new Uint8Array(b):Fa||(Fa=new Uint8Array(0)));if(b instanceof Uint8Array)return new Uint8Array(b.buffer,b.byteOffset,b.byteLength);throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers")}(C,b.v),b.j=0,b.i=b.h.length,b.g=b.j}function qr(b){if(b.g>b.i)throw Error("Tried to read past the end of the data "+b.g+" > "+b.i)}function Ji(b){var C=b.h,T=C[b.g],D=127&T;if(128>T)return b.g+=1,qr(b),D;if(D|=(127&(T=C[b.g+1]))<<7,128>T)return b.g+=2,qr(b),D;if(D|=(127&(T=C[b.g+2]))<<14,128>T)return b.g+=3,qr(b),D;if(D|=(127&(T=C[b.g+3]))<<21,128>T)return b.g+=4,qr(b),D;if(T=C[b.g+4],b.g+=5,D|=(15&T)<<28,128>T)return qr(b),D;if(128<=C[b.g++]&&128<=C[b.g++]&&128<=C[b.g++]&&128<=C[b.g++]&&128<=C[b.g++])throw Gd();return qr(b),D}Ma.prototype.reset=function(){this.g=this.j};var vm=[];function Bl(){this.g=[]}function bo(b,C){for(;127<C;)b.g.push(127&C|128),C>>>=7;b.g.push(C)}function uv(b){var C={},T=void 0!==C.W&&C.W;this.l={v:void 0!==C.v&&C.v},this.W=T,C=this.l,vm.length?(T=vm.pop(),C&&(T.v=C.v),b&&Pa(T,b),b=T):b=new Ma(b,C),this.g=b,this.j=this.g.g,this.h=this.i=-1}function qd(b){var C=b.g;if(C.g==C.i)return!1;b.j=b.g.g;var T=Ji(b.g)>>>0;if(C=T>>>3,!(0<=(T&=7)&&5>=T))throw Ku(T,b.j);if(1>C)throw Error("Invalid field number: "+C+" (at position "+b.j+")");return b.i=C,b.h=T,!0}function Gn(b){switch(b.h){case 0:if(0!=b.h)Gn(b);else e:{for(var C=(b=b.g).g,T=C+10;C<T;)if(0==(128&b.h[C++])){b.g=C,qr(b);break e}throw Gd()}break;case 1:(b=b.g).g+=8,qr(b);break;case 2:2!=b.h?Gn(b):(C=Ji(b.g)>>>0,(b=b.g).g+=C,qr(b));break;case 5:(b=b.g).g+=4,qr(b);break;case 3:for(C=b.i;;){if(!qd(b))throw Error("Unmatched start-group tag: stream EOF");if(4==b.h){if(b.i!=C)throw Error("Unmatched end-group tag");break}Gn(b)}break;default:throw Ku(b.h,b.j)}}Bl.prototype.length=function(){return this.g.length},Bl.prototype.end=function(){var b=this.g;return this.g=[],b},uv.prototype.reset=function(){this.g.reset(),this.j=this.g.g,this.h=this.i=-1};var zl=[];function cv(){this.i=[],this.h=0,this.g=new Bl}function La(b,C){0!==C.length&&(b.i.push(C),b.h+=C.length)}var Go="function"==typeof Symbol&&"symbol"==typeof Symbol()?Symbol(void 0):void 0;function Kd(b,C){Object.isFrozen(b)||(Go?b[Go]|=C:void 0!==b.N?b.N|=C:Object.defineProperties(b,{N:{value:C,configurable:!0,writable:!0,enumerable:!1}}))}function wm(b){return(Go?b[Go]:b.N)??0}function Os(b){return Kd(b,1),b}function ps(b){return!!Array.isArray(b)&&!!(2&wm(b))}function Xd(b){if(!Array.isArray(b))throw Error("cannot mark non-array as immutable");Kd(b,2)}function Si(b){return null!==b&&"object"==typeof b&&!Array.isArray(b)&&b.constructor===Object}var $a=Object.freeze(Os([]));function xm(b){if(ps(b.m))throw Error("Cannot mutate an immutable Message")}var Em,Xu=typeof Symbol<"u"&&typeof Symbol.hasInstance<"u";function Cm(b){return{value:b,configurable:!1,writable:!1,enumerable:!1}}function Xs(b,C,T){return-1===C?null:C>=b.i?b.g?b.g[C]:void 0:void 0!==T&&T&&b.g&&null!=(T=b.g[C])?T:b.m[C+b.h]}function rr(b,C,T,D){D=void 0!==D&&D,xm(b),C<b.i&&!D?b.m[C+b.h]=T:(b.g||(b.g=b.m[b.i+b.h]={}))[C]=T}function Sm(b,C,T,D){T=void 0===T||T;var P=Xs(b,C,D=void 0!==D&&D);return null==P&&(P=$a),ps(b.m)?T&&(Xd(P),Object.freeze(P)):(P===$a||ps(P))&&rr(b,C,P=Os(P.slice()),D),P}function vo(b,C,T){return(b=null==(b=Xs(b,C))?b:+b)??(void 0===T?0:T)}function Ju(b,C,T,D){b.j||(b.j={});var P=ps(b.m),W=b.j[T];if(!W){D=Sm(b,T,!0,void 0!==D&&D),W=[],P=P||ps(D);for(var B=0;B<D.length;B++)W[B]=new C(D[B]),P&&Xd(W[B].m);P&&(Xd(W),Object.freeze(W)),b.j[T]=W}return W}function Nm(b,C,T,D,P){var W=void 0!==W&&W;return xm(b),W=Ju(b,T,C,W),T=D||new T,b=Sm(b,C),null!=P?(W.splice(P,0,T),b.splice(P,0,T.m)):(W.push(T),b.push(T.m)),T}function Tm(b,C){return(b=Xs(b,C))??0}function Jd(b,C){return(b=Xs(b,C))??""}function Zu(b){return Yu(b,void 0===_m?fv:_m)}function Im(b,C){if(null!=b){if(Array.isArray(b))b=Yu(b,C);else if(Si(b)){var D,T={};for(D in b)T[D]=Im(b[D],C);b=T}else b=C(b);return b}}function Yu(b,C){for(var T=b.slice(),D=0;D<T.length;D++)T[D]=Im(T[D],C);return Array.isArray(b)&&1&wm(b)&&Os(T),T}function _m(b){return b&&"object"==typeof b&&b.toJSON?b.toJSON():(b=function hv(b){switch(typeof b){case"number":return isFinite(b)?b:String(b);case"object":if(b&&!Array.isArray(b)){if(jd(b))return xn(b);if(b instanceof Ci){var C=b.L;return C=null==C||"string"==typeof C?C:bm&&C instanceof Uint8Array?xn(C):null,(b.L=C)||""}}}return b}(b),Array.isArray(b)?Zu(b):b)}function fv(b){return jd(b)?new Uint8Array(b):b}function Qu(b,C,T){b||(b=Em),Em=null;var D=this.constructor.h;if(b||(b=D?[D]:[]),this.h=(D?0:-1)-(this.constructor.g||0),this.j=void 0,this.m=b,b=(D=this.m.length)-1,D&&Si(D=this.m[b])?(this.i=b-this.h,this.g=D):void 0!==C&&-1<C?(this.i=Math.max(C,b+1-this.h),this.g=void 0):this.i=Number.MAX_VALUE,T)for(C=0;C<T.length;C++)if((b=T[C])<this.i)(D=this.m[b+=this.h])?Array.isArray(D)&&Os(D):this.m[b]=$a;else{var P=(D=this.g||(this.g=this.m[this.i+this.h]={}))[b];P?Array.isArray(P)&&Os(P):D[b]=$a}}function Js(){Qu.apply(this,arguments)}if(Qu.prototype.toJSON=function(){return Zu(this.m)},Qu.prototype.toString=function(){return this.m.toString()},fe(Js,Qu),Xu){var Zd={};Object.defineProperties(Js,(Zd[Symbol.hasInstance]=Cm(function(){throw Error("Cannot perform instanceof checks for MutableMessage")}),Zd))}function Dm(b,C,T){if(T){var P,D={};for(P in T){var W=T[P],B=W.ha;B||(D.F=W.la||W.fa.P,W.aa?(D.U=Om(W.aa),B=function(X){return function(oe,ve,Be){return X.F(oe,ve,Be,X.U)}}(D)):W.ca?(D.T=Fm(W.X.g,W.ca),B=function(X){return function(oe,ve,Be){return X.F(oe,ve,Be,X.T)}}(D)):B=D.F,W.ha=B),B(C,b,W.X),D={F:D.F,U:D.U,T:D.T}}}!function dv(b,C){if(C=C.ba){La(b,b.g.end());for(var T=0;T<C.length;T++)La(b,C[T])}}(C,b)}var Ul=Symbol();function km(b,C,T){return b[Ul]||(b[Ul]=function(D,P){return C(D,P,T)})}function Am(b){var C=b[Ul];if(!C){var T=th(b);b[Ul]=C=function(D,P){return nh(D,P,T)}}return C}function pv(b){var C=function Yd(b){var C=b.aa;return C?Am(C):(C=b.ka)?km(b.X.g,C,b.ca):void 0}(b),T=b.X,D=b.fa.O;return C?function(P,W){return D(P,W,T,C)}:function(P,W){return D(P,W,T)}}function Rm(b,C,T,D,P,W){var B=0;for((b=b()).length&&"number"!=typeof b[0]&&(T(C,b[0]),B++);B<b.length;){T=b[B++];for(var X=B+1;X<b.length&&"number"!=typeof b[X];)X++;var oe=b[B++];switch(X-=B){case 0:D(C,T,oe);break;case 1:D(C,T,oe,b[B++]);break;case 2:P(C,T,oe,b[B++],b[B++]);break;case 3:X=b[B++];var ve=b[B++],Be=b[B++];Array.isArray(Be)?P(C,T,oe,X,ve,Be):W(C,T,oe,X,ve,Be);break;case 4:W(C,T,oe,b[B++],b[B++],b[B++],b[B++]);break;default:throw Error("unexpected number of binary field arguments: "+X)}}return C}var ec=Symbol();function Om(b){var C=b[ec];if(!C){var T=Qd(b);b[ec]=C=function(D,P){return rh(D,P,T)}}return C}function Fm(b,C){var T=b[ec];return T||(b[ec]=T=function(D,P){return Dm(D,P,C)}),T}var Mm=Symbol();function mv(b,C){b.push(C)}function gv(b,C,T){b.push(C,T.P)}function yv(b,C,T,D,P){var W=Om(P),B=T.P;b.push(C,function(X,oe,ve){return B(X,oe,ve,D,W)})}function S_(b,C,T,D,P,W){var B=Fm(D,W),X=T.P;b.push(C,function(oe,ve,Be){return X(oe,ve,Be,D,B)})}function Qd(b){return b[Mm]||Rm(b,b[Mm]=[],mv,gv,yv,S_)}var eh=Symbol();function Pm(b,C){b[0]=C}function Lm(b,C,T,D){var P=T.O;b[C]=D?function(W,B,X){return P(W,B,X,D)}:P}function $m(b,C,T,D,P,W){var B=T.O,X=Am(P);b[C]=function(oe,ve,Be){return B(oe,ve,Be,D,X,W)}}function bv(b,C,T,D,P,W,B){var X=T.O,oe=km(D,P,W);b[C]=function(ve,Be,ct){return X(ve,Be,ct,D,oe,B)}}function th(b){return b[eh]||Rm(b,b[eh]={},Pm,Lm,$m,bv)}function nh(b,C,T){for(;qd(C)&&4!=C.h;){var D=C.i,P=T[D];if(!P){var W=T[0];W&&(W=W[D])&&(P=T[D]=pv(W))}if(!(P&&P(C,b,D)||(P=C,D=b,W=P.j,Gn(P),P.W))){var B=P.g.h;P=W===(P=P.g.g)?Fa||(Fa=new Uint8Array(0)):qu?B.slice(W,P):new Uint8Array(B.subarray(W,P)),(W=D.ba)?W.push(P):D.ba=[P]}}return b}function tc(b,C,T){if(zl.length){var D=zl.pop();b&&(Pa(D.g,b),D.i=-1,D.h=-1),b=D}else b=new uv(b);try{return nh(new C,b,th(T))}finally{(C=b.g).h=null,C.j=0,C.i=0,C.g=0,C.v=!1,b.i=-1,b.h=-1,100>zl.length&&zl.push(b)}}function rh(b,C,T){for(var D=T.length,P=D%2==1,W=P?1:0;W<D;W+=2)(0,T[W+1])(C,b,T[W]);Dm(b,C,P?T[0]:void 0)}function Zs(b,C){var T=new cv;rh(b,T,Qd(C)),La(T,T.g.end()),b=new Uint8Array(T.h);for(var D=(C=T.i).length,P=0,W=0;W<D;W++){var B=C[W];b.set(B,P),P+=B.length}return T.i=[b],b}function Wl(b,C){return{O:b,P:C}}var Ys=Wl(function(b,C,T){if(5!==b.h)return!1;var D=(b=b.g).h[b.g],P=b.h[b.g+1],W=b.h[b.g+2],B=b.h[b.g+3];return b.g+=4,qr(b),b=2*((P=(D<<0|P<<8|W<<16|B<<24)>>>0)>>31)+1,D=P>>>23&255,P&=8388607,rr(C,T,255==D?P?NaN:1/0*b:0==D?b*Math.pow(2,-149)*P:b*Math.pow(2,D-150)*(P+Math.pow(2,23))),!0},function(b,C,T){if(null!=(C=Xs(C,T))){bo(b.g,8*T+5),b=b.g;var D=C;0===(D=(T=0>D?1:0)?-D:D)?jo=0<1/D?0:2147483648:isNaN(D)?jo=2147483647:34028234663852886e22<D?jo=(T<<31|2139095040)>>>0:11754943508222875e-54>D?(D=Math.round(D/Math.pow(2,-149)),jo=(T<<31|D)>>>0):(C=Math.floor(Math.log(D)/Math.LN2),D*=Math.pow(2,-C),16777216<=(D=Math.round(8388608*D))&&++C,jo=(T<<31|C+127<<23|8388607&D)>>>0),b.g.push((T=jo)>>>0&255),b.g.push(T>>>8&255),b.g.push(T>>>16&255),b.g.push(T>>>24&255)}}),vv=Wl(function(b,C,T){if(0!==b.h)return!1;for(var D=b.g,P=128,W=0,B=b=0;4>B&&128<=P;B++)P=D.h[D.g++],qr(D),W|=(127&P)<<7*B;if(128<=P&&(P=D.h[D.g++],qr(D),W|=(127&P)<<28,b|=(127&P)>>4),128<=P)for(B=0;5>B&&128<=P;B++)P=D.h[D.g++],qr(D),b|=(127&P)<<7*B+3;if(!(128>P))throw Gd();return D=W>>>0,(b=2147483648&(P=b>>>0))&&(P=~P>>>0,0==(D=1+~D>>>0)&&(P=P+1>>>0)),D=4294967296*P+(D>>>0),rr(C,T,b?-D:D),!0},function(b,C,T){if(null!=(C=Xs(C,T))&&null!=C){bo(b.g,8*T),b=b.g;var D=C;for(T=0>D,C=(D=Math.abs(D))>>>0,D=Math.floor((D-C)/4294967296),D>>>=0,T&&(D=~D>>>0,4294967295<(C=1+(~C>>>0))&&(C=0,4294967295<++D&&(D=0))),T=jo=C,C=D;0<C||127<T;)b.g.push(127&T|128),T=(T>>>7|C<<25)>>>0,C>>>=7;b.g.push(T)}}),wv=Wl(function(b,C,T){return 0===b.h&&(rr(C,T,Ji(b.g)),!0)},function(b,C,T){if(null!=(C=Xs(C,T))&&null!=C)if(bo(b.g,8*T),b=b.g,0<=(T=C))bo(b,T);else{for(C=0;9>C;C++)b.g.push(127&T|128),T>>=7;b.g.push(1)}}),sh=Wl(function(b,C,T){if(2!==b.h)return!1;var W,D=Ji(b.g)>>>0,P=(b=b.g).g;if(b.g+=D,qr(b),b=b.h,Kt)(W=Ut)||(W=Ut=new TextDecoder("utf-8",{fatal:!0})),W=W.decode(b.subarray(P,P+D));else{D=P+D;for(var oe,ve,Be,B=[],X=null;P<D;)128>(oe=b[P++])?B.push(oe):224>oe?P>=D?wt():(ve=b[P++],194>oe||128!=(192&ve)?(P--,wt()):B.push((31&oe)<<6|63&ve)):240>oe?P>=D-1?wt():128!=(192&(ve=b[P++]))||224===oe&&160>ve||237===oe&&160<=ve||128!=(192&(W=b[P++]))?(P--,wt()):B.push((15&oe)<<12|(63&ve)<<6|63&W):244>=oe?P>=D-2?wt():128!=(192&(ve=b[P++]))||ve-144+(oe<<28)>>30!=0||128!=(192&(W=b[P++]))||128!=(192&(Be=b[P++]))?(P--,wt()):(oe=(7&oe)<<18|(63&ve)<<12|(63&W)<<6|63&Be,B.push(55296+((oe-=65536)>>10&1023),56320+(1023&oe))):wt(),8192<=B.length&&(X=xt(X,B),B.length=0);W=xt(X,B)}return rr(C,T,W),!0},function(b,C,T){if(null!=(C=Xs(C,T))){var D=!1;if(D=void 0!==D&&D,nr){if(D&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(C))throw Error("Found an unpaired surrogate");C=(An||(An=new TextEncoder)).encode(C)}else{for(var P=0,W=new Uint8Array(3*C.length),B=0;B<C.length;B++){var X=C.charCodeAt(B);if(128>X)W[P++]=X;else{if(2048>X)W[P++]=X>>6|192;else{if(55296<=X&&57343>=X){if(56319>=X&&B<C.length){var oe=C.charCodeAt(++B);if(56320<=oe&&57343>=oe){W[P++]=(X=1024*(X-55296)+oe-56320+65536)>>18|240,W[P++]=X>>12&63|128,W[P++]=X>>6&63|128,W[P++]=63&X|128;continue}B--}if(D)throw Error("Found an unpaired surrogate");X=65533}W[P++]=X>>12|224,W[P++]=X>>6&63|128}W[P++]=63&X|128}}C=W.subarray(0,P)}bo(b.g,8*T+2),bo(b.g,C.length),La(b,b.g.end()),La(b,C)}}),Vm=Wl(function(b,C,T,D,P){if(2!==b.h)return!1;C=Nm(C,T,D),T=b.g.i,D=Ji(b.g)>>>0;var W=b.g.g+D,B=W-T;if(0>=B&&(b.g.i=W,P(C,b),B=W-b.g.g),B)throw Error("Message parsing ended unexpectedly. Expected to read "+D+" bytes, instead read "+(D-B)+" bytes, either the data ended unexpectedly or the message misreported its own length");return b.g.g=W,b.g.i=T,!0},function(b,C,T,D,P){if(null!=(C=Ju(C,D,T)))for(D=0;D<C.length;D++){var W=b;bo(W.g,8*T+2);var B=W.g.end();La(W,B),B.push(W.h),W=B,P(C[D],b),B=b;var X=W.pop();for(X=B.h+B.g.length()-X;127<X;)W.push(127&X|128),X>>>=7,B.h++;W.push(X),B.h++}});function Fs(){Js.apply(this,arguments)}if(fe(Fs,Js),Xu){var wo={};Object.defineProperties(Fs,(wo[Symbol.hasInstance]=Cm(Object[Symbol.hasInstance]),wo))}function Hl(b){Fs.call(this,b)}function jl(){return[1,wv,2,Ys,3,sh,4,sh]}function oh(b){Fs.call(this,b,-1,N_)}function ih(){return[1,Vm,Hl,jl]}fe(Hl,Fs),fe(oh,Fs),oh.prototype.addClassification=function(b,C){return Nm(this,1,Hl,b,C),this};var N_=[1];function nc(b){Fs.call(this,b)}function Bm(){return[1,Ys,2,Ys,3,Ys,4,Ys,5,Ys]}function rc(b){Fs.call(this,b,-1,ah)}function zm(){return[1,Vm,nc,Bm]}fe(nc,Fs),fe(rc,Fs);var ah=[1];function lh(b){Fs.call(this,b)}function uh(){return[1,Ys,2,Ys,3,Ys,4,Ys,5,Ys,6,vv]}fe(lh,Fs);var ch=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Um=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],Wm=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],Hm=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],jm=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],dh=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],xv=[].concat(We(ch),We(Um),We(Wm),We(Hm),We(jm),We(dh));function Gm(b,C,T){if(T=b.createShader(0===T?b.VERTEX_SHADER:b.FRAGMENT_SHADER),b.shaderSource(T,C),b.compileShader(T),!b.getShaderParameter(T,b.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+b.getShaderInfoLog(T));return T}function Gl(b){return Ju(b,Hl,1).map(function(C){return{index:Tm(C,1),ga:vo(C,2),label:null!=Xs(C,3)?Jd(C,3):void 0,displayName:null!=Xs(C,4)?Jd(C,4):void 0}})}function Cv(b){return{x:vo(b,1),y:vo(b,2),z:vo(b,3),visibility:null!=Xs(b,4)?vo(b,4):void 0}}function hh(b,C){this.h=b,this.g=C,this.l=0}function sc(b,C,T){return function tn(b,C){var T=b.g;if(void 0===b.o){var D=Gm(T,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),P=Gm(T,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),W=T.createProgram();if(T.attachShader(W,D),T.attachShader(W,P),T.linkProgram(W),!T.getProgramParameter(W,T.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+T.getProgramInfoLog(W));D=b.o=W,T.useProgram(D),P=T.getUniformLocation(D,"sampler0"),b.j={K:T.getAttribLocation(D,"aVertex"),J:T.getAttribLocation(D,"aTex"),ma:P},b.u=T.createBuffer(),T.bindBuffer(T.ARRAY_BUFFER,b.u),T.enableVertexAttribArray(b.j.K),T.vertexAttribPointer(b.j.K,2,T.FLOAT,!1,0,0),T.bufferData(T.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),T.STATIC_DRAW),T.bindBuffer(T.ARRAY_BUFFER,null),b.s=T.createBuffer(),T.bindBuffer(T.ARRAY_BUFFER,b.s),T.enableVertexAttribArray(b.j.J),T.vertexAttribPointer(b.j.J,2,T.FLOAT,!1,0,0),T.bufferData(T.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),T.STATIC_DRAW),T.bindBuffer(T.ARRAY_BUFFER,null),T.uniform1i(P,0)}D=b.j,T.useProgram(b.o),T.canvas.width=C.width,T.canvas.height=C.height,T.viewport(0,0,C.width,C.height),T.activeTexture(T.TEXTURE0),b.h.bindTexture2d(C.glName),T.enableVertexAttribArray(D.K),T.bindBuffer(T.ARRAY_BUFFER,b.u),T.vertexAttribPointer(D.K,2,T.FLOAT,!1,0,0),T.enableVertexAttribArray(D.J),T.bindBuffer(T.ARRAY_BUFFER,b.s),T.vertexAttribPointer(D.J,2,T.FLOAT,!1,0,0),T.bindFramebuffer(T.DRAW_FRAMEBUFFER?T.DRAW_FRAMEBUFFER:T.FRAMEBUFFER,null),T.clearColor(0,0,0,0),T.clear(T.COLOR_BUFFER_BIT),T.colorMask(!0,!0,!0,!0),T.drawArrays(T.TRIANGLE_FAN,0,4),T.disableVertexAttribArray(D.K),T.disableVertexAttribArray(D.J),T.bindBuffer(T.ARRAY_BUFFER,null),b.h.bindTexture2d(0)}(b,C),"function"==typeof b.g.canvas.transferToImageBitmap?Promise.resolve(b.g.canvas.transferToImageBitmap()):T?Promise.resolve(b.g.canvas):"function"==typeof createImageBitmap?createImageBitmap(b.g.canvas):(void 0===b.i&&(b.i=document.createElement("canvas")),new Promise(function(D){b.i.height=b.g.canvas.height,b.i.width=b.g.canvas.width,b.i.getContext("2d",{}).drawImage(b.g.canvas,0,0,b.g.canvas.width,b.g.canvas.height),D(b.i)}))}function fh(b){this.g=b}var nn=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ph(b,C){return C+b}function qm(b,C){window[b]=C}function ql(b){if(this.g=b,this.listeners={},this.j={},this.H={},this.o={},this.u={},this.I=this.s=this.Z=!0,this.D=Promise.resolve(),this.Y="",this.C={},this.locateFile=b&&b.locateFile||ph,"object"==typeof window)var C=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if(!(typeof location<"u"))throw Error("solutions can only be loaded on a web page or in a web worker");C=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.$=C,b.options)for(var T=(C=Xe(Object.keys(b.options))).next();!T.done;T=C.next()){var D=b.options[T=T.value].default;void 0!==D&&(this.j[T]="function"==typeof D?D():D)}}function it(b,C){var T,D;return le(function(P){return C in b.H?P.return(b.H[C]):(T=b.locateFile(C,""),D=fetch(T).then(function(W){return W.arrayBuffer()}),b.H[C]=D,P.return(D))})}function I_(b,C){for(var T=C.name||"$",D=[].concat(We(C.wants)),P=new b.h.StringList,W=Xe(C.wants),B=W.next();!B.done;B=W.next())P.push_back(B.value);W=b.h.PacketListener.implement({onResults:function(X){for(var oe={},ve=0;ve<C.wants.length;++ve)oe[D[ve]]=X.get(ve);var Be=b.listeners[T];Be&&(b.D=function qt(b,C,T){var D,P,W,B,oe,ve,Be,ct,lt,He,ze,Cn;return le(function(fn){switch(fn.g){case 1:if(!T)return fn.return(C);for(D={},P=0,W=Xe(Object.keys(T)),B=W.next();!B.done;B=W.next())"string"!=typeof(oe=T[B.value])&&"texture"===oe.type&&void 0!==C[oe.stream]&&++P;1<P&&(b.I=!1),ve=Xe(Object.keys(T)),B=ve.next();case 2:if(B.done){fn.g=4;break}if("string"==typeof(ct=T[Be=B.value]))return ze=D,Cn=Be,_t(fn,function Sv(b,C,T){var D;return le(function(P){return"number"==typeof T||T instanceof Uint8Array||T instanceof b.h.Uint8BlobList?P.return(T):T instanceof b.h.Texture2dDataOut?((D=b.u[C])||(D=new hh(b.h,b.G),b.u[C]=D),P.return(sc(D,T,b.I))):P.return(void 0)})}(b,Be,C[ct]),14);if(lt=C[ct.stream],"detection_list"===ct.type){if(lt){for(var Mr=lt.getRectList(),Qe=lt.getLandmarksList(),ms=lt.getClassificationsList(),ft=[],Rn=0;Rn<Mr.size();++Rn){var Zi=tc(Mr.get(Rn),lh,uh);Zi={boundingBox:{xCenter:vo(Zi,1),yCenter:vo(Zi,2),height:vo(Zi,3),width:vo(Zi,4),rotation:vo(Zi,5,0),rectId:Tm(Zi,6)},landmarks:Ju(tc(Qe.get(Rn),rc,zm),nc,1).map(Cv),V:Gl(tc(ms.get(Rn),oh,ih))},ft.push(Zi)}Mr=ft}else Mr=[];D[Be]=Mr,fn.g=7;break}if("proto_list"===ct.type){if(lt){for(Mr=Array(lt.size()),Qe=0;Qe<lt.size();Qe++)Mr[Qe]=lt.get(Qe);lt.delete()}else Mr=[];D[Be]=Mr,fn.g=7;break}if(void 0===lt){fn.g=3;break}if("float_list"===ct.type){D[Be]=lt,fn.g=7;break}if("proto"===ct.type){D[Be]=lt,fn.g=7;break}if("texture"!==ct.type)throw Error("Unknown output config type: '"+ct.type+"'");return(He=b.u[Be])||(He=new hh(b.h,b.G),b.u[Be]=He),_t(fn,sc(He,lt,b.I),13);case 13:D[Be]=fn.h;case 7:ct.transform&&D[Be]&&(D[Be]=ct.transform(D[Be])),fn.g=3;break;case 14:ze[Cn]=fn.h;case 3:B=ve.next(),fn.g=2;break;case 4:return fn.return(D)}})}(b,oe,C.outs).then(function(ct){ct=Be(ct);for(var lt=0;lt<C.wants.length;++lt){var He=oe[D[lt]];"object"==typeof He&&He.hasOwnProperty&&He.hasOwnProperty("delete")&&He.delete()}ct&&(b.D=ct)}))}}),b.i.attachMultiListener(P,W),P.delete()}function Km(b){var C=this,T={url:"face_detection_short.binarypb"},D={type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}};this.g=new ql({locateFile:(b=b||{}).locateFile,files:[{data:!0,url:"face_detection_short.binarypb"},{data:!0,url:"face_detection_short_range.tflite"},{simd:!0,url:"face_detection_solution_simd_wasm_bin.js"},{simd:!1,url:"face_detection_solution_wasm_bin.js"}],graph:T,listeners:[{wants:["detections","image_transformed"],outs:{image:"image_transformed",detections:{type:"detection_list",stream:"detections"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"==typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},model:{type:0,onChange:function(P){var B,X,oe,ve;return le(function(ct){switch(ct.g){case 1:B=Xe("short"===P?["face_detection_short_range.tflite"]:["face_detection_full_range_sparse.tflite"]),X=B.next();case 2:if(X.done){ct.g=4;break}return ve="third_party/mediapipe/modules/face_detection/"+(oe=X.value),_t(ct,it(C.g,oe),5);case 5:C.g.overrideFile(ve,ct.h),X=B.next(),ct.g=2;break;case 4:return T.url="short"===P?"face_detection_short.binarypb":"face_detection_full.binarypb",D.graphOptionXref.calculatorName="short"===P?"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator":"facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator",ct.return(!0)}})}},minDetectionConfidence:D}})}(Ze=ql.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},Ze.reset=function(){var b=this;return le(function(C){b.i&&(b.i.reset(),b.o={},b.u={}),C.g=0})},Ze.setOptions=function(b,C){var T=this;if(C=C||this.g.options){for(var D=[],P=[],W={},B=Xe(Object.keys(b)),X=B.next();!X.done;W={R:W.R,S:W.S},X=B.next()){var oe=X.value;oe in this.j&&this.j[oe]===b[oe]||(this.j[oe]=b[oe],void 0!==(X=C[oe])&&(X.onChange&&(W.R=X.onChange,W.S=b[oe],D.push(function(ve){return function(){return le(function(ct){if(1==ct.g)return _t(ct,ve.R(ve.S),2);!0===ct.h&&(T.s=!0),ct.g=0})}}(W))),X.graphOptionXref&&(oe={valueNumber:1===X.type?b[oe]:0,valueBoolean:0===X.type&&b[oe],valueString:2===X.type?b[oe]:""},X=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),X.graphOptionXref),oe),P.push(X))))}(0!==D.length||0!==P.length)&&(this.s=!0,this.B=(void 0===this.B?[]:this.B).concat(P),this.A=(void 0===this.A?[]:this.A).concat(D))}},Ze.initialize=function(){var b=this;return le(function(C){return 1==C.g?_t(C,function T_(b){var C,T,D,P,W,B,X,oe,ve,Be,ct;return le(function(lt){switch(lt.g){case 1:return b.Z?(C=void 0===b.g.files?[]:"function"==typeof b.g.files?b.g.files(b.j):b.g.files,_t(lt,function nt(){return le(function(b){switch(b.g){case 1:return b.o=2,_t(b,WebAssembly.instantiate(nn),4);case 4:b.g=3,b.o=0;break;case 2:return b.o=0,b.j=null,b.return(!1);case 3:return b.return(!0)}})}(),2)):lt.return();case 2:if(T=lt.h,"object"==typeof window)return qm("createMediapipeSolutionsWasm",{locateFile:b.locateFile}),qm("createMediapipeSolutionsPackedAssets",{locateFile:b.locateFile}),B=C.filter(function(He){return void 0!==He.data}),X=C.filter(function(He){return void 0===He.data}),oe=Promise.all(B.map(function(He){var Je=it(b,He.url);if(void 0!==He.path){var ze=He.path;Je=Je.then(function(Cn){return b.overrideFile(ze,Cn),Promise.resolve(Cn)})}return Je})),ve=Promise.all(X.map(function(He){return void 0===He.simd||He.simd&&T||!He.simd&&!T?function un(b){var C=document.createElement("script");return C.setAttribute("src",b),C.setAttribute("crossorigin","anonymous"),new Promise(function(T){C.addEventListener("load",function(){T()},!1),C.addEventListener("error",function(){T()},!1),document.body.appendChild(C)})}(b.locateFile(He.url,b.$)):Promise.resolve()})).then(function(){var He,Je,ze;return le(function(Cn){if(1==Cn.g)return He=window.createMediapipeSolutionsWasm,Je=window.createMediapipeSolutionsPackedAssets,ze=b,_t(Cn,He(Je),2);ze.h=Cn.h,Cn.g=0})}),Be=le(function(He){return b.g.graph&&b.g.graph.url?He=_t(He,it(b,b.g.graph.url),0):(He.g=0,He=void 0),He}),_t(lt,Promise.all([ve,oe,Be]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return D=C.filter(function(He){return void 0===He.simd||He.simd&&T||!He.simd&&!T}).map(function(He){return b.locateFile(He.url,b.$)}),importScripts.apply(null,We(D)),P=b,_t(lt,createMediapipeSolutionsWasm(Module),6);case 6:P.h=lt.h,b.l=new OffscreenCanvas(1,1),b.h.canvas=b.l,W=b.h.GL.createContext(b.l,{antialias:!1,alpha:!1,ja:typeof WebGL2RenderingContext<"u"?2:1}),b.h.GL.makeContextCurrent(W),lt.g=4;break;case 7:if(b.l=document.createElement("canvas"),!(ct=b.l.getContext("webgl2",{}))&&!(ct=b.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),lt.return();b.G=ct,b.h.canvas=b.l,b.h.createContext(b.l,!0,!0,{});case 4:b.i=new b.h.SolutionWasm,b.Z=!1,lt.g=0}})}(b),2):3!=C.g?_t(C,function Pe(b){var T,D,P,W,B,oe;return le(function(ve){if(1==ve.g)return b.g.graph&&b.g.graph.url&&b.Y===b.g.graph.url?ve.return():(b.s=!0,b.g.graph&&b.g.graph.url?(b.Y=b.g.graph.url,_t(ve,it(b,b.g.graph.url),3)):void(ve.g=2));for(2!=ve.g&&b.i.loadGraph(ve.h),T=Xe(Object.keys(b.C)),D=T.next();!D.done;D=T.next())b.i.overrideFile(P=D.value,b.C[P]);if(b.C={},b.g.listeners)for(W=Xe(b.g.listeners),B=W.next();!B.done;B=W.next())I_(b,B.value);oe=b.j,b.j={},b.setOptions(oe),ve.g=0})}(b),3):_t(C,function oc(b){var C,T,P,W,B;return le(function(oe){switch(oe.g){case 1:if(!b.s)return oe.return();if(!b.A){oe.g=2;break}C=Xe(b.A),T=C.next();case 3:if(T.done){oe.g=5;break}return _t(oe,(0,T.value)(),4);case 4:T=C.next(),oe.g=3;break;case 5:b.A=void 0;case 2:if(b.B){for(P=new b.h.GraphOptionChangeRequestList,W=Xe(b.B),B=W.next();!B.done;B=W.next())P.push_back(B.value);b.i.changeOptions(P),P.delete(),b.B=void 0}b.s=!1,oe.g=0}})}(b),0)})},Ze.overrideFile=function(b,C){this.i?this.i.overrideFile(b,C):this.C[b]=C},Ze.clearOverriddenFiles=function(){this.C={},this.i&&this.i.clearOverriddenFiles()},Ze.send=function(b,C){var D,P,W,B,X,oe,ve,Be,ct,T=this;return le(function(lt){switch(lt.g){case 1:return T.g.inputs?(D=1e3*(C??performance.now()),_t(lt,T.D,2)):lt.return();case 2:return _t(lt,T.initialize(),3);case 3:for(P=new T.h.PacketDataList,W=Xe(Object.keys(b)),B=W.next();!B.done;B=W.next())if(oe=T.g.inputs[X=B.value]){e:{var He=b[X];switch(oe.type){case"video":var Je=T.o[oe.stream];if(Je||(Je=new hh(T.h,T.G),T.o[oe.stream]=Je),0===Je.l&&(Je.l=Je.h.createTexture()),typeof HTMLVideoElement<"u"&&He instanceof HTMLVideoElement)var ze=He.videoWidth,Cn=He.videoHeight;else typeof HTMLImageElement<"u"&&He instanceof HTMLImageElement?(ze=He.naturalWidth,Cn=He.naturalHeight):(ze=He.width,Cn=He.height);Cn={glName:Je.l,width:ze,height:Cn},(ze=Je.g).canvas.width=Cn.width,ze.canvas.height=Cn.height,ze.activeTexture(ze.TEXTURE0),Je.h.bindTexture2d(Je.l),ze.texImage2D(ze.TEXTURE_2D,0,ze.RGBA,ze.RGBA,ze.UNSIGNED_BYTE,He),Je.h.bindTexture2d(0),Je=Cn;break e;case"detections":for((Je=T.o[oe.stream])||(Je=new fh(T.h),T.o[oe.stream]=Je),Je.data||(Je.data=new Je.g.DetectionListData),Je.data.reset(He.length),Cn=0;Cn<He.length;++Cn){var fn=Je.data,Mr=fn.setBoundingBox,Qe=Cn,ms=(ze=He[Cn]).boundingBox,ft=new lh;if(rr(ft,1,ms.xCenter),rr(ft,2,ms.yCenter),rr(ft,3,ms.height),rr(ft,4,ms.width),rr(ft,5,ms.rotation),rr(ft,6,ms.rectId),ms=Zs(ft,uh),Mr.call(fn,Qe,ms),ze.landmarks)for(fn=0;fn<ze.landmarks.length;++fn){var Rn=!!(ft=ze.landmarks[fn]).visibility;Qe=(Mr=Je.data).addNormalizedLandmark,ms=Cn,ft=Object.assign(Object.assign({},ft),{visibility:Rn?ft.visibility:0}),rr(Rn=new nc,1,ft.x),rr(Rn,2,ft.y),rr(Rn,3,ft.z),ft.visibility&&rr(Rn,4,ft.visibility),ft=Zs(Rn,Bm),Qe.call(Mr,ms,ft)}if(ze.V)for(fn=0;fn<ze.V.length;++fn)Qe=(Mr=Je.data).addClassification,ms=Cn,ft=ze.V[fn],rr(Rn=new Hl,2,ft.ga),ft.index&&rr(Rn,1,ft.index),ft.label&&rr(Rn,3,ft.label),ft.displayName&&rr(Rn,4,ft.displayName),ft=Zs(Rn,jl),Qe.call(Mr,ms,ft)}Je=Je.data;break e;default:Je={}}}switch(ve=Je,Be=oe.stream,oe.type){case"video":P.pushTexture2d(Object.assign(Object.assign({},ve),{stream:Be,timestamp:D}));break;case"detections":(ct=ve).stream=Be,ct.timestamp=D,P.pushDetectionList(ct);break;default:throw Error("Unknown input config type: '"+oe.type+"'")}}return T.i.send(P),_t(lt,T.D,4);case 4:P.delete(),lt.g=0}})},Ze.onResults=function(b,C){this.listeners[C||"$"]=b},Ne("Solution",ql),Ne("OptionType",{BOOL:0,NUMBER:1,ia:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(Ze=Km.prototype).close=function(){return this.g.close(),Promise.resolve()},Ze.onResults=function(b){this.g.onResults(b)},Ze.initialize=function(){var b=this;return le(function(C){return _t(C,b.g.initialize(),0)})},Ze.reset=function(){this.g.reset()},Ze.send=function(b){var C=this;return le(function(T){return _t(T,C.g.send(b),0)})},Ze.setOptions=function(b){this.g.setOptions(b)},Ne("FaceDetection",Km),Ne("FACEDETECTION_LIPS",ch),Ne("FACEDETECTION_LEFT_EYE",Um),Ne("FACEDETECTION_LEFT_EYEBROW",Wm),Ne("FACEDETECTION_RIGHT_EYE",Hm),Ne("FACEDETECTION_RIGHT_EYEBROW",jm),Ne("FACEDETECTION_FACE_OVAL",dh),Ne("FACEDETECTION_CONTOURS",xv),Ne("FACEDETECTION_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),Ne("VERSION","0.4.1646425229")}).call(this)},785:(Ze,At,ee)=>{"use strict";var Ye={};ee.r(Ye),ee.d(Ye,{CompositeArrayBuffer:()=>ui,browserFiles:()=>vJ,browserHTTPRequest:()=>TJ,concatenateArrayBuffers:()=>zO,copyModel:()=>jX,decodeWeights:()=>PO,decodeWeightsStream:()=>VO,encodeWeights:()=>K2,fromMemory:()=>_J,fromMemorySync:()=>fF,getLoadHandlers:()=>RX,getModelArtifactsForJSON:()=>eS,getModelArtifactsForJSONSync:()=>HO,getModelArtifactsInfoForJSON:()=>cp,getSaveHandlers:()=>jO,getWeightSpecs:()=>nS,http:()=>vS,isHTTPScheme:()=>bS,listModels:()=>WX,loadWeights:()=>xJ,moveModel:()=>GX,registerLoadRouter:()=>AX,registerSaveRouter:()=>kX,removeModel:()=>HX,weightsLoaderFactory:()=>uF,withSaveHandler:()=>EJ,withSaveHandlerSync:()=>DJ});var en={};ee.r(en),ee.d(en,{assertParamsValid:()=>NS,computeFlatOffset:()=>_S,computeOutShape:()=>TS,getNormalizedAxes:()=>$J,isSliceContinous:()=>IS,maskToAxes:()=>LJ,parseSliceParams:()=>W0,sliceInfo:()=>ES,startForAxis:()=>NF,startIndicesWithElidedDims:()=>xF,stopForAxis:()=>TF,stopIndicesWithElidedDims:()=>CF,stridesForAxis:()=>SF,stridesWithElidedDims:()=>bF});var je={};ee.r(je),ee.d(je,{conv2d:()=>NM,depthwiseConv2d:()=>ste,matMul:()=>fN});var hn={};ee.r(hn),ee.d(hn,{collectGatherOpShapeInfo:()=>UN,computeOutShape:()=>oP,segOpComputeOptimalWindowSize:()=>sP});var Xe={};ee.r(Xe),ee.d(Xe,{ERF_A1:()=>EN,ERF_A2:()=>DN,ERF_A3:()=>kN,ERF_A4:()=>AN,ERF_A5:()=>RN,ERF_P:()=>_N,PARALLELIZE_THRESHOLD:()=>CN,RowPartitionType:()=>Lo,SELU_SCALE:()=>b1,SELU_SCALEALPHA:()=>y1,applyActivation:()=>p1,assertAndGetBroadcastShape:()=>mt,assertAxesAreInnerMostDims:()=>Br,assertParamsConsistent:()=>xN,assignToTypedArray:()=>UM,axesAreInnerMostDims:()=>VS,calculateShapes:()=>Tu,checkEinsumDimSizes:()=>LN,checkPadOnDimRoundingMode:()=>as,combineLocations:()=>YF,combineRaggedTensorToTensorShapes:()=>MM,complexWithEvenIndex:()=>BM,complexWithOddIndex:()=>zM,computeConv2DInfo:()=>Ar,computeConv3DInfo:()=>dl,computeDefaultPad:()=>kS,computeDilation2DInfo:()=>dp,computeOptimalWindowSize:()=>g1,computeOutAndReduceShapes:()=>Rr,computeOutShape:()=>Li,computePool2DInfo:()=>Ro,computePool3DInfo:()=>ba,convertConv2DDataFormat:()=>va,decodeEinsumEquation:()=>MN,eitherStridesOrDilationsAreOne:()=>Vr,expandShapeToKeepDim:()=>Jn,exponent:()=>HM,exponents:()=>WM,fromStringArrayToUint8:()=>iP,fromUint8ToStringArray:()=>Ca,getAxesPermutation:()=>Pn,getBroadcastDims:()=>ad,getComplexWithIndex:()=>ON,getEinsumComputePath:()=>$N,getEinsumPermutation:()=>PN,getFusedBiasGradient:()=>f1,getFusedDyActivation:()=>h1,getImageCenter:()=>SN,getInnerMostAxes:()=>Zn,getPermuted:()=>Ip,getRaggedRank:()=>LM,getReductionAxes:()=>pr,getReshaped:()=>Tp,getReshapedPermuted:()=>_p,getRowPartitionTypesHelper:()=>PM,getSliceBeginCoords:()=>NN,getSliceSize:()=>TN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>qM,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>KM,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>XM,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>YM,getSparseReshapeInputOutputMismatchErrorMessage:()=>eP,getSparseReshapeInputOutputMultipleErrorMessage:()=>QM,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>JM,getSparseReshapeNegativeOutputDimErrorMessage:()=>ZM,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>rP,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>zN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>tP,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>nP,getUndoAxesPermutation:()=>pl,isIdentityPermutation:()=>VN,log:()=>HK,mergeRealAndImagArrays:()=>xa,prepareAndValidate:()=>IN,prepareSplitSize:()=>BN,segment_util:()=>hn,shouldFuse:()=>m1,slice_util:()=>en,splitRealAndImagArrays:()=>VM,stridesOrDilationsArePositive:()=>wu,tupleValuesAreOne:()=>hl,upcastType:()=>zs,validateDefaultValueShape:()=>$M,validateInput:()=>sN,validateUpdateShape:()=>yM,warn:()=>lo});var We={};ee.r(We),ee.d(We,{json:()=>Qie});var gt={};ee.r(gt),ee.d(gt,{json:()=>eae});var Ae={};ee.r(Ae),ee.d(Ae,{json:()=>tae});var j={};ee.r(j),ee.d(j,{json:()=>nae});var ge={};ee.r(ge),ee.d(ge,{json:()=>rae});var Se={};ee.r(Se),ee.d(Se,{json:()=>sae});var ce={};ee.r(ce),ee.d(ce,{json:()=>oae});var fe={};ee.r(fe),ee.d(fe,{json:()=>iae});var Me={};ee.r(Me),ee.d(Me,{json:()=>aae});var Le={};ee.r(Le),ee.d(Le,{json:()=>lae});var Ht={};ee.r(Ht),ee.d(Ht,{json:()=>uae});var _t={};ee.r(_t),ee.d(_t,{json:()=>cae});var Vn={};ee.r(Vn),ee.d(Vn,{json:()=>dae});var Rs={};ee.r(Rs),ee.d(Rs,{json:()=>hae});var Gr={};ee.r(Gr),ee.d(Gr,{json:()=>fae});var Ct={};ee.r(Ct),ee.d(Ct,{json:()=>pae});var Bt={};ee.r(Bt),ee.d(Bt,{json:()=>mae});var zt={};ee.r(zt),ee.d(zt,{json:()=>gae});var le={};ee.r(le),ee.d(le,{json:()=>yae});var re={};ee.r(re),ee.d(re,{OP_SCOPE_SUFFIX:()=>OO,abs:()=>fr,acos:()=>_F,acosh:()=>EF,add:()=>ue,addN:()=>HJ,all:()=>DS,any:()=>H0,argMax:()=>ld,argMin:()=>DF,asin:()=>kF,asinh:()=>AF,atan:()=>RF,atan2:()=>OF,atanh:()=>FF,avgPool:()=>j0,avgPool3d:()=>MF,basicLSTMCell:()=>fZ,batchNorm:()=>pp,batchNorm2d:()=>PF,batchNorm3d:()=>LF,batchNorm4d:()=>$F,batchToSpaceND:()=>G0,bincount:()=>VF,bitwiseAnd:()=>CZ,booleanMaskAsync:()=>$ee,broadcastArgs:()=>NZ,broadcastTo:()=>cd,buffer:()=>Tt,cast:()=>Ce,ceil:()=>BF,clipByValue:()=>Ts,clone:()=>pa,complex:()=>il,concat:()=>_n,concat1d:()=>zF,concat2d:()=>UF,concat3d:()=>WF,concat4d:()=>HF,conv1d:()=>RS,conv2d:()=>fl,conv2dTranspose:()=>FS,conv3d:()=>jF,conv3dTranspose:()=>qF,cos:()=>q0,cosh:()=>MS,cosineWindow:()=>cN,cumprod:()=>K0,cumsum:()=>PS,denseBincount:()=>LS,depthToSpace:()=>KF,depthwiseConv2d:()=>mp,diag:()=>qZ,dilation2d:()=>XF,div:()=>Ee,divNoNan:()=>JF,dot:()=>ZF,dropout:()=>CM,einsum:()=>dd,elu:()=>gp,enclosingPowerOfTwo:()=>SM,ensureShape:()=>nY,equal:()=>di,erf:()=>$S,euclideanNorm:()=>eM,exp:()=>ls,expandDims:()=>zr,expm1:()=>tM,eye:()=>BS,fft:()=>c1,fill:()=>id,floor:()=>vp,floorDiv:()=>hS,fused:()=>je,gather:()=>wp,gatherND:()=>Kee,greater:()=>Ws,greaterEqual:()=>ml,ifft:()=>Np,imag:()=>X0,image:()=>Ur,inTopKAsync:()=>Yee,irfft:()=>nN,isFinite:()=>nM,isInf:()=>rM,isNaN:()=>sM,leakyRelu:()=>J0,less:()=>xp,lessEqual:()=>Cu,linalg:()=>OM,linspace:()=>TY,localResponseNormalization:()=>oM,log:()=>uo,log1p:()=>Z0,logSigmoid:()=>iM,logSoftmax:()=>zS,logSumExp:()=>Y0,logicalAnd:()=>Fi,logicalNot:()=>Q0,logicalOr:()=>US,logicalXor:()=>aM,losses:()=>Pne,lowerBound:()=>VY,matMul:()=>Ft,max:()=>Oo,maxPool:()=>t1,maxPool3d:()=>lM,maxPoolWithArgmax:()=>WY,maximum:()=>ya,mean:()=>Hn,meshgrid:()=>jY,min:()=>yp,minimum:()=>Su,mirrorPad:()=>uM,mod:()=>cM,moments:()=>n1,movingAverage:()=>zee,mul:()=>L,multiRNNCell:()=>ZY,multinomial:()=>QY,neg:()=>In,norm:()=>bp,notEqual:()=>fd,oneHot:()=>r1,ones:()=>Is,onesLike:()=>co,op:()=>M,outerProduct:()=>sQ,pad:()=>gl,pad1d:()=>aQ,pad2d:()=>uQ,pad3d:()=>dQ,pad4d:()=>fQ,pool:()=>dM,pow:()=>ga,prelu:()=>o1,print:()=>QO,prod:()=>hM,raggedGather:()=>xQ,raggedRange:()=>SQ,raggedTensorToTensor:()=>TQ,rand:()=>_Q,randomGamma:()=>FQ,randomNormal:()=>GS,randomStandardNormal:()=>LQ,randomUniform:()=>Nu,randomUniformInt:()=>BQ,range:()=>pd,real:()=>Cp,reciprocal:()=>fM,relu:()=>Mi,relu6:()=>qS,reshape:()=>V,reverse:()=>Mo,reverse1d:()=>qQ,reverse2d:()=>XQ,reverse3d:()=>ZQ,reverse4d:()=>QQ,rfft:()=>d1,round:()=>KS,rsqrt:()=>XS,scalar:()=>Ke,scatterND:()=>Wee,searchSorted:()=>WS,selu:()=>JS,separableConv2d:()=>ZS,setdiff1dAsync:()=>oee,sigmoid:()=>ci,sign:()=>pM,signal:()=>Mne,sin:()=>QS,sinh:()=>eN,slice:()=>rt,slice1d:()=>a1,slice2d:()=>tN,slice3d:()=>l1,slice4d:()=>Sp,softmax:()=>u1,softplus:()=>hd,spaceToBatchND:()=>s1,sparse:()=>Lne,sparseToDense:()=>Gee,spectral:()=>Fne,split:()=>Hs,sqrt:()=>$r,square:()=>cn,squaredDifference:()=>rN,squeeze:()=>Yn,stack:()=>_s,step:()=>md,stridedSlice:()=>mM,string:()=>$ne,sub:()=>De,sum:()=>$e,tan:()=>gM,tanh:()=>xu,tensor:()=>ko,tensor1d:()=>Qn,tensor2d:()=>Pi,tensor3d:()=>pF,tensor4d:()=>Tee,tensor5d:()=>Iee,tensor6d:()=>_ee,tensorScatterUpdate:()=>Dee,tile:()=>Fo,topk:()=>bM,transpose:()=>$t,truncatedNormal:()=>oN,unique:()=>vM,unsortedSegmentSum:()=>iN,unstack:()=>Po,upperBound:()=>Mee,variable:()=>wM,where:()=>Xr,whereAsync:()=>xM,zeros:()=>ar,zerosLike:()=>Lt});var O={};ee.r(O),ee.d(O,{addImpl:()=>l$,bincountImpl:()=>rI,bincountReduceImpl:()=>p$,bitwiseAndImpl:()=>m$,castImpl:()=>a$,ceilImpl:()=>g$,concatImpl:()=>y$,equalImpl:()=>w$,expImpl:()=>C$,expm1Impl:()=>N$,floorDivImpl:()=>E$,floorImpl:()=>_$,gatherNdImpl:()=>D$,gatherV2Impl:()=>k$,greaterEqualImpl:()=>R$,greaterImpl:()=>A$,lessEqualImpl:()=>F$,lessImpl:()=>O$,linSpaceImpl:()=>M$,logImpl:()=>P$,maxImpl:()=>L$,maximumImpl:()=>V$,minimumImpl:()=>B$,multiplyImpl:()=>sI,negImpl:()=>U$,notEqualImpl:()=>W$,prodImpl:()=>q$,raggedGatherImpl:()=>X$,raggedRangeImpl:()=>Z$,raggedTensorToTensorImpl:()=>eV,rangeImpl:()=>tV,rsqrtImpl:()=>nV,scatterImpl:()=>Pu,sigmoidImpl:()=>Ule,simpleAbsImpl:()=>c$,sliceImpl:()=>f$,sparseFillEmptyRowsImpl:()=>sV,sparseReshapeImpl:()=>oV,sparseSegmentReductionImpl:()=>cI,sqrtImpl:()=>ppe,squaredDifferenceImpl:()=>iV,staticRegexReplaceImpl:()=>aV,stridedSliceImpl:()=>lV,stringNGramsImpl:()=>uV,stringSplitImpl:()=>cV,stringToHashBucketFastImpl:()=>dV,subImpl:()=>T$,tileImpl:()=>hV,topKImpl:()=>pV,transposeImpl:()=>tI,uniqueImpl:()=>gV});var Ie={};function Ne(n){return"function"==typeof n}function wt(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}ee.r(Ie),ee.d(Ie,{Decoder:()=>UI,Encoder:()=>HSe,PacketType:()=>Vt,protocol:()=>WSe});const xt=wt(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function Ut(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class Kt{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(Ne(r))try{r()}catch(o){t=o instanceof xt?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{vn(o)}catch(i){t=t??[],i instanceof xt?t=[...t,...i.errors]:t.push(i)}}if(t)throw new xt(t)}}add(t){var e;if(t&&t!==this)if(this.closed)vn(t);else{if(t instanceof Kt){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&Ut(e,t)}remove(t){const{_finalizers:e}=this;e&&Ut(e,t),t instanceof Kt&&t._removeParent(this)}}Kt.EMPTY=(()=>{const n=new Kt;return n.closed=!0,n})();const An=Kt.EMPTY;function nr(n){return n instanceof Kt||n&&"closed"in n&&Ne(n.remove)&&Ne(n.add)&&Ne(n.unsubscribe)}function vn(n){Ne(n)?n():n.unsubscribe()}const wn={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},xn={setTimeout(n,t,...e){const{delegate:r}=xn;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=xn;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function Cr(n){xn.setTimeout(()=>{const{onUnhandledError:t}=wn;if(!t)throw n;t(n)})}function xi(){}const ym=Fa("C",void 0,void 0);function Fa(n,t,e){return{kind:n,value:t,error:e}}let Ci=null;function qu(n){if(wn.useDeprecatedSynchronousErrorHandling){const t=!Ci;if(t&&(Ci={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=Ci;if(Ci=null,e)throw r}}else n()}class yo extends Kt{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,nr(t)&&t.add(this)):this.destination=vm}static create(t,e,r){return new Ma(t,e,r)}next(t){this.isStopped?Ji(function jd(n){return Fa("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?Ji(function bm(n){return Fa("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?Ji(ym,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const lv=Function.prototype.bind;function Ku(n,t){return lv.call(n,t)}class Gd{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){Pa(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){Pa(r)}else Pa(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){Pa(e)}}}class Ma extends yo{constructor(t,e,r){let s;if(super(),Ne(t)||!t)s={next:t??void 0,error:e??void 0,complete:r??void 0};else{let o;this&&wn.useDeprecatedNextContext?(o=Object.create(t),o.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&Ku(t.next,o),error:t.error&&Ku(t.error,o),complete:t.complete&&Ku(t.complete,o)}):s=t}this.destination=new Gd(s)}}function Pa(n){wn.useDeprecatedSynchronousErrorHandling?function jo(n){wn.useDeprecatedSynchronousErrorHandling&&Ci&&(Ci.errorThrown=!0,Ci.error=n)}(n):Cr(n)}function Ji(n,t){const{onStoppedNotification:e}=wn;e&&xn.setTimeout(()=>e(n,t))}const vm={closed:!0,next:xi,error:function qr(n){throw n},complete:xi},Bl="function"==typeof Symbol&&Symbol.observable||"@@observable";function bo(n){return n}let Gn=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const o=function La(n){return n&&n instanceof yo||function cv(n){return n&&Ne(n.next)&&Ne(n.error)&&Ne(n.complete)}(n)&&nr(n)}(e)?e:new Ma(e,r,s);return qu(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=zl(r))((s,o)=>{const i=new Ma({next:a=>{try{e(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[Bl](){return this}pipe(...e){return function qd(n){return 0===n.length?bo:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}(e)(this)}toPromise(e){return new(e=zl(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return n.create=t=>new n(t),n})();function zl(n){var t;return null!==(t=n??wn.Promise)&&void 0!==t?t:Promise}const dv=wt(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Go=(()=>{class n extends Gn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new Kd(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new dv}next(e){qu(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){qu(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){qu(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:o}=this;return r||s?An:(this.currentObservers=null,o.push(e),new Kt(()=>{this.currentObservers=null,Ut(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:o}=this;r?e.error(s):o&&e.complete()}asObservable(){const e=new Gn;return e.source=this,e}}return n.create=(t,e)=>new Kd(t,e),n})();class Kd extends Go{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:An}}function Os(n){return t=>{if(function wm(n){return Ne(n?.lift)}(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function ps(n,t,e,r,s){return new Xd(n,t,e,r,s)}class Xd extends yo{constructor(t,e,r,s,o,i){super(t),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function Si(n,t){return Os((e,r)=>{let s=0;e.subscribe(ps(r,o=>{r.next(n.call(t,o,s++))}))})}function Js(n){return this instanceof Js?(this.v=n,this):new Js(n)}function Zd(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),o=[];return s=Object.create(("function"==typeof AsyncIterator?AsyncIterator:Object).prototype),a("next"),a("throw"),a("return",function i(f){return function(p){return Promise.resolve(p).then(f,d)}}),s[Symbol.asyncIterator]=function(){return this},s;function a(f,p){r[f]&&(s[f]=function(g){return new Promise(function(m,y){o.push([f,g,m,y])>1||l(f,g)})},p&&(s[f]=p(s[f])))}function l(f,p){try{!function u(f){f.value instanceof Js?Promise.resolve(f.value.v).then(c,d):h(o[0][2],f)}(r[f](p))}catch(g){h(o[0][3],g)}}function c(f){l("next",f)}function d(f){l("throw",f)}function h(f,p){f(p),o.shift(),o.length&&l(o[0][0],o[0][1])}}function Ul(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function Yu(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=n[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(u){o({value:u,done:a})},i)}(a,l,(i=n[o](i)).done,i.value)})}}}"function"==typeof SuppressedError&&SuppressedError;const Qd=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function eh(n){return Ne(n?.then)}function Pm(n){return Ne(n[Bl])}function Lm(n){return Symbol.asyncIterator&&Ne(n?.[Symbol.asyncIterator])}function $m(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const th=function bv(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function nh(n){return Ne(n?.[th])}function tc(n){return Zd(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield Js(e.read());if(s)return yield Js(void 0);yield yield Js(r)}}finally{e.releaseLock()}})}function rh(n){return Ne(n?.getReader)}function Zs(n){if(n instanceof Gn)return n;if(null!=n){if(Pm(n))return function Wl(n){return new Gn(t=>{const e=n[Bl]();if(Ne(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Qd(n))return function Ys(n){return new Gn(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(eh(n))return function vv(n){return new Gn(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,Cr)})}(n);if(Lm(n))return sh(n);if(nh(n))return function wv(n){return new Gn(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(rh(n))return function Vm(n){return sh(tc(n))}(n)}throw $m(n)}function sh(n){return new Gn(t=>{(function Fs(n,t){var e,r,s,o;return function Jd(n,t,e,r){return new(e||(e=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof e?o:new e(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=Ul(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function wo(n,t,e,r=0,s=!1){const o=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(o),!s)return o}function jl(n,t,e=1/0){return Ne(t)?jl((r,s)=>Si((o,i)=>t(r,o,s,i))(Zs(n(r,s))),e):("number"==typeof t&&(e=t),Os((r,s)=>function Hl(n,t,e,r,s,o,i,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&t.complete()},f=g=>u<r?p(g):l.push(g),p=g=>{o&&t.next(g),u++;let m=!1;Zs(e(g,c++)).subscribe(ps(t,y=>{s?.(y),o?f(y):t.next(y)},()=>{m=!0},void 0,()=>{if(m)try{for(u--;l.length&&u<r;){const y=l.shift();i?wo(t,i,()=>p(y)):p(y)}h()}catch(y){t.error(y)}}))};return n.subscribe(ps(t,f,()=>{d=!0,h()})),()=>{a?.()}}(r,s,n,e)))}const ih=new Gn(n=>n.complete());function rc(n){return n[n.length-1]}function zm(n){return Ne(rc(n))?n.pop():void 0}function ah(n){return function Bm(n){return n&&Ne(n.schedule)}(rc(n))?n.pop():void 0}function uh(n,t=0){return Os((e,r)=>{e.subscribe(ps(r,s=>wo(r,n,()=>r.next(s),t),()=>wo(r,n,()=>r.complete(),t),s=>wo(r,n,()=>r.error(s),t)))})}function ch(n,t=0){return Os((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function dh(n,t){if(!n)throw new Error("Iterable cannot be null");return new Gn(e=>{wo(e,t,()=>{const r=n[Symbol.asyncIterator]();wo(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function Gl(n,t){return t?function Gm(n,t){if(null!=n){if(Pm(n))return function Um(n,t){return Zs(n).pipe(ch(t),uh(t))}(n,t);if(Qd(n))return function Hm(n,t){return new Gn(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(eh(n))return function Wm(n,t){return Zs(n).pipe(ch(t),uh(t))}(n,t);if(Lm(n))return dh(n,t);if(nh(n))return function jm(n,t){return new Gn(e=>{let r;return wo(e,t,()=>{r=n[th](),wo(e,t,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void e.error(i)}o?e.complete():e.next(s)},0,!0)}),()=>Ne(r?.return)&&r.return()})}(n,t);if(rh(n))return function xv(n,t){return dh(tc(n),t)}(n,t)}throw $m(n)}(n,t):Zs(n)}function sc(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new Ma({next:()=>{r.unsubscribe(),n()}});return t(...e).subscribe(r)}function tn(n){for(let t in n)if(n[t]===tn)return t;throw Error("Could not find renamed property on target object.")}function fh(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function nn(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(nn).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function ph(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const qm=tn({__forward_ref__:tn});function un(n){return n.__forward_ref__=un,n.toString=function(){return nn(this())},n}function nt(n){return ql(n)?n():n}function ql(n){return"function"==typeof n&&n.hasOwnProperty(qm)&&n.__forward_ref__===un}class Pe extends Error{constructor(t,e){super(function oc(n,t){return`NG0${Math.abs(n)}${t?": "+t.trim():""}`}(t,e)),this.code=t}}function it(n){return"string"==typeof n?n:null==n?"":String(n)}function b(n,t){throw new Pe(-201,!1)}function Je(n,t){null==n&&function ze(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function Qe(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function ft(n){return{providers:n.providers||[],imports:n.imports||[]}}function Rn(n){return __(n,Xm)||__(n,D_)}function __(n,t){return n.hasOwnProperty(t)?n[t]:null}function E_(n){return n&&(n.hasOwnProperty(Nv)||n.hasOwnProperty(M6))?n[Nv]:null}const Xm=tn({\u0275prov:tn}),Nv=tn({\u0275inj:tn}),D_=tn({ngInjectableDef:tn}),M6=tn({ngInjectorDef:tn});var ht=(()=>((ht=ht||{})[ht.Default=0]="Default",ht[ht.Host=1]="Host",ht[ht.Self=2]="Self",ht[ht.SkipSelf=4]="SkipSelf",ht[ht.Optional=8]="Optional",ht))();let Tv;function xo(n){const t=Tv;return Tv=n,t}function k_(n,t,e){const r=Rn(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&ht.Optional?null:void 0!==t?t:void b(nn(n))}function Va(n){return{toString:n}.toString()}var qo=(()=>((qo=qo||{})[qo.OnPush=0]="OnPush",qo[qo.Default=1]="Default",qo))(),Ni=(()=>{return(n=Ni||(Ni={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",Ni;var n})();const Sn=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),ic={},Xt=[],Jm=tn({\u0275cmp:tn}),Iv=tn({\u0275dir:tn}),_v=tn({\u0275pipe:tn}),A_=tn({\u0275mod:tn}),Yi=tn({\u0275fac:tn}),mh=tn({__NG_ELEMENT_ID__:tn});let L6=0;function gh(n){return Va(()=>{const e=!0===n.standalone,r={},s={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:r,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===qo.OnPush,directiveDefs:null,pipeDefs:null,standalone:e,dependencies:e&&n.dependencies||null,getStandaloneInjector:null,selectors:n.selectors||Xt,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||Ni.Emulated,id:"c"+L6++,styles:n.styles||Xt,_:null,setInput:null,schemas:n.schemas||null,tView:null},o=n.dependencies,i=n.features;return s.inputs=F_(n.inputs,r),s.outputs=F_(n.outputs),i&&i.forEach(a=>a(s)),s.directiveDefs=o?()=>("function"==typeof o?o():o).map(R_).filter(O_):null,s.pipeDefs=o?()=>("function"==typeof o?o():o).map(ys).filter(O_):null,s})}function R_(n){return rn(n)||gs(n)}function O_(n){return null!==n}function Ko(n){return Va(()=>({type:n.type,bootstrap:n.bootstrap||Xt,declarations:n.declarations||Xt,imports:n.imports||Xt,exports:n.exports||Xt,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function F_(n,t){if(null==n)return ic;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,t&&(t[s]=o)}return e}const yt=gh;function rn(n){return n[Jm]||null}function gs(n){return n[Iv]||null}function ys(n){return n[_v]||null}function Ps(n){return Array.isArray(n)&&"object"==typeof n[1]}function Jo(n){return Array.isArray(n)&&!0===n[1]}function kv(n){return 0!=(8&n.flags)}function eg(n){return 2==(2&n.flags)}function tg(n){return 1==(1&n.flags)}function Zo(n){return null!==n.template}function W6(n){return 0!=(256&n[2])}function Yl(n,t){return n.hasOwnProperty(Yi)?n[Yi]:null}class G6{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function Qi(){return L_}function L_(n){return n.type.prototype.ngOnChanges&&(n.setInput=K6),q6}function q6(){const n=V_(this),t=n?.current;if(t){const e=n.previous;if(e===ic)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function K6(n,t,e,r){const s=V_(n)||function X6(n,t){return n[$_]=t}(n,{previous:ic,current:null}),o=s.current||(s.current={}),i=s.previous,a=this.declaredInputs[e],l=i[a];o[a]=new G6(l&&l.currentValue,t,i===ic),n[r]=t}Qi.ngInherit=!0;const $_="__ngSimpleChanges__";function V_(n){return n[$_]||null}function lr(n){for(;Array.isArray(n);)n=n[0];return n}function ng(n,t){return lr(t[n])}function to(n,t){return lr(t[n.index])}function Mv(n,t){return n.data[t]}function no(n,t){const e=t[n];return Ps(e)?e:e[0]}function rg(n){return 64==(64&n[2])}function Ba(n,t){return null==t?null:n[t]}function B_(n){n[18]=0}function Pv(n,t){n[5]+=t;let e=n,r=n[3];for(;null!==r&&(1===t&&1===e[5]||-1===t&&0===e[5]);)r[5]+=t,e=r,r=r[3]}const pt={lFrame:J_(null),bindingsEnabled:!0};function U_(){return pt.bindingsEnabled}function de(){return pt.lFrame.lView}function jt(){return pt.lFrame.tView}function za(n){return pt.lFrame.contextLView=n,n[8]}function Ua(n){return pt.lFrame.contextLView=null,n}function Sr(){let n=W_();for(;null!==n&&64===n.type;)n=n.parent;return n}function W_(){return pt.lFrame.currentTNode}function Ti(n,t){const e=pt.lFrame;e.currentTNode=n,e.isParent=t}function Lv(){return pt.lFrame.isParent}function $v(){pt.lFrame.isParent=!1}function dc(){return pt.lFrame.bindingIndex++}function cU(n,t){const e=pt.lFrame;e.bindingIndex=e.bindingRootIndex=n,Vv(t)}function Vv(n){pt.lFrame.currentDirectiveIndex=n}function q_(){return pt.lFrame.currentQueryIndex}function zv(n){pt.lFrame.currentQueryIndex=n}function hU(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function K_(n,t,e){if(e&ht.SkipSelf){let s=t,o=n;for(;!(s=s.parent,null!==s||e&ht.Host||(s=hU(o),null===s||(o=o[15],10&s.type))););if(null===s)return!1;t=s,n=o}const r=pt.lFrame=X_();return r.currentTNode=t,r.lView=n,!0}function Uv(n){const t=X_(),e=n[1];pt.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function X_(){const n=pt.lFrame,t=null===n?null:n.child;return null===t?J_(n):t}function J_(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function Z_(){const n=pt.lFrame;return pt.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const Y_=Z_;function Wv(){const n=Z_();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function vs(){return pt.lFrame.selectedIndex}function Wa(n){pt.lFrame.selectedIndex=n}function sg(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const o=n.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=o;i&&(n.contentHooks||(n.contentHooks=[])).push(-e,i),a&&((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&&(n.viewHooks||(n.viewHooks=[])).push(-e,l),u&&((n.viewHooks||(n.viewHooks=[])).push(e,u),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,u)),null!=c&&(n.destroyHooks||(n.destroyHooks=[])).push(e,c)}}function og(n,t,e){Q_(n,t,3,e)}function ig(n,t,e,r){(3&n[2])===e&&Q_(n,t,e,r)}function Hv(n,t){let e=n[2];(3&e)===t&&(e&=2047,e+=1,n[2]=e)}function Q_(n,t,e,r){const o=r??-1,i=t.length-1;let a=0;for(let l=void 0!==r?65535&n[18]:0;l<i;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=r&&a>=r)break}else t[l]<0&&(n[18]+=65536),(a<o||-1==o)&&(xU(n,e,t,l),n[18]=(4294901760&n[18])+l+2),l++}function xU(n,t,e,r){const s=e[r]<0,o=e[r+1],a=n[s?-e[r]:e[r]];if(s){if(n[2]>>11<n[18]>>16&&(3&n[2])===t){n[2]+=2048;try{o.call(a)}finally{}}}else try{o.call(a)}finally{}}class Sh{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function ag(n,t,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const o=e[r++],i=e[r++],a=e[r++];n.setAttribute(t,i,a,o)}else{const o=s,i=e[++r];tE(o)?n.setProperty(t,o,i):n.setAttribute(t,o,i),r++}}return r}function eE(n){return 3===n||4===n||6===n}function tE(n){return 64===n.charCodeAt(0)}function lg(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||nE(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function nE(n,t,e,r,s){let o=0,i=n.length;if(-1===t)i=-1;else for(;o<n.length;){const a=n[o++];if("number"==typeof a){if(a===t){i=-1;break}if(a>t){i=o-1;break}}}for(;o<n.length;){const a=n[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[o+1]=s));if(r===n[o+1])return void(n[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(n.splice(i,0,t),o=i+1),n.splice(o++,0,e),null!==r&&n.splice(o++,0,r),null!==s&&n.splice(o++,0,s)}function rE(n){return-1!==n}function hc(n){return 32767&n}function fc(n,t){let e=function IU(n){return n>>16}(n),r=t;for(;e>0;)r=r[15],e--;return r}let Gv=!0;function ug(n){const t=Gv;return Gv=n,t}let _U=0;const Ii={};function Th(n,t){const e=Kv(n,t);if(-1!==e)return e;const r=t[1];r.firstCreatePass&&(n.injectorIndex=t.length,qv(r.data,n),qv(t,null),qv(r.blueprint,null));const s=cg(n,t),o=n.injectorIndex;if(rE(s)){const i=hc(s),a=fc(s,t),l=a[1].data;for(let u=0;u<8;u++)t[o+u]=a[i+u]|l[i+u]}return t[o+8]=s,o}function qv(n,t){n.push(0,0,0,0,0,0,0,0,t)}function Kv(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function cg(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){if(r=hE(s),null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function dg(n,t,e){!function EU(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(mh)&&(r=e[mh]),null==r&&(r=e[mh]=_U++);const s=255&r;t.data[n+(s>>5)]|=1<<s}(n,t,e)}function iE(n,t,e){if(e&ht.Optional||void 0!==n)return n;b()}function aE(n,t,e,r){if(e&ht.Optional&&void 0===r&&(r=null),0==(e&(ht.Self|ht.Host))){const s=n[9],o=xo(void 0);try{return s?s.get(t,r,e&ht.Optional):k_(t,r,e&ht.Optional)}finally{xo(o)}}return iE(r,0,e)}function lE(n,t,e,r=ht.Default,s){if(null!==n){if(1024&t[2]){const i=function OU(n,t,e,r,s){let o=n,i=t;for(;null!==o&&null!==i&&1024&i[2]&&!(256&i[2]);){const a=uE(o,i,e,r|ht.Self,Ii);if(a!==Ii)return a;let l=o.parent;if(!l){const u=i[21];if(u){const c=u.get(e,Ii,r);if(c!==Ii)return c}l=hE(i),i=i[15]}o=l}return s}(n,t,e,r,Ii);if(i!==Ii)return i}const o=uE(n,t,e,r,Ii);if(o!==Ii)return o}return aE(t,e,r,s)}function uE(n,t,e,r,s){const o=function AU(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(mh)?n[mh]:void 0;return"number"==typeof t?t>=0?255&t:RU:t}(e);if("function"==typeof o){if(!K_(t,n,r))return r&ht.Host?iE(s,0,r):aE(t,e,r,s);try{const i=o(r);if(null!=i||r&ht.Optional)return i;b()}finally{Y_()}}else if("number"==typeof o){let i=null,a=Kv(n,t),l=-1,u=r&ht.Host?t[16][6]:null;for((-1===a||r&ht.SkipSelf)&&(l=-1===a?cg(n,t):t[a+8],-1!==l&&dE(r,!1)?(i=t[1],a=hc(l),t=fc(l,t)):a=-1);-1!==a;){const c=t[1];if(cE(o,a,c.data)){const d=kU(a,t,e,i,r,u);if(d!==Ii)return d}l=t[a+8],-1!==l&&dE(r,t[1].data[a+8]===u)&&cE(o,a,t)?(i=c,a=hc(l),t=fc(l,t)):a=-1}}return s}function kU(n,t,e,r,s,o){const i=t[1],a=i.data[n+8],c=hg(a,i,e,null==r?eg(a)&&Gv:r!=i&&0!=(3&a.type),s&ht.Host&&o===a);return null!==c?Ih(t,i,c,a):Ii}function hg(n,t,e,r,s){const o=n.providerIndexes,i=t.data,a=1048575&o,l=n.directiveStart,c=o>>20,h=s?a+c:n.directiveEnd;for(let f=r?a:a+c;f<h;f++){const p=i[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(s){const f=i[l];if(f&&Zo(f)&&f.type===e)return l}return null}function Ih(n,t,e,r){let s=n[e];const o=t.data;if(function CU(n){return n instanceof Sh}(s)){const i=s;i.resolving&&function Sv(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new Pe(-200,`Circular dependency in DI detected for ${n}${e}`)}(function qt(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():it(n)}(o[e]));const a=ug(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?xo(i.injectImpl):null;K_(n,r,ht.Default);try{s=n[e]=i.factory(void 0,o,n,r),t.firstCreatePass&&e>=r.directiveStart&&function wU(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=t.type.prototype;if(r){const i=L_(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,i)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,s),o&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o))}(e,o[e],t)}finally{null!==l&&xo(l),ug(a),i.resolving=!1,Y_()}}return s}function cE(n,t,e){return!!(e[t+(n>>5)]&1<<n)}function dE(n,t){return!(n&ht.Self||n&ht.Host&&t)}class pc{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return lE(this._tNode,this._lView,t,r,e)}}function RU(){return new pc(Sr(),de())}function es(n){return Va(()=>{const t=n.prototype.constructor,e=t[Yi]||Xv(t),r=Object.prototype;let s=Object.getPrototypeOf(n.prototype).constructor;for(;s&&s!==r;){const o=s[Yi]||Xv(s);if(o&&o!==e)return o;s=Object.getPrototypeOf(s)}return o=>new o})}function Xv(n){return ql(n)?()=>{const t=Xv(nt(n));return t&&t()}:Yl(n)}function hE(n){const t=n[1],e=t.type;return 2===e?t.declTNode:1===e?n[6]:null}const gc="__parameters__";function bc(n,t,e){return Va(()=>{const r=function Zv(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,u,c){const d=l.hasOwnProperty(gc)?l[gc]:Object.defineProperty(l,gc,{value:[]})[gc];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(i),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}class dt{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Qe({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function ro(n,t){void 0===t&&(t=n);for(let e=0;e<n.length;e++){let r=n[e];Array.isArray(r)?(t===n&&(t=n.slice(0,e)),ro(r,t)):t!==n&&t.push(r)}return t}function na(n,t){n.forEach(e=>Array.isArray(e)?na(e,t):t(e))}function pE(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function fg(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function so(n,t,e){let r=vc(n,t);return r>=0?n[1|r]=e:(r=~r,function LU(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function Qv(n,t){const e=vc(n,t);if(e>=0)return n[1|e]}function vc(n,t){return function yE(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const o=r+(s-r>>1),i=n[o<<e];if(t===i)return o<<e;i>t?s=o:r=o+1}return~(s<<e)}(n,t,1)}const kh={},tw="__NG_DI_FLAG__",mg="ngTempTokenPath",jU=/\n/gm,bE="__source";let Ah;function wc(n){const t=Ah;return Ah=n,t}function qU(n,t=ht.Default){if(void 0===Ah)throw new Pe(-203,!1);return null===Ah?k_(n,void 0,t):Ah.get(n,t&ht.Optional?null:void 0,t)}function Nt(n,t=ht.Default){return(function P6(){return Tv}()||qU)(nt(n),t)}function nw(n){const t=[];for(let e=0;e<n.length;e++){const r=nt(n[e]);if(Array.isArray(r)){if(0===r.length)throw new Pe(900,!1);let s,o=ht.Default;for(let i=0;i<r.length;i++){const a=r[i],l=XU(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}t.push(Nt(s,o))}else t.push(Nt(r))}return t}function Rh(n,t){return n[tw]=t,n.prototype[tw]=t,n}function XU(n){return n[tw]}const gg=Rh(bc("Optional"),8),yg=Rh(bc("SkipSelf"),4);var Ls=(()=>((Ls=Ls||{})[Ls.Important=1]="Important",Ls[Ls.DashCase=2]="DashCase",Ls))();const aw=new Map;let f5=0;const uw="__ngContext__";function ts(n,t){Ps(t)?(n[uw]=t[20],function m5(n){aw.set(n[20],n)}(t)):n[uw]=t}function dw(n,t){return undefined(n,t)}function Ph(n){const t=n[3];return Jo(t)?t[3]:t}function hw(n){return VE(n[13])}function fw(n){return VE(n[4])}function VE(n){for(;null!==n&&!Jo(n);)n=n[4];return n}function Cc(n,t,e,r,s){if(null!=r){let o,i=!1;Jo(r)?o=r:Ps(r)&&(i=!0,r=r[0]);const a=lr(r);0===n&&null!==e?null==s?jE(t,e,a):Ql(t,e,a,s||null,!0):1===n&&null!==e?Ql(t,e,a,s||null,!0):2===n?function ww(n,t,e){const r=wg(n,t);r&&function L5(n,t,e,r){n.removeChild(t,e,r)}(n,r,t,e)}(t,a,i):3===n&&t.destroyNode(a),null!=o&&function B5(n,t,e,r,s){const o=e[7];o!==lr(e)&&Cc(t,n,r,o,s);for(let a=10;a<e.length;a++){const l=e[a];Lh(l[1],l,n,t,r,o)}}(t,n,o,e,s)}}function mw(n,t,e){return n.createElement(t,e)}function zE(n,t){const e=n[9],r=e.indexOf(t),s=t[3];512&t[2]&&(t[2]&=-513,Pv(s,-1)),e.splice(r,1)}function gw(n,t){if(n.length<=10)return;const e=10+t,r=n[e];if(r){const s=r[17];null!==s&&s!==n&&zE(s,r),t>0&&(n[e-1][4]=r[4]);const o=fg(n,10+t);!function D5(n,t){Lh(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(r[1],r);const i=o[19];null!==i&&i.detachView(o[1]),r[3]=null,r[4]=null,r[2]&=-65}return r}function UE(n,t){if(!(128&t[2])){const e=t[11];e.destroyNode&&Lh(n,t,e,3,null,null),function R5(n){let t=n[13];if(!t)return yw(n[1],n);for(;t;){let e=null;if(Ps(t))e=t[13];else{const r=t[10];r&&(e=r)}if(!e){for(;t&&!t[4]&&t!==n;)Ps(t)&&yw(t[1],t),t=t[3];null===t&&(t=n),Ps(t)&&yw(t[1],t),e=t&&t[4]}t=e}}(t)}}function yw(n,t){if(!(128&t[2])){t[2]&=-65,t[2]|=128,function P5(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof Sh)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];try{l.call(a)}finally{}}else try{o.call(s)}finally{}}}}(n,t),function M5(n,t){const e=n.cleanup,r=t[7];let s=-1;if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+1],a="function"==typeof i?i(t):lr(t[i]),l=r[s=e[o+2]],u=e[o+3];"boolean"==typeof u?a.removeEventListener(e[o],l,u):u>=0?r[s=u]():r[s=-u].unsubscribe(),o+=2}else{const i=r[s=e[o+1]];e[o].call(i)}if(null!==r){for(let o=s+1;o<r.length;o++)(0,r[o])();t[7]=null}}(n,t),1===t[1].type&&t[11].destroy();const e=t[17];if(null!==e&&Jo(t[3])){e!==t[3]&&zE(e,t);const r=t[19];null!==r&&r.detachView(n)}!function g5(n){aw.delete(n[20])}(t)}}function WE(n,t,e){return function HE(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[0];if(2&r.flags){const s=n.data[r.directiveStart].encapsulation;if(s===Ni.None||s===Ni.Emulated)return null}return to(r,e)}(n,t.parent,e)}function Ql(n,t,e,r,s){n.insertBefore(t,e,r,s)}function jE(n,t,e){n.appendChild(t,e)}function GE(n,t,e,r,s){null!==r?Ql(n,t,e,r,s):jE(n,t,e)}function wg(n,t){return n.parentNode(t)}let Nw,XE=function KE(n,t,e){return 40&n.type?to(n,e):null};function xg(n,t,e,r){const s=WE(n,r,t),o=t[11],a=function qE(n,t,e){return XE(n,t,e)}(r.parent||t[6],r,t);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)GE(o,s,e[l],a,!1);else GE(o,s,e,a,!1)}function Cg(n,t){if(null!==t){const e=t.type;if(3&e)return to(t,n);if(4&e)return vw(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return Cg(n,r);{const s=n[t.index];return Jo(s)?vw(-1,s):lr(s)}}if(32&e)return dw(t,n)()||lr(n[t.index]);{const r=ZE(n,t);return null!==r?Array.isArray(r)?r[0]:Cg(Ph(n[16]),r):Cg(n,t.next)}}return null}function ZE(n,t){return null!==t?n[16][6].projection[t.projection]:null}function vw(n,t){const e=10+n+1;if(e<t.length){const r=t[e],s=r[1].firstChild;if(null!==s)return Cg(r,s)}return t[7]}function xw(n,t,e,r,s,o,i){for(;null!=e;){const a=r[e.index],l=e.type;if(i&&0===t&&(a&&ts(lr(a),r),e.flags|=4),64!=(64&e.flags))if(8&l)xw(n,t,e.child,r,s,o,!1),Cc(t,n,s,a,o);else if(32&l){const u=dw(e,r);let c;for(;c=u();)Cc(t,n,s,c,o);Cc(t,n,s,a,o)}else 16&l?YE(n,t,r,e,s,o):Cc(t,n,s,a,o);e=i?e.projectionNext:e.next}}function Lh(n,t,e,r,s,o){xw(e,r,n.firstChild,t,s,o,!1)}function YE(n,t,e,r,s,o){const i=e[16],l=i[6].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)Cc(t,n,s,l[u],o);else xw(n,t,l,i[3],s,o,!0)}function QE(n,t,e){n.setAttribute(t,"style",e)}function Cw(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}const fD=new dt("ENVIRONMENT_INITIALIZER"),pD=new dt("INJECTOR",-1),mD=new dt("INJECTOR_DEF_TYPES");class gD{get(t,e=kh){if(e===kh){const r=new Error(`NullInjectorError: No provider for ${nn(t)}!`);throw r.name="NullInjectorError",r}return e}}function mW(...n){return{\u0275providers:yD(0,n)}}function yD(n,...t){const e=[],r=new Set;let s;return na(t,o=>{const i=o;kw(i,e,[],r)&&(s||(s=[]),s.push(i))}),void 0!==s&&bD(s,e),e}function bD(n,t){for(let e=0;e<n.length;e++){const{providers:s}=n[e];na(s,o=>{t.push(o)})}}function kw(n,t,e,r){if(!(n=nt(n)))return!1;let s=null,o=E_(n);const i=!o&&rn(n);if(o||i){if(i&&!i.standalone)return!1;s=n}else{const l=n.ngModule;if(o=E_(l),!o)return!1;s=l}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const l="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const u of l)kw(u,t,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let u;r.add(s);try{na(o.imports,c=>{kw(c,t,e,r)&&(u||(u=[]),u.push(c))})}finally{}void 0!==u&&bD(u,t)}if(!a){const u=Yl(s)||(()=>new s);t.push({provide:s,useFactory:u,deps:Xt},{provide:mD,useValue:s,multi:!0},{provide:fD,useValue:()=>Nt(s),multi:!0})}const l=o.providers;null==l||a||na(l,c=>{t.push(c)})}}return s!==n&&void 0!==n.providers}const gW=tn({provide:String,useValue:tn});function Aw(n){return null!==n&&"object"==typeof n&&gW in n}function tu(n){return"function"==typeof n}const Rw=new dt("Set Injector scope."),Ig={},bW={};let Ow;function _g(){return void 0===Ow&&(Ow=new gD),Ow}class Sc{}class xD extends Sc{constructor(t,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Mw(t,i=>this.processProvider(i)),this.records.set(pD,Nc(void 0,this)),s.has("environment")&&this.records.set(Sc,Nc(void 0,this));const o=this.records.get(Rw);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(mD.multi,Xt,ht.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){this._onDestroyHooks.push(t)}runInContext(t){this.assertNotDestroyed();const e=wc(this),r=xo(void 0);try{return t()}finally{wc(e),xo(r)}}get(t,e=kh,r=ht.Default){this.assertNotDestroyed();const s=wc(this),o=xo(void 0);try{if(!(r&ht.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function SW(n){return"function"==typeof n||"object"==typeof n&&n instanceof dt}(t)&&Rn(t);a=l&&this.injectableDefInScope(l)?Nc(Fw(t),Ig):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&ht.Self?_g():this.parent).get(t,e=r&ht.Optional&&e===kh?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[mg]=i[mg]||[]).unshift(nn(t)),s)throw i;return function JU(n,t,e,r){const s=n[mg];throw t[bE]&&s.unshift(t[bE]),n.message=function ZU(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let s=nn(t);if(Array.isArray(t))s=t.map(nn).join(" -> ");else if("object"==typeof t){let o=[];for(let i in t)if(t.hasOwnProperty(i)){let a=t[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):nn(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace(jU,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[mg]=null,n}(i,t,"R3InjectorError",this.source)}throw i}finally{xo(o),wc(s)}}resolveInjectorInitializers(){const t=wc(this),e=xo(void 0);try{const r=this.get(fD.multi,Xt,ht.Self);for(const s of r)s()}finally{wc(t),xo(e)}}toString(){const t=[],e=this.records;for(const r of e.keys())t.push(nn(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Pe(205,!1)}processProvider(t){let e=tu(t=nt(t))?t:nt(t&&t.provide);const r=function wW(n){return Aw(n)?Nc(void 0,n.useValue):Nc(CD(n),Ig)}(t);if(tu(t)||!0!==t.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=Nc(void 0,Ig,!0),s.factory=()=>nw(s.multi),this.records.set(e,s)),e=t,s.multi.push(t)}this.records.set(e,r)}hydrate(t,e){return e.value===Ig&&(e.value=bW,e.value=e.factory()),"object"==typeof e.value&&e.value&&function CW(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=nt(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function Fw(n){const t=Rn(n),e=null!==t?t.factory:Yl(n);if(null!==e)return e;if(n instanceof dt)throw new Pe(204,!1);if(n instanceof Function)return function vW(n){const t=n.length;if(t>0)throw function Dh(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}(t,"?"),new Pe(204,!1);const e=function O6(n){const t=n&&(n[Xm]||n[D_]);if(t){const e=function F6(n){if(n.hasOwnProperty("name"))return n.name;const t=(""+n).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),t}return null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new Pe(204,!1)}function CD(n,t,e){let r;if(tu(n)){const s=nt(n);return Yl(s)||Fw(s)}if(Aw(n))r=()=>nt(n.useValue);else if(function wD(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...nw(n.deps||[]));else if(function vD(n){return!(!n||!n.useExisting)}(n))r=()=>Nt(nt(n.useExisting));else{const s=nt(n&&(n.useClass||n.provide));if(!function xW(n){return!!n.deps}(n))return Yl(s)||Fw(s);r=()=>new s(...nw(n.deps))}return r}function Nc(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function NW(n){return!!n.\u0275providers}function Mw(n,t){for(const e of n)Array.isArray(e)?Mw(e,t):NW(e)?Mw(e.\u0275providers,t):t(e)}class SD{}class _W{resolveComponentFactory(t){throw function IW(n){const t=Error(`No component factory found for ${nn(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let Eg=(()=>{class n{}return n.NULL=new _W,n})();function EW(){return Tc(Sr(),de())}function Tc(n,t){return new Yo(to(n,t))}let Yo=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=EW,n})();function DW(n){return n instanceof Yo?n.nativeElement:n}class TD{}let nu=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function kW(){const n=de(),e=no(Sr().index,n);return(Ps(e)?e:n)[11]}(),n})(),AW=(()=>{class n{}return n.\u0275prov=Qe({token:n,providedIn:"root",factory:()=>null}),n})();class Dg{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const RW=new Dg("14.3.0"),Pw={};function $w(n){return n.ngOriginalError}class Ic{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&$w(t);for(;e&&$w(e);)e=$w(e);return e||null}}function _D(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const o=t.length;if(s+o===r||n.charCodeAt(s+o)<=32)return s}e=s+1}}const ED="ng-template";function WW(n,t,e){let r=0;for(;r<n.length;){let s=n[r++];if(e&&"class"===s){if(s=n[r],-1!==_D(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<n.length&&"string"==typeof(s=n[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function DD(n){return 4===n.type&&n.value!==ED}function HW(n,t,e){return t===(4!==n.type||e?n.value:ED)}function jW(n,t,e){let r=4;const s=n.attrs||[],o=function KW(n){for(let t=0;t<n.length;t++)if(eE(n[t]))return t;return n.length}(s);let i=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!HW(n,l,e)||""===l&&1===t.length){if(Qo(r))return!1;i=!0}}else{const u=8&r?l:t[++a];if(8&r&&null!==n.attrs){if(!WW(n.attrs,u,e)){if(Qo(r))return!1;i=!0}continue}const d=GW(8&r?"class":l,s,DD(n),e);if(-1===d){if(Qo(r))return!1;i=!0;continue}if(""!==u){let h;h=d>o?"":s[d+1].toLowerCase();const f=8&r?h:null;if(f&&-1!==_D(f,u,0)||2&r&&u!==h){if(Qo(r))return!1;i=!0}}}}else{if(!i&&!Qo(r)&&!Qo(l))return!1;if(i&&Qo(l))continue;i=!1,r=l|1&r}}return Qo(r)||i}function Qo(n){return 0==(1&n)}function GW(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let o=!1;for(;s<t.length;){const i=t[s];if(i===n)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function XW(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function kD(n,t,e=!1){for(let r=0;r<t.length;r++)if(jW(n,t[r],e))return!0;return!1}function AD(n,t){return n?":not("+t.trim()+")":t}function ZW(n){let t=n[0],e=1,r=2,s="",o=!1;for(;e<n.length;){let i=n[e];if("string"==typeof i)if(2&r){const a=n[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!Qo(i)&&(t+=AD(o,s),s=""),r=i,o=o||!Qo(r);e++}return""!==s&&(t+=AD(o,s)),t}const bt={};function sr(n){RD(jt(),de(),vs()+n,!1)}function RD(n,t,e,r){if(!r)if(3==(3&t[2])){const o=n.preOrderCheckHooks;null!==o&&og(t,o,e)}else{const o=n.preOrderHooks;null!==o&&ig(t,o,0,e)}Wa(e)}function PD(n,t=null,e=null,r){const s=LD(n,t,e,r);return s.resolveInjectorInitializers(),s}function LD(n,t=null,e=null,r,s=new Set){const o=[e||Xt,mW(n)];return r=r||("object"==typeof n?void 0:nn(n)),new xD(o,t||_g(),r||null,s)}let oa=(()=>{class n{static create(e,r){if(Array.isArray(e))return PD({name:""},r,e,"");{const s=e.name??"";return PD({name:s},e.parent,e.providers,s)}}}return n.THROW_IF_NOT_FOUND=kh,n.NULL=new gD,n.\u0275prov=Qe({token:n,providedIn:"any",factory:()=>Nt(pD)}),n.__NG_ELEMENT_ID__=-1,n})();function be(n,t=ht.Default){const e=de();return null===e?Nt(n,t):lE(Sr(),e,nt(n),t)}function Ag(n,t){return n<<17|t<<2}function ei(n){return n>>17&32767}function Ww(n){return 2|n}function ia(n){return(131068&n)>>2}function Hw(n,t){return-131069&n|t<<2}function jw(n){return 1|n}function ek(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],o=e[r+1];if(-1!==o){const i=n.data[o];zv(s),i.contentQueries(2,t[o],o)}}}function Fg(n,t,e,r,s,o,i,a,l,u,c){const d=t.blueprint.slice();return d[0]=s,d[2]=76|r,(null!==c||n&&1024&n[2])&&(d[2]|=1024),B_(d),d[3]=d[15]=n,d[8]=e,d[10]=i||n&&n[10],d[11]=a||n&&n[11],d[12]=l||n&&n[12]||null,d[9]=u||n&&n[9]||null,d[6]=o,d[20]=function p5(){return f5++}(),d[21]=c,d[16]=2==t.type?n[16]:d,d}function Dc(n,t,e,r,s){let o=n.data[t];if(null===o)o=function Qw(n,t,e,r,s){const o=W_(),i=Lv(),l=n.data[t]=function F8(n,t,e,r,s,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=l),null!==o&&(i?null==o.child&&null!==l.parent&&(o.child=l):null===o.next&&(o.next=l)),l}(n,t,e,r,s),function uU(){return pt.lFrame.inI18n}()&&(o.flags|=64);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function Ch(){const n=pt.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return Ti(o,!0),o}function kc(n,t,e,r){if(0===e)return-1;const s=t.length;for(let o=0;o<e;o++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function ex(n,t,e){Uv(t);try{const r=n.viewQuery;null!==r&&lx(1,r,e);const s=n.template;null!==s&&tk(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&ek(n,t),n.staticViewQueries&&lx(2,n.viewQuery,e);const o=n.components;null!==o&&function A8(n,t){for(let e=0;e<t.length;e++)J8(n,t[e])}(t,o)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[2]&=-5,Wv()}}function Mg(n,t,e,r){const s=t[2];if(128!=(128&s)){Uv(t);try{B_(t),function j_(n){return pt.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&tk(n,t,e,2,r);const i=3==(3&s);if(i){const u=n.preOrderCheckHooks;null!==u&&og(t,u,null)}else{const u=n.preOrderHooks;null!==u&&ig(t,u,0,null),Hv(t,0)}if(function K8(n){for(let t=hw(n);null!==t;t=fw(t)){if(!t[2])continue;const e=t[9];for(let r=0;r<e.length;r++){const s=e[r],o=s[3];0==(512&s[2])&&Pv(o,1),s[2]|=512}}}(t),function q8(n){for(let t=hw(n);null!==t;t=fw(t))for(let e=10;e<t.length;e++){const r=t[e],s=r[1];rg(r)&&Mg(s,r,s.template,r[8])}}(t),null!==n.contentQueries&&ek(n,t),i){const u=n.contentCheckHooks;null!==u&&og(t,u)}else{const u=n.contentHooks;null!==u&&ig(t,u,1),Hv(t,1)}!function D8(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)Wa(~s);else{const o=s,i=e[++r],a=e[++r];cU(i,o),a(2,t[o])}}}finally{Wa(-1)}}(n,t);const a=n.components;null!==a&&function k8(n,t){for(let e=0;e<t.length;e++)X8(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&lx(2,l,r),i){const u=n.viewCheckHooks;null!==u&&og(t,u)}else{const u=n.viewHooks;null!==u&&ig(t,u,2),Hv(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[2]&=-41,512&t[2]&&(t[2]&=-513,Pv(t[3],-1))}finally{Wv()}}}function tk(n,t,e,r,s){const o=vs(),i=2&r;try{Wa(-1),i&&t.length>22&&RD(n,t,22,!1),e(r,s)}finally{Wa(o)}}function nk(n,t,e){if(kv(t)){const s=t.directiveEnd;for(let o=t.directiveStart;o<s;o++){const i=n.data[o];i.contentQueries&&i.contentQueries(1,e[o],o)}}}function tx(n,t,e){!U_()||(function V8(n,t,e,r){const s=e.directiveStart,o=e.directiveEnd;n.firstCreatePass||Th(e,t),ts(r,t);const i=e.initialInputs;for(let a=s;a<o;a++){const l=n.data[a],u=Zo(l);u&&H8(t,e,l);const c=Ih(t,n,a,e);ts(c,t),null!==i&&j8(0,a-s,c,l,0,i),u&&(no(e.index,t)[8]=c)}}(n,t,e,to(e,t)),128==(128&e.flags)&&function B8(n,t,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,i=function dU(){return pt.lFrame.currentDirectiveIndex}();try{Wa(o);for(let a=r;a<s;a++){const l=n.data[a],u=t[a];Vv(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&uk(l,u)}}finally{Wa(-1),Vv(i)}}(n,t,e))}function nx(n,t,e=to){const r=t.localNames;if(null!==r){let s=t.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(t,n):n[i];n[s++]=a}}}function rk(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=rx(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function rx(n,t,e,r,s,o,i,a,l,u){const c=22+r,d=c+s,h=function R8(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:bt);return e}(c,d),f="function"==typeof u?u():u;return h[1]={type:n,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:t,data:h.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1}}function sk(n,t,e,r){const s=pk(t);null===e?s.push(r):(s.push(e),n.firstCreatePass&&mk(n).push(r,s.length-1))}function ok(n,t,e){for(let r in n)if(n.hasOwnProperty(r)){const s=n[r];(e=null===e?{}:e).hasOwnProperty(r)?e[r].push(t,s):e[r]=[t,s]}return e}function ik(n,t){const r=t.directiveEnd,s=n.data,o=t.attrs,i=[];let a=null,l=null;for(let u=t.directiveStart;u<r;u++){const c=s[u],d=c.inputs,h=null===o||DD(t)?null:G8(d,o);i.push(h),a=ok(d,u,a),l=ok(c.outputs,u,l)}null!==a&&(a.hasOwnProperty("class")&&(t.flags|=16),a.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=i,t.inputs=a,t.outputs=l}function ak(n,t){const e=no(t,n);16&e[2]||(e[2]|=32)}function sx(n,t,e,r){let s=!1;if(U_()){const o=function z8(n,t,e){const r=n.directiveRegistry;let s=null;if(r)for(let o=0;o<r.length;o++){const i=r[o];kD(e,i.selectors,!1)&&(s||(s=[]),dg(Th(e,t),n,i.type),Zo(i)?(ck(n,e),s.unshift(i)):s.push(i))}return s}(n,t,e),i=null===r?null:{"":-1};if(null!==o){s=!0,dk(e,n.data.length,o.length);for(let c=0;c<o.length;c++){const d=o[c];d.providersResolver&&d.providersResolver(d)}let a=!1,l=!1,u=kc(n,t,o.length,null);for(let c=0;c<o.length;c++){const d=o[c];e.mergedAttrs=lg(e.mergedAttrs,d.hostAttrs),hk(n,e,t,u,d),W8(u,d,i),null!==d.contentQueries&&(e.flags|=8),(null!==d.hostBindings||null!==d.hostAttrs||0!==d.hostVars)&&(e.flags|=128);const h=d.type.prototype;!a&&(h.ngOnChanges||h.ngOnInit||h.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),a=!0),!l&&(h.ngOnChanges||h.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),l=!0),u++}ik(n,e)}i&&function U8(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const o=e[t[s+1]];if(null==o)throw new Pe(-301,!1);r.push(t[s],o)}}}(e,r,i)}return e.mergedAttrs=lg(e.mergedAttrs,e.attrs),s}function lk(n,t,e,r,s,o){const i=o.hostBindings;if(i){let a=n.hostBindingOpCodes;null===a&&(a=n.hostBindingOpCodes=[]);const l=~t.index;(function $8(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(a)!=l&&a.push(l),a.push(r,s,i)}}function uk(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function ck(n,t){t.flags|=2,(n.components||(n.components=[])).push(t.index)}function W8(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;Zo(t)&&(e[""]=n)}}function dk(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}function hk(n,t,e,r,s){n.data[r]=s;const o=s.factory||(s.factory=Yl(s.type)),i=new Sh(o,Zo(s),be);n.blueprint[r]=i,e[r]=i,lk(n,t,0,r,kc(n,e,s.hostVars,bt),s)}function H8(n,t,e){const r=to(t,n),s=rk(e),o=n[10],i=Pg(n,Fg(n,s,null,e.onPush?32:16,r,t,o,o.createRenderer(r,e),null,null,null));n[t.index]=i}function j8(n,t,e,r,s,o){const i=o[t];if(null!==i){const a=r.setInput;for(let l=0;l<i.length;){const u=i[l++],c=i[l++],d=i[l++];null!==a?r.setInput(e,d,u,c):e[c]=d}}}function G8(n,t){let e=null,r=0;for(;r<t.length;){const s=t[r];if(0!==s)if(5!==s){if("number"==typeof s)break;n.hasOwnProperty(s)&&(null===e&&(e=[]),e.push(s,n[s],t[r+1])),r+=2}else r+=2;else r+=4}return e}function fk(n,t,e,r){return new Array(n,!0,!1,t,null,0,r,e,null,null)}function X8(n,t){const e=no(t,n);if(rg(e)){const r=e[1];48&e[2]?Mg(r,e,r.template,e[8]):e[5]>0&&ix(e)}}function ix(n){for(let r=hw(n);null!==r;r=fw(r))for(let s=10;s<r.length;s++){const o=r[s];if(rg(o))if(512&o[2]){const i=o[1];Mg(i,o,i.template,o[8])}else o[5]>0&&ix(o)}const e=n[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=no(e[r],n);rg(s)&&s[5]>0&&ix(s)}}function J8(n,t){const e=no(t,n),r=e[1];(function Z8(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])})(r,e),ex(r,e,e[8])}function Pg(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function ax(n){for(;n;){n[2]|=32;const t=Ph(n);if(W6(n)&&!t)return n;n=t}return null}function Lg(n,t,e,r=!0){const s=t[10];s.begin&&s.begin();try{Mg(n,t,n.template,e)}catch(i){throw r&&yk(t,i),i}finally{s.end&&s.end()}}function lx(n,t,e){zv(0),t(n,e)}function pk(n){return n[7]||(n[7]=[])}function mk(n){return n.cleanup||(n.cleanup=[])}function yk(n,t){const e=n[9],r=e?e.get(Ic,null):null;r&&r.handleError(t)}function ux(n,t,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++],l=t[i],u=n.data[i];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function $g(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,o=0;if(null!==t)for(let i=0;i<t.length;i++){const a=t[i];"number"==typeof a?o=a:1==o?s=ph(s,a):2==o&&(r=ph(r,a+": "+t[++i]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}function Vg(n,t,e,r,s=!1){for(;null!==e;){const o=t[e.index];if(null!==o&&r.push(lr(o)),Jo(o))for(let a=10;a<o.length;a++){const l=o[a],u=l[1].firstChild;null!==u&&Vg(l[1],l,u,r)}const i=e.type;if(8&i)Vg(n,t,e.child,r);else if(32&i){const a=dw(e,t);let l;for(;l=a();)r.push(l)}else if(16&i){const a=ZE(t,e);if(Array.isArray(a))r.push(...a);else{const l=Ph(t[16]);Vg(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class zh{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Vg(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Jo(t)){const e=t[8],r=e?e.indexOf(this):-1;r>-1&&(gw(t,r),fg(e,r))}this._attachedToViewContainer=!1}UE(this._lView[1],this._lView)}onDestroy(t){sk(this._lView[1],this._lView,null,t)}markForCheck(){ax(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){Lg(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Pe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function A5(n,t){Lh(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Pe(902,!1);this._appRef=t}}class Y8 extends zh{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;Lg(t[1],t,t[8],!1)}checkNoChanges(){}get context(){return null}}class cx extends Eg{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=rn(t);return new Uh(e,this.ngModule)}}function bk(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class eH{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){const s=this.injector.get(t,Pw,r);return s!==Pw||e===Pw?s:this.parentInjector.get(t,e,r)}}class Uh extends SD{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function YW(n){return n.map(ZW).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return bk(this.componentDef.inputs)}get outputs(){return bk(this.componentDef.outputs)}create(t,e,r,s){let o=(s=s||this.ngModule)instanceof Sc?s:s?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const i=o?new eH(t,o):t,a=i.get(TD,null);if(null===a)throw new Pe(407,!1);const l=i.get(AW,null),u=a.createRenderer(null,this.componentDef),c=this.componentDef.selectors[0][0]||"div",d=r?function O8(n,t,e){return n.selectRootElement(t,e===Ni.ShadowDom)}(u,r,this.componentDef.encapsulation):mw(u,c,function Q8(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(c)),h=this.componentDef.onPush?288:272,f=rx(0,null,null,1,0,null,null,null,null,null),p=Fg(null,f,null,h,null,null,a,u,l,i,null);let g,m;Uv(p);try{const y=function rH(n,t,e,r,s,o){const i=e[1];e[22]=n;const l=Dc(i,22,2,"#host",null),u=l.mergedAttrs=t.hostAttrs;null!==u&&($g(l,u,!0),null!==n&&(ag(s,n,u),null!==l.classes&&Cw(s,n,l.classes),null!==l.styles&&QE(s,n,l.styles)));const c=r.createRenderer(n,t),d=Fg(e,rk(t),null,t.onPush?32:16,e[22],l,r,c,o||null,null,null);return i.firstCreatePass&&(dg(Th(l,e),i,t.type),ck(i,l),dk(l,e.length,1)),Pg(e,d),e[22]=d}(d,this.componentDef,p,a,u);if(d)if(r)ag(u,d,["ng-version",RW.full]);else{const{attrs:v,classes:w}=function QW(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let o=n[r];if("string"==typeof o)2===s?""!==o&&t.push(o,n[++r]):8===s&&e.push(o);else{if(!Qo(s))break;s=o}r++}return{attrs:t,classes:e}}(this.componentDef.selectors[0]);v&&ag(u,d,v),w&&w.length>0&&Cw(u,d,w.join(" "))}if(m=Mv(f,22),void 0!==e){const v=m.projection=[];for(let w=0;w<this.ngContentSelectors.length;w++){const x=e[w];v.push(null!=x?Array.from(x):null)}}g=function sH(n,t,e,r){const s=e[1],o=function L8(n,t,e){const r=Sr();n.firstCreatePass&&(e.providersResolver&&e.providersResolver(e),hk(n,r,t,kc(n,t,1,null),e),ik(n,r));const s=Ih(t,n,r.directiveStart,r);ts(s,t);const o=to(r,t);return o&&ts(o,t),s}(s,e,t);if(n[8]=e[8]=o,null!==r)for(const a of r)a(o,t);if(t.contentQueries){const a=Sr();t.contentQueries(1,o,a.directiveStart)}const i=Sr();return!s.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(Wa(i.index),lk(e[1],i,0,i.directiveStart,i.directiveEnd,t),uk(t,o)),o}(y,this.componentDef,p,[oH]),ex(f,p,null)}finally{Wv()}return new nH(this.componentType,g,Tc(m,p),p,m)}}class nH extends class TW{}{constructor(t,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=e,this.hostView=this.changeDetectorRef=new Y8(s),this.componentType=t}setInput(t,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[t])){const o=this._rootLView;ux(o[1],o,s,t,e),ak(o,this._tNode.index)}}get injector(){return new pc(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function oH(){const n=Sr();sg(de()[1],n)}function sn(n){let t=function vk(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(Zo(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Pe(903,!1);s=t.\u0275dir}if(s){if(e){r.push(s);const i=n;i.inputs=dx(n.inputs),i.declaredInputs=dx(n.declaredInputs),i.outputs=dx(n.outputs);const a=s.hostBindings;a&&uH(n,a);const l=s.viewQuery,u=s.contentQueries;if(l&&aH(n,l),u&&lH(n,u),fh(n.inputs,s.inputs),fh(n.declaredInputs,s.declaredInputs),fh(n.outputs,s.outputs),Zo(s)&&s.data.animation){const c=n.data;c.animation=(c.animation||[]).concat(s.data.animation)}}const o=s.features;if(o)for(let i=0;i<o.length;i++){const a=o[i];a&&a.ngInherit&&a(n),a===sn&&(e=!1)}}t=Object.getPrototypeOf(t)}!function iH(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=lg(s.hostAttrs,e=lg(e,s.hostAttrs))}}(r)}function dx(n){return n===ic?{}:n===Xt?[]:n}function aH(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function lH(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,o)=>{t(r,s,o),e(r,s,o)}:t}function uH(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}let Bg=null;function ru(){if(!Bg){const n=Sn.Symbol;if(n&&n.iterator)Bg=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const r=t[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(Bg=r)}}}return Bg}function Wh(n){return!!function hx(n){return null!==n&&("function"==typeof n||"object"==typeof n)}(n)&&(Array.isArray(n)||!(n instanceof Map)&&ru()in n)}function ns(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function ti(n,t,e,r,s,o,i,a){const l=de(),u=jt(),c=n+22,d=u.firstCreatePass?function yH(n,t,e,r,s,o,i,a,l){const u=t.consts,c=Dc(t,n,4,i||null,Ba(u,a));sx(t,e,c,Ba(u,l)),sg(t,c);const d=c.tViews=rx(2,c,r,s,o,t.directiveRegistry,t.pipeRegistry,null,t.schemas,u);return null!==t.queries&&(t.queries.template(t,c),d.queries=t.queries.embeddedTView(c)),c}(c,u,l,t,e,r,s,o,i):u.data[c];Ti(d,!1);const h=l[11].createComment("");xg(u,l,h,d),ts(h,l),Pg(l,l[c]=fk(h,l,h,d)),tg(d)&&tx(u,l,d),null!=i&&nx(l,d,a)}function Tr(n,t,e){const r=de();return ns(r,dc(),t)&&function oo(n,t,e,r,s,o,i,a){const l=to(t,e);let c,u=t.inputs;!a&&null!=u&&(c=u[r])?(ux(n,e,c,r,s),eg(t)&&ak(e,t.index)):3&t.type&&(r=function M8(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=i?i(s,t.value||"",r):s,o.setProperty(l,r,s))}(jt(),function Bn(){const n=pt.lFrame;return Mv(n.tView,n.selectedIndex)}(),r,n,t,r[11],e,!1),Tr}function fx(n,t,e,r,s){const i=s?"class":"style";ux(n,e,t.inputs[i],i,r)}function pn(n,t,e,r){const s=de(),o=jt(),i=22+n,a=s[11],l=s[i]=mw(a,t,function vU(){return pt.lFrame.currentNamespace}()),u=o.firstCreatePass?function vH(n,t,e,r,s,o,i){const a=t.consts,u=Dc(t,n,2,s,Ba(a,o));return sx(t,e,u,Ba(a,i)),null!==u.attrs&&$g(u,u.attrs,!1),null!==u.mergedAttrs&&$g(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(i,o,s,0,t,e,r):o.data[i];Ti(u,!0);const c=u.mergedAttrs;null!==c&&ag(a,l,c);const d=u.classes;null!==d&&Cw(a,l,d);const h=u.styles;return null!==h&&QE(a,l,h),64!=(64&u.flags)&&xg(o,s,l,u),0===function rU(){return pt.lFrame.elementDepthCount}()&&ts(l,s),function sU(){pt.lFrame.elementDepthCount++}(),tg(u)&&(tx(o,s,u),nk(o,u,s)),null!==r&&nx(s,u),pn}function Zt(){let n=Sr();Lv()?$v():(n=n.parent,Ti(n,!1));const t=n;!function oU(){pt.lFrame.elementDepthCount--}();const e=jt();return e.firstCreatePass&&(sg(e,n),kv(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function NU(n){return 0!=(16&n.flags)}(t)&&fx(e,t,de(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function TU(n){return 0!=(32&n.flags)}(t)&&fx(e,t,de(),t.stylesWithoutHost,!1),Zt}function ua(n,t,e,r){return pn(n,t,e,r),Zt(),ua}function ou(n,t,e){const r=de(),s=jt(),o=n+22,i=s.firstCreatePass?function wH(n,t,e,r,s){const o=t.consts,i=Ba(o,r),a=Dc(t,n,8,"ng-container",i);return null!==i&&$g(a,i,!0),sx(t,e,a,Ba(o,s)),null!==t.queries&&t.queries.elementStart(t,a),a}(o,s,r,t,e):s.data[o];Ti(i,!0);const a=r[o]=r[11].createComment("");return xg(s,r,a,i),ts(a,r),tg(i)&&(tx(s,r,i),nk(s,i,r)),null!=e&&nx(r,i),ou}function iu(){let n=Sr();const t=jt();return Lv()?$v():(n=n.parent,Ti(n,!1)),t.firstCreatePass&&(sg(t,n),kv(n)&&t.queries.elementEnd(n)),iu}function Ug(n){return!!n&&"function"==typeof n.then}const Ok=function Rk(n){return!!n&&"function"==typeof n.subscribe};function zn(n,t,e,r){const s=de(),o=jt(),i=Sr();return function Mk(n,t,e,r,s,o,i,a){const l=tg(r),c=n.firstCreatePass&&mk(n),d=t[8],h=pk(t);let f=!0;if(3&r.type||a){const m=to(r,t),y=a?a(m):m,v=h.length,w=a?N=>a(lr(N[r.index])):r.index;let x=null;if(!a&&l&&(x=function xH(n,t,e,r){const s=n.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=t[7],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(n,t,s,r.index)),null!==x)(x.__ngLastListenerFn__||x).__ngNextListenerFn__=o,x.__ngLastListenerFn__=o,f=!1;else{o=Lk(r,t,d,o,!1);const N=e.listen(y,s,o);h.push(o,N),c&&c.push(s,w,v,v+1)}}else o=Lk(r,t,d,o,!1);const p=r.outputs;let g;if(f&&null!==p&&(g=p[s])){const m=g.length;if(m)for(let y=0;y<m;y+=2){const I=t[g[y]][g[y+1]].subscribe(o),k=h.length;h.push(o,I),c&&c.push(s,r.index,k,-(k+1))}}}(o,s,s[11],i,n,t,0,r),zn}function Pk(n,t,e,r){try{return!1!==e(r)}catch(s){return yk(n,s),!1}}function Lk(n,t,e,r,s){return function o(i){if(i===Function)return r;ax(2&n.flags?no(n.index,t):t);let l=Pk(t,0,r,i),u=o.__ngNextListenerFn__;for(;u;)l=Pk(t,0,u,i)&&l,u=u.__ngNextListenerFn__;return s&&!1===l&&(i.preventDefault(),i.returnValue=!1),l}}function ni(n=1){return function fU(n){return(pt.lFrame.contextLView=function pU(n,t){for(;n>0;)t=t[15],n--;return t}(n,pt.lFrame.contextLView))[8]}(n)}function qk(n,t,e,r,s){const o=n[e+1],i=null===t;let a=r?ei(o):ia(o),l=!1;for(;0!==a&&(!1===l||i);){const c=n[a+1];_H(n[a],t)&&(l=!0,n[a+1]=r?jw(c):Ww(c)),a=r?ei(c):ia(c)}l&&(n[e+1]=r?Ww(o):jw(o))}function _H(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&vc(n,t)>=0}function mx(n,t,e){return ri(n,t,e,!1),mx}function Wg(n,t){return ri(n,t,null,!0),Wg}function ri(n,t,e,r){const s=de(),o=jt(),i=function ta(n){const t=pt.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}(2);o.firstUpdatePass&&function tA(n,t,e,r){const s=n.data;if(null===s[e+1]){const o=s[vs()],i=function eA(n,t){return t>=n.expandoStartIndex}(n,e);(function oA(n,t){return 0!=(n.flags&(t?16:32))})(o,r)&&null===t&&!i&&(t=!1),t=function PH(n,t,e,r){const s=function Bv(n){const t=pt.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let o=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=jh(e=gx(null,n,t,e,r),t.attrs,r),o=null);else{const i=t.directiveStylingLast;if(-1===i||n[i]!==s)if(e=gx(s,n,t,e,r),null===o){let l=function LH(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==ia(r))return n[ei(r)]}(n,t,r);void 0!==l&&Array.isArray(l)&&(l=gx(null,n,t,l[1],r),l=jh(l,t.attrs,r),function $H(n,t,e,r){n[ei(e?t.classBindings:t.styleBindings)]=r}(n,t,r,l))}else o=function VH(n,t,e){let r;const s=t.directiveEnd;for(let o=1+t.directiveStylingLast;o<s;o++)r=jh(r,n[o].hostAttrs,e);return jh(r,t.attrs,e)}(n,t,r)}return void 0!==o&&(r?t.residualClasses=o:t.residualStyles=o),e}(s,o,t,r),function TH(n,t,e,r,s,o){let i=o?t.classBindings:t.styleBindings,a=ei(i),l=ia(i);n[r]=e;let c,u=!1;if(Array.isArray(e)){const d=e;c=d[1],(null===c||vc(d,c)>0)&&(u=!0)}else c=e;if(s)if(0!==l){const h=ei(n[a+1]);n[r+1]=Ag(h,a),0!==h&&(n[h+1]=Hw(n[h+1],r)),n[a+1]=function v8(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=Ag(a,0),0!==a&&(n[a+1]=Hw(n[a+1],r)),a=r;else n[r+1]=Ag(l,0),0===a?a=r:n[l+1]=Hw(n[l+1],r),l=r;u&&(n[r+1]=Ww(n[r+1])),qk(n,c,r,!0),qk(n,c,r,!1),function IH(n,t,e,r,s){const o=s?n.residualClasses:n.residualStyles;null!=o&&"string"==typeof t&&vc(o,t)>=0&&(e[r+1]=jw(e[r+1]))}(t,c,n,r,o),i=Ag(a,l),o?t.classBindings=i:t.styleBindings=i}(s,o,t,e,i,r)}}(o,n,i,r),t!==bt&&ns(s,i,t)&&function rA(n,t,e,r,s,o,i,a){if(!(3&t.type))return;const l=n.data,u=l[a+1];Hg(function GD(n){return 1==(1&n)}(u)?sA(l,t,e,s,ia(u),i):void 0)||(Hg(o)||function jD(n){return 2==(2&n)}(u)&&(o=sA(l,null,e,s,a,i)),function z5(n,t,e,r,s){if(t)s?n.addClass(e,r):n.removeClass(e,r);else{let o=-1===r.indexOf("-")?void 0:Ls.DashCase;null==s?n.removeStyle(e,r,o):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),o|=Ls.Important),n.setStyle(e,r,s,o))}}(r,i,ng(vs(),e),s,o))}(o,o.data[vs()],s,s[11],n,s[i+1]=function UH(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=nn(function ja(n){return n instanceof class sD{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}?n.changingThisBreaksApplicationSecurity:n}(n)))),n}(t,e),r,i)}function gx(n,t,e,r,s){let o=null;const i=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<i&&(o=t[a],r=jh(r,o.hostAttrs,s),o!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function jh(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let o=0;o<t.length;o++){const i=t[o];"number"==typeof i?s=i:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),so(n,i,!!e||t[++o]))}return void 0===n?null:n}function sA(n,t,e,r,s,o){const i=null===t;let a;for(;s>0;){const l=n[s],u=Array.isArray(l),c=u?l[1]:l,d=null===c;let h=e[s+1];h===bt&&(h=d?Xt:void 0);let f=d?Qv(h,r):c===r?h:void 0;if(u&&!Hg(f)&&(f=Qv(l,r)),Hg(f)&&(a=f,i))return a;const p=n[s+1];s=i?ei(p):ia(p)}if(null!==t){let l=o?t.residualClasses:t.residualStyles;null!=l&&(a=Qv(l,r))}return a}function Hg(n){return void 0!==n}function _r(n,t=""){const e=de(),r=jt(),s=n+22,o=r.firstCreatePass?Dc(r,s,1,t,null):r.data[s],i=e[s]=function pw(n,t){return n.createText(t)}(e[11],t);xg(r,e,i,o),Ti(o,!1)}function yx(n){return Gh("",n,""),yx}function Gh(n,t,e){const r=de(),s=function Rc(n,t,e,r){return ns(n,dc(),e)?t+it(e)+r:bt}(r,n,t,e);return s!==bt&&function aa(n,t,e){const r=ng(t,n);!function BE(n,t,e){n.setValue(t,e)}(n[11],r,e)}(r,vs(),s),Gh}const Uc="en-US";let _A=Uc;function wx(n,t,e,r,s){if(n=nt(n),Array.isArray(n))for(let o=0;o<n.length;o++)wx(n[o],t,e,r,s);else{const o=jt(),i=de();let a=tu(n)?n:nt(n.provide),l=CD(n);const u=Sr(),c=1048575&u.providerIndexes,d=u.directiveStart,h=u.providerIndexes>>20;if(tu(n)||!n.multi){const f=new Sh(l,s,be),p=Cx(a,t,s?c:c+h,d);-1===p?(dg(Th(u,i),o,a),xx(o,n,t.length),t.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),e.push(f),i.push(f)):(e[p]=f,i[p]=f)}else{const f=Cx(a,t,c+h,d),p=Cx(a,t,c,c+h),g=f>=0&&e[f],m=p>=0&&e[p];if(s&&!m||!s&&!g){dg(Th(u,i),o,a);const y=function iG(n,t,e,r,s){const o=new Sh(n,e,be);return o.multi=[],o.index=t,o.componentProviders=0,YA(o,s,r&&!e),o}(s?oG:sG,e.length,s,r,l);!s&&m&&(e[p].providerFactory=y),xx(o,n,t.length,0),t.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),e.push(y),i.push(y)}else xx(o,n,f>-1?f:p,YA(e[s?p:f],l,!s&&r));!s&&r&&m&&e[p].componentProviders++}}}function xx(n,t,e,r){const s=tu(t),o=function yW(n){return!!n.useClass}(t);if(s||o){const l=(o?nt(t.useClass):t).prototype.ngOnDestroy;if(l){const u=n.destroyHooks||(n.destroyHooks=[]);if(!s&&t.multi){const c=u.indexOf(e);-1===c?u.push(e,[r,l]):u[c+1].push(r,l)}else u.push(e,l)}}}function YA(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function Cx(n,t,e,r){for(let s=e;s<r;s++)if(t[s]===n)return s;return-1}function sG(n,t,e,r){return Sx(this.multi,[])}function oG(n,t,e,r){const s=this.multi;let o;if(this.providerFactory){const i=this.providerFactory.componentProviders,a=Ih(e,e[1],this.providerFactory.index,r);o=a.slice(0,i),Sx(s,o);for(let l=i;l<a.length;l++)o.push(a[l])}else o=[],Sx(s,o);return o}function Sx(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function Fn(n,t=[]){return e=>{e.providersResolver=(r,s)=>function rG(n,t,e){const r=jt();if(r.firstCreatePass){const s=Zo(n);wx(e,r.data,r.blueprint,s,!0),wx(t,r.data,r.blueprint,s,!1)}}(r,s?s(n):n,t)}}class Wc{}class QA extends Wc{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new cx(this);const r=function Qs(n,t){const e=n[A_]||null;if(!e&&!0===t)throw new Error(`Type ${nn(n)} does not have '\u0275mod' property.`);return e}(t);this._bootstrapComponents=function sa(n){return n instanceof Function?n():n}(r.bootstrap),this._r3Injector=LD(t,e,[{provide:Wc,useValue:this},{provide:Eg,useValue:this.componentFactoryResolver}],nn(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Nx extends class aG{}{constructor(t){super(),this.moduleType=t}create(t){return new QA(this.moduleType,t)}}function Ix(n){return t=>{setTimeout(n,void 0,t)}}const rs=class LG extends Go{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){let s=t,o=e||(()=>null),i=r;if(t&&"object"==typeof t){const l=t;s=l.next?.bind(l),o=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(o=Ix(o),s&&(s=Ix(s)),i&&(i=Ix(i)));const a=super.subscribe({next:s,error:o,complete:i});return t instanceof Kt&&t.add(a),a}};function $G(){return this._results[ru()]()}class _x{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=ru(),r=_x.prototype;r[e]||(r[e]=$G)}get changes(){return this._changes||(this._changes=new rs)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=ro(t);(this._changesDetected=!function MU(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],o=t[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let ca=(()=>{class n{}return n.__NG_ELEMENT_ID__=zG,n})();const VG=ca,BG=class extends VG{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(t,e){const r=this._declarationTContainer.tViews,s=Fg(this._declarationLView,r,t,16,null,r.declTNode,null,null,null,null,e||null);s[17]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[19];return null!==i&&(s[19]=i.createEmbeddedView(r)),ex(r,s,t),new zh(s)}};function zG(){return Xg(Sr(),de())}function Xg(n,t){return 4&n.type?new BG(t,n,Tc(n,t)):null}let Ai=(()=>{class n{}return n.__NG_ELEMENT_ID__=UG,n})();function UG(){return pR(Sr(),de())}const WG=Ai,hR=class extends WG{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return Tc(this._hostTNode,this._hostLView)}get injector(){return new pc(this._hostTNode,this._hostLView)}get parentInjector(){const t=cg(this._hostTNode,this._hostLView);if(rE(t)){const e=fc(t,this._hostLView),r=hc(t);return new pc(e[1].data[r+8],e)}return new pc(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=fR(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const i=t.createEmbeddedView(e||{},o);return this.insert(i,s),i}createComponent(t,e,r,s,o){const i=t&&!function Eh(n){return"function"==typeof n}(t);let a;if(i)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,o=d.environmentInjector||d.ngModuleRef}const l=i?t:new Uh(rn(t)),u=r||this.parentInjector;if(!o&&null==l.ngModule){const h=(i?u:this.parentInjector).get(Sc,null);h&&(o=h)}const c=l.create(u,s,void 0,o);return this.insert(c.hostView,a),c}insert(t,e){const r=t._lView,s=r[1];if(function nU(n){return Jo(n[3])}(r)){const c=this.indexOf(t);if(-1!==c)this.detach(c);else{const d=r[3],h=new hR(d,d[6],d[3]);h.detach(h.indexOf(t))}}const o=this._adjustIndex(e),i=this._lContainer;!function O5(n,t,e,r){const s=10+r,o=e.length;r>0&&(e[s-1][4]=t),r<o-10?(t[4]=e[s],pE(e,10+r,t)):(e.push(t),t[4]=null),t[3]=e;const i=t[17];null!==i&&e!==i&&function F5(n,t){const e=n[9];t[16]!==t[3][3][16]&&(n[2]=!0),null===e?n[9]=[t]:e.push(t)}(i,t);const a=t[19];null!==a&&a.insertView(n),t[2]|=64}(s,r,i,o);const a=vw(o,i),l=r[11],u=wg(l,i[7]);return null!==u&&function k5(n,t,e,r,s,o){r[0]=s,r[6]=t,Lh(n,r,e,1,s,o)}(s,i[6],l,r,u,a),t.attachToViewContainerRef(),pE(Ex(i),o,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=fR(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=gw(this._lContainer,e);r&&(fg(Ex(this._lContainer),e),UE(r[1],r))}detach(t){const e=this._adjustIndex(t,-1),r=gw(this._lContainer,e);return r&&null!=fg(Ex(this._lContainer),e)?new zh(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function fR(n){return n[8]}function Ex(n){return n[8]||(n[8]=[])}function pR(n,t){let e;const r=t[n.index];if(Jo(r))e=r;else{let s;if(8&n.type)s=lr(r);else{const o=t[11];s=o.createComment("");const i=to(n,t);Ql(o,wg(o,i),s,function $5(n,t){return n.nextSibling(t)}(o,i),!1)}t[n.index]=e=fk(r,t,s,n),Pg(t,e)}return new hR(e,n,t)}class Dx{constructor(t){this.queryList=t,this.matches=null}clone(){return new Dx(this.queryList)}setDirty(){this.queryList.setDirty()}}class kx{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new kx(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==vR(t,e).matches&&this.queries[e].setDirty()}}class mR{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class Ax{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(t,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new Ax(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class Rx{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new Rx(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(t,e,GG(e,o)),this.matchTNodeWithReadOption(t,e,hg(e,t,o,!1,!1))}else r===ca?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,hg(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===Yo||s===Ai||s===ca&&4&e.type)this.addMatch(e.index,-2);else{const o=hg(e,t,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function GG(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function KG(n,t,e,r){return-1===e?function qG(n,t){return 11&n.type?Tc(n,t):4&n.type?Xg(n,t):null}(t,n):-2===e?function XG(n,t,e){return e===Yo?Tc(t,n):e===ca?Xg(t,n):e===Ai?pR(t,n):void 0}(n,t,r):Ih(n,n[1],e,t)}function gR(n,t,e,r){const s=t[19].queries[r];if(null===s.matches){const o=n.data,i=e.matches,a=[];for(let l=0;l<i.length;l+=2){const u=i[l];a.push(u<0?null:KG(t,o[u],i[l+1],e.metadata.read))}s.matches=a}return s.matches}function Ox(n,t,e,r){const s=n.queries.getByIndex(e),o=s.matches;if(null!==o){const i=gR(n,t,s,e);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const u=o[a+1],c=t[-l];for(let d=10;d<c.length;d++){const h=c[d];h[17]===h[3]&&Ox(h[1],h,u,r)}if(null!==c[9]){const d=c[9];for(let h=0;h<d.length;h++){const f=d[h];Ox(f[1],f,u,r)}}}}}return r}function Ka(n){const t=de(),e=jt(),r=q_();zv(r+1);const s=vR(e,r);if(n.dirty&&function tU(n){return 4==(4&n[2])}(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const o=s.crossesNgTemplate?Ox(e,t,r,[]):gR(e,t,s,r);n.reset(o,DW),n.notifyOnChanges()}return!0}return!1}function Xa(n,t,e){const r=jt();r.firstCreatePass&&(function bR(n,t,e){null===n.queries&&(n.queries=new Ax),n.queries.track(new Rx(t,e))}(r,new mR(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),function yR(n,t,e){const r=new _x(4==(4&e));sk(n,t,r,r.destroy),null===t[19]&&(t[19]=new kx),t[19].queries.push(new Dx(r))}(r,de(),t)}function Ja(){return function ZG(n,t){return n[19].queries[t].queryList}(de(),q_())}function vR(n,t){return n.queries.getByIndex(t)}function Zg(...n){}const $R=new dt("Application Initializer");let Yg=(()=>{class n{constructor(e){this.appInits=e,this.resolve=Zg,this.reject=Zg,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const o=this.appInits[s]();if(Ug(o))e.push(o);else if(Ok(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});e.push(i)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(Nt($R,8))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const nf=new dt("AppId",{providedIn:"root",factory:function VR(){return`${$x()}${$x()}${$x()}`}});function $x(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const BR=new dt("Platform Initializer"),Vx=new dt("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),v9=new dt("appBootstrapListener"),da=new dt("LocaleId",{providedIn:"root",factory:()=>function KU(n,t=ht.Default){return"number"!=typeof t&&(t=0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)),Nt(n,t)}(da,ht.Optional|ht.SkipSelf)||function w9(){return typeof $localize<"u"&&$localize.locale||Uc}()}),T9=(()=>Promise.resolve(0))();function Bx(n){typeof Zone>"u"?T9.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class ss{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new rs(!1),this.onMicrotaskEmpty=new rs(!1),this.onStable=new rs(!1),this.onError=new rs(!1),typeof Zone>"u")throw new Pe(908,!1);Zone.assertZonePatched();const s=this;if(s._nesting=0,s._outer=s._inner=Zone.current,Zone.AsyncStackTaggingZoneSpec){const o=Zone.AsyncStackTaggingZoneSpec;s._inner=s._inner.fork(new o("Angular"))}Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function I9(){let n=Sn.requestAnimationFrame,t=Sn.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function D9(n){const t=()=>{!function E9(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(Sn,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,Ux(n),n.isCheckStableRunning=!0,zx(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),Ux(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return WR(n),e.invokeTask(s,o,i,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||n.shouldCoalesceRunChangeDetection)&&t(),HR(n)}},onInvoke:(e,r,s,o,i,a,l)=>{try{return WR(n),e.invoke(s,o,i,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),HR(n)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(n._hasPendingMicrotasks=o.microTask,Ux(n),zx(n)):"macroTask"==o.change&&(n.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),n.runOutsideAngular(()=>n.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!ss.isInAngularZone())throw new Pe(909,!1)}static assertNotInAngularZone(){if(ss.isInAngularZone())throw new Pe(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,t,_9,Zg,Zg);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const _9={};function zx(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function Ux(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function WR(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function HR(n){n._nesting--,zx(n)}class k9{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new rs,this.onMicrotaskEmpty=new rs,this.onStable=new rs,this.onError=new rs}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}const jR=new dt(""),Qg=new dt("");let jx,Wx=(()=>{class n{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,jx||(function A9(n){jx=n}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{ss.assertNotInAngularZone(),Bx(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Bx(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(Nt(ss),Nt(Hx),Nt(Qg))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})(),Hx=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return jx?.findTestabilityInTree(this,e,r)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Qe({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),Za=null;const GR=new dt("AllowMultipleToken"),Gx=new dt("PlatformDestroyListeners");function KR(n,t,e=[]){const r=`Platform: ${t}`,s=new dt(r);return(o=[])=>{let i=qx();if(!i||i.injector.get(GR,!1)){const a=[...e,...o,{provide:s,useValue:!0}];n?n(a):function F9(n){if(Za&&!Za.get(GR,!1))throw new Pe(400,!1);Za=n;const t=n.get(JR);(function qR(n){const t=n.get(BR,null);t&&t.forEach(e=>e())})(n)}(function XR(n=[],t){return oa.create({name:t,providers:[{provide:Rw,useValue:"platform"},{provide:Gx,useValue:new Set([()=>Za=null])},...n]})}(a,r))}return function P9(n){const t=qx();if(!t)throw new Pe(401,!1);return t}()}}function qx(){return Za?.get(JR)??null}let JR=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function YR(n,t){let e;return e="noop"===n?new k9:("zone.js"===n?void 0:n)||new ss(t),e}(r?.ngZone,function ZR(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!n||!n.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!n||!n.ngZoneRunCoalescing)||!1}}(r)),o=[{provide:ss,useValue:s}];return s.run(()=>{const i=oa.create({providers:o,parent:this.injector,name:e.moduleType.name}),a=e.create(i),l=a.injector.get(Ic,null);if(!l)throw new Pe(402,!1);return s.runOutsideAngular(()=>{const u=s.onError.subscribe({next:c=>{l.handleError(c)}});a.onDestroy(()=>{ey(this._modules,a),u.unsubscribe()})}),function QR(n,t,e){try{const r=e();return Ug(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(l,s,()=>{const u=a.injector.get(Yg);return u.runInitializers(),u.donePromise.then(()=>(function EA(n){Je(n,"Expected localeId to be defined"),"string"==typeof n&&(_A=n.toLowerCase().replace(/_/g,"-"))}(a.injector.get(da,Uc)||Uc),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=e3({},r);return function R9(n,t,e){const r=new Nx(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(Kx);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new Pe(403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Pe(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(Gx,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Nt(oa))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function e3(n,t){return Array.isArray(t)?t.reduce(e3,n):{...n,...t}}let Kx=(()=>{class n{constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new Gn(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),i=new Gn(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{ss.assertNotInAngularZone(),Bx(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const u=this._zone.onUnstable.subscribe(()=>{ss.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),u.unsubscribe()}});this.isStable=function Cv(...n){const t=ah(n),e=function lh(n,t){return"number"==typeof rc(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?Zs(r[0]):function oh(n=1/0){return jl(bo,n)}(e)(Gl(r,t)):ih}(o,i.pipe(function hh(n={}){const{connector:t=(()=>new Go),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return o=>{let i,a,l,u=0,c=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},f=()=>{h(),i=l=void 0,c=d=!1},p=()=>{const g=i;f(),g?.unsubscribe()};return Os((g,m)=>{u++,!d&&!c&&h();const y=l=l??t();m.add(()=>{u--,0===u&&!d&&!c&&(a=sc(p,s))}),y.subscribe(m),!i&&u>0&&(i=new Ma({next:v=>y.next(v),error:v=>{d=!0,h(),a=sc(f,e,v),y.error(v)},complete:()=>{c=!0,h(),a=sc(f,r),y.complete()}}),Zs(g).subscribe(i))})(o)}}()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof SD;if(!this._injector.get(Yg).done)throw!s&&function yh(n){const t=rn(n)||gs(n)||ys(n);return null!==t&&t.standalone}(e),new Pe(405,false);let i;i=s?e:this._injector.get(Eg).resolveComponentFactory(e),this.componentTypes.push(i.componentType);const a=function O9(n){return n.isBoundToModule}(i)?void 0:this._injector.get(Wc),u=i.create(oa.NULL,[],r||i.selector,a),c=u.location.nativeElement,d=u.injector.get(jR,null);return d?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),ey(this.components,u),d?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){if(this._runningTick)throw new Pe(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;ey(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(v9,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>ey(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new Pe(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)(Nt(ss),Nt(Sc),Nt(Ic))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function ey(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}let n3=!0,o3=(()=>{class n{}return n.__NG_ELEMENT_ID__=V9,n})();function V9(n){return function B9(n,t,e){if(eg(n)&&!e){const r=no(n.index,t);return new zh(r,r)}return 47&n.type?new zh(t[16],t):null}(Sr(),de(),16==(16&n))}class l3{constructor(){}supports(t){return Wh(t)}create(t){return new G9(t)}}const j9=(n,t)=>t;class G9{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||j9}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,o=null;for(;e||r;){const i=!r||e&&e.currentIndex<c3(r,s,o)?e:r,a=c3(i,s,o),l=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{o||(o=[]);const u=a-s,c=l-s;if(u!=c){for(let h=0;h<u;h++){const f=h<o.length?o[h]:o[h]=0,p=f+h;c<=p&&p<u&&(o[h]=f+1)}o[i.previousIndex]=c-u}}a!==l&&t(i,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Wh(t))throw new Pe(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,o,i,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)o=t[a],i=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,o,i,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,i,a),r=!0),e=e._next}else s=0,function pH(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[ru()]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{i=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,a,i,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,i,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let o;return null===t?o=this._itTail:(o=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,o,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,o,s)):t=this._addAfter(new q9(e,r),o,s),t}_verifyReinsertion(t,e,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?t=this._reinsertAfter(o,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,o=t._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new u3),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new u3),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class q9{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class K9{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class u3{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new K9,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function c3(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}function h3(){return new ry([new l3])}let ry=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||h3()),deps:[[n,new yg,new gg]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new Pe(901,!1)}}return n.\u0275prov=Qe({token:n,providedIn:"root",factory:h3}),n})();const Q9=KR(null,"core",[]);let e7=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Nt(Kx))},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({}),n})();let sy=null;function uu(){return sy}const To=new dt("DocumentToken");function S3(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(o)}return null}class H7{constructor(t,e,r,s){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let I3=(()=>{class n{constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,o,i)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new H7(s.item,this._ngForOf,-1,-1),null===i?void 0:i);else if(null==i)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,i),_3(a,s)}});for(let s=0,o=r.length;s<o;s++){const a=r.get(s).context;a.index=s,a.count=o,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{_3(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(be(Ai),be(ca),be(ry))},n.\u0275dir=yt({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),n})();function _3(n,t){n.context.$implicit=t.item}let uC=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new G7,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){E3("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){E3("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(be(Ai),be(ca))},n.\u0275dir=yt({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class G7{constructor(){this.$implicit=null,this.ngIf=null}}function E3(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${nn(t)}'.`)}class cC{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let py=(()=>{class n{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(e){this._ngSwitch=e,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(e){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(e)}_matchCase(e){const r=e==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||r,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),r}_updateDefaultCases(e){if(this._defaultViews&&e!==this._defaultUsed){this._defaultUsed=e;for(let r=0;r<this._defaultViews.length;r++)this._defaultViews[r].enforceState(e)}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=yt({type:n,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"},standalone:!0}),n})(),D3=(()=>{class n{constructor(e,r,s){this.ngSwitch=s,s._addCase(),this._view=new cC(e,r)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return n.\u0275fac=function(e){return new(e||n)(be(Ai),be(ca),be(py,9))},n.\u0275dir=yt({type:n,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"},standalone:!0}),n})(),R3=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({}),n})();class M3{}class mC extends class Kq extends class r7{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){!function n7(n){sy||(sy=n)}(new mC)}onAndCancel(t,e,r){return t.addEventListener(e,r,!1),()=>{t.removeEventListener(e,r,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function Xq(){return lf=lf||document.querySelector("base"),lf?lf.getAttribute("href"):null}();return null==e?null:function Jq(n){yy=yy||document.createElement("a"),yy.setAttribute("href",n);const t=yy.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){lf=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return S3(document.cookie,t)}}let yy,lf=null;const B3=new dt("TRANSITION_ID"),Yq=[{provide:$R,useFactory:function Zq(n,t,e){return()=>{e.get(Yg).donePromise.then(()=>{const r=uu(),s=t.querySelectorAll(`style[ng-transition="${n}"]`);for(let o=0;o<s.length;o++)r.remove(s[o])})}},deps:[B3,To,oa],multi:!0}];let eK=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();const by=new dt("EventManagerPlugins");let vy=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let o=0;o<s.length;o++){const i=s[o];if(i.supports(e))return this._eventNameToPlugin.set(e,i),i}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Nt(by),Nt(ss))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();class z3{constructor(t){this._doc=t}addGlobalEventListener(t,e,r){const s=uu().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let U3=(()=>{class n{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})(),uf=(()=>{class n extends U3{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(o=>{const i=this._doc.createElement("style");i.textContent=o,s.push(r.appendChild(i))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach(W3),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(W3))}}return n.\u0275fac=function(e){return new(e||n)(Nt(To))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();function W3(n){uu().remove(n)}const gC={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},yC=/%COMP%/g;function wy(n,t,e){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?wy(n,s,e):(s=s.replace(yC,n),e.push(s))}return e}function G3(n){return t=>{if("__ngUnwrap__"===t)return n;!1===n(t)&&(t.preventDefault(),t.returnValue=!1)}}let bC=(()=>{class n{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new vC(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case Ni.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new iK(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case Ni.ShadowDom:return new aK(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=wy(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(Nt(vy),Nt(uf),Nt(nf))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();class vC{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?document.createElementNS(gC[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){(K3(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(K3(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?document.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const o=gC[s];o?t.setAttributeNS(o,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=gC[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&(Ls.DashCase|Ls.Important)?t.style.setProperty(e,r,s&Ls.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&Ls.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,G3(r)):this.eventManager.addEventListener(t,e,G3(r))}}function K3(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class iK extends vC{constructor(t,e,r,s){super(t),this.component=r;const o=wy(s+"-"+r.id,r.styles,[]);e.addStyles(o),this.contentAttr=function rK(n){return"_ngcontent-%COMP%".replace(yC,n)}(s+"-"+r.id),this.hostAttr=function sK(n){return"_nghost-%COMP%".replace(yC,n)}(s+"-"+r.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}class aK extends vC{constructor(t,e,r,s){super(t),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=wy(s.id,s.styles,[]);for(let i=0;i<o.length;i++){const a=document.createElement("style");a.textContent=o[i],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let lK=(()=>{class n extends z3{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(Nt(To))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();const X3=["alt","control","meta","shift"],uK={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},cK={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let dK=(()=>{class n extends z3{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const o=n.parseEventName(r),i=n.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>uu().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=n._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),X3.forEach(u=>{const c=r.indexOf(u);c>-1&&(r.splice(c,1),i+=u+".")}),i+=o,0!=r.length||0===o.length)return null;const l={};return l.domEventName=s,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let s=uK[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(s=e.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),X3.forEach(i=>{i!==s&&(0,cK[i])(e)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(e,r,s){return o=>{n.matchEventFullKeyCode(o,e)&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Nt(To))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();const mK=KR(Q9,"browser",[{provide:Vx,useValue:"browser"},{provide:BR,useValue:function hK(){mC.makeCurrent()},multi:!0},{provide:To,useFactory:function pK(){return function j5(n){Nw=n}(document),document},deps:[]}]),Y3=new dt(""),Q3=[{provide:Qg,useClass:class Qq{addToWindow(t){Sn.getAngularTestability=(r,s=!0)=>{const o=t.findTestabilityInTree(r,s);if(null==o)throw new Error("Could not find testability for element.");return o},Sn.getAllAngularTestabilities=()=>t.getAllTestabilities(),Sn.getAllAngularRootElements=()=>t.getAllRootElements(),Sn.frameworkStabilizers||(Sn.frameworkStabilizers=[]),Sn.frameworkStabilizers.push(r=>{const s=Sn.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(l){i=i||l,o--,0==o&&r(i)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,r){return null==e?null:t.getTestability(e)??(r?uu().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:jR,useClass:Wx,deps:[ss,Hx,Qg]},{provide:Wx,useClass:Wx,deps:[ss,Hx,Qg]}],eO=[{provide:Rw,useValue:"root"},{provide:Ic,useFactory:function fK(){return new Ic},deps:[]},{provide:by,useClass:lK,multi:!0,deps:[To,ss,Vx]},{provide:by,useClass:dK,multi:!0,deps:[To]},{provide:bC,useClass:bC,deps:[vy,uf,nf]},{provide:TD,useExisting:bC},{provide:U3,useExisting:uf},{provide:uf,useClass:uf,deps:[To]},{provide:vy,useClass:vy,deps:[by,ss]},{provide:M3,useClass:eK,deps:[]},[]];let gK=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:nf,useValue:e.appId},{provide:B3,useExisting:nf},Yq]}}}return n.\u0275fac=function(e){return new(e||n)(Nt(Y3,12))},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({providers:[...eO,...Q3],imports:[R3,e7]}),n})();function rO(n,t,e,r,s,o,i){try{var a=n[o](i),l=a.value}catch(u){return void e(u)}a.done?t(l):Promise.resolve(l).then(r,s)}function J(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var o=n.apply(t,e);function i(l){rO(o,r,s,i,a,"next",l)}function a(l){rO(o,r,s,i,a,"throw",l)}i(void 0)})}}typeof window<"u"&&window;class sO{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class CC{refCount(t){return Vs("refCount")}incRef(t){return Vs("incRef")}timerAvailable(){return!0}time(t){return Vs("time")}read(t){return Vs("read")}readSync(t){return Vs("readSync")}readToGPU(t,e){return Vs("readToGPU")}numDataIds(){return Vs("numDataIds")}disposeData(t,e){return Vs("disposeData")}write(t,e,r){return Vs("write")}move(t,e,r,s,o){return Vs("move")}createTensorFromGPUData(t,e,r){return Vs("createTensorFromGPUData")}memory(){return Vs("memory")}floatPrecision(){return Vs("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Vs("dispose")}}function Vs(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function oO(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Qa(n,t,e)}function cu(n,t,e){return Math.max(n,Math.min(t,e))}function SC(n){return n%2==0?n:n+1}function Qa(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function _(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Bs(n,t,e=""){_(Pt(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Gc(n){_(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function Z(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Pt(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function qc(n){return n%1==0}function NC(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Kc(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function iO(n,t=(s=>0),e,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(n())return void s();i++;const l=t(i);null!=e&&i>=e?o():null!=r?r(a,l):setTimeout(a,l)};a()})}function aO(n,t){let e=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)e*=n[o];else if(-1===n[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function Rt(n,t){const e=t.length;return _((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),_(n.every(r=>qc(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function el(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||s?null:Rt(t,n).sort();let i=0;for(let a=0;a<n.length;++a){if(null!=o){if(o[i]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),o[i]<=a&&i++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function Lr(n,t){return Xn(n,t)}function Xn(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function lO(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function xy(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function cf(n){return"string"==typeof n||n instanceof String}function TC(n){return"number"==typeof n}function Xc(n){return Array.isArray(n)?Xc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":TC(n)?"float32":cf(n)?"string":function FK(n){return"boolean"==typeof n}(n)?"bool":"float32"}function IC(n){return!!(n&&n.constructor&&n.call&&n.apply)}function _C(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Ge(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function uO(n,t,e,r=!1){const s=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=e[n+i]}else{const o=t[0],i=t.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=uO(n+l*a,i,e,r)}return s}function Eo(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,o)=>s*o)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return uO(0,n,t,e)}function EC(n,t){const e=Kr(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Kr(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function cO(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return Eo(n,new Float32Array(e));if("int32"===t)return Eo(n,new Int32Array(e));if("bool"===t)return Eo(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function ao(n){n.forEach(t=>{_(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Ri(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function Jc(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function du(n){return n&&n.then&&"function"==typeof n.then}const dO="tfjsflags";class PK{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=LK,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return J(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(du(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);dO in t&&t[dO].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function VK(n,t){const e=t.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:t}(0,o)})}}function LK(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function $K(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function G(){return hO}let DC,hO=null;function fO(){if(null==DC){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}DC=n}return DC}function kC(n,t){const e=function zK(){const n=fO();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const Cy="Abs",df="Acos",hf="Acosh",Zc="Add",Sy="AddN",Ny="ArgMax",Ty="ArgMin",ff="Asin",pf="Asinh",mf="Atan",gf="Atanh",yf="Atan2",Iy="AvgPool",OC="AvgPoolGrad",_y="AvgPool3D",FC="AvgPool3DGrad",Ey="BatchMatMul",Dy="BatchToSpaceND",MC="Bincount",ky="BitwiseAnd",PC="BroadcastArgs",bf="Cast",vf="Ceil",wf="ClipByValue",LC="Complex",Ay="ComplexAbs",Ry="Concat",Oy="Conv2D",$C="Conv2DBackpropFilter",Fy="Conv2DBackpropInput",My="Conv3D",VC="Conv3DBackpropFilterV2",BC="Conv3DBackpropInputV2",xf="Cos",Cf="Cosh",zC="Cumprod",Py="Cumsum",UC="CropAndResize",WC="DenseBincount",HC="DepthToSpace",Ly="DepthwiseConv2dNative",jC="DepthwiseConv2dNativeBackpropFilter",GC="DepthwiseConv2dNativeBackpropInput",qC="Diag",$y="Dilation2D",KC="Dilation2DBackpropInput",XC="Dilation2DBackpropFilter",JC="Draw",Sf="RealDiv",ZC="Einsum",Nf="Elu",YC="EluGrad",Tf="Erf",Vy="Equal",If="Exp",By="ExpandDims",_f="Expm1",e2="Fill",t2="FlipLeftRight",Ef="Floor",Df="FloorDiv",zy="FusedBatchNorm",Uy="GatherV2",n2="GatherNd",Wy="Greater",kf="GreaterEqual",Af="Identity",r2="IFFT",s2="Imag",Rf="IsFinite",Of="IsInf",Ff="IsNan",Hy="LeakyRelu",jy="Less",Gy="LessEqual",o2="LinSpace",Mf="Log",Pf="Log1p",qy="LogicalAnd",Ky="LogicalNot",Xy="LogicalOr",Jy="LRN",i2="LRNGrad",Zy="Max",Lf="Maximum",Yy="MaxPool",a2="MaxPoolGrad",Qy="MaxPool3D",l2="MaxPool3DGrad",u2="MaxPoolWithArgmax",e0="Mean",t0="Min",$f="Minimum",n0="MirrorPad",Vf="Mod",c2="Multinomial",Bf="Multiply",r0="Neg",s0="NotEqual",d2="NonMaxSuppressionV3",h2="NonMaxSuppressionV4",f2="NonMaxSuppressionV5",o0="OnesLike",a0="OneHot",l0="Pack",u0="PadV2",zf="Pow",c0="Prelu",d0="Prod",p2="RaggedGather",m2="RaggedRange",g2="RaggedTensorToTensor",y2="Range",b2="Real",Uf="Reciprocal",Wf="Relu",h0="Reshape",f0="ResizeNearestNeighbor",v2="ResizeNearestNeighborGrad",p0="ResizeBilinear",w2="ResizeBilinearGrad",Hf="Relu6",m0="Reverse",jf="Round",Gf="Rsqrt",x2="ScatterNd",C2="TensorScatterUpdate",S2="SearchSorted",g0="Select",qf="Selu",y0="Slice",Kf="Sin",Xf="Sinh",Jf="Sign",Zf="Sigmoid",Yf="Softplus",Qf="Sqrt",b0="Sum",v0="SpaceToBatchND",w0="SplitV",x0="Softmax",N2="SparseFillEmptyRows",T2="SparseReshape",I2="SparseSegmentMean",_2="SparseSegmentSum",E2="SparseToDense",ep="SquaredDifference",D2="Square",C0="StaticRegexReplace",k2="StridedSlice",A2="StringNGrams",R2="StringSplit",O2="StringToHashBucketFast",tp="Sub",np="Tan",rp="Tanh",sp="Tile",F2="TopK",M2="Transform",Yc="Transpose",P2="Unique",S0="Unpack",N0="UnsortedSegmentSum",T0="ZerosLike",op="Step",L2="FromPixels",$2="RotateWithOffset",I0="_FusedMatMul",_0="FusedConv2D",E0="FusedDepthwiseConv2D";function lo(...n){G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(...n)}function HK(...n){G().getBool("IS_TEST")||G().getBool("PROD")||console.log(...n)}const Qc=kC("kernelRegistry",()=>new Map),ip=kC("gradRegistry",()=>new Map);function D0(n,t){const e=z2(n,t);return Qc.get(e)}function pO(n){return ip.get(n)}function V2(n){const t=Qc.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===n&&e.push(i)}return e}function B2(n){const{kernelName:t,backendName:e}=n,r=z2(t,e);Qc.has(r)&&lo(`The kernel '${t}' for backend '${e}' is already registered`),Qc.set(r,n)}function jK(n){const{kernelName:t}=n;ip.has(t)&&G().getBool("DEBUG")&&lo(`Overriding the gradient for '${t}'`),ip.set(t,n)}function z2(n,t){return`${t}_${n}`}function mO(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var gO=ee(658);const hu=ee.n(gO)()||gO;function k0(n){return hu.fromString(n,!0,16)}const yO=k0("c3a5c85c97cb3127"),fu=k0("b492b66fbe98f273"),os=k0("9ae16a3b2f90404f");function U2(n){return n.xor(n.shru(47))}function bO(n,t,e){const r=n.slice(t,t+e);return hu.fromBytes(Array.from(r),!0,!0)}function mn(n,t){return bO(n,t,8)}function vO(n,t){return bO(n,t,4)}function Dr(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function tl(n,t,e=k0("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function A0(n,t,e,r){return function qK(n,t,e,r,s,o){s=s.add(n),o=Dr(o.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(e),o=o.add(Dr(s,44)),[s.add(r),o.add(i)]}(mn(n,t),mn(n,t+8),mn(n,t+16),mn(n,t+24),e,r)}function ZK(n,t=n.length){const e=hu.fromNumber(81,!0);if(t<=32)return t<=16?function KK(n,t=n.length){if(t>=8){const e=os.add(2*t),r=mn(n,0).add(os),s=mn(n,t-8);return tl(Dr(s,37).mul(e).add(r),Dr(r,25).add(s).mul(e),e)}if(t>=4){const e=os.add(2*t);return tl(vO(n,0).shl(3).add(t),vO(n,t-4),e)}if(t>0){const i=t+(n[t-1]<<2);return U2(os.mul(n[0]+(n[t>>1]<<8)).xor(yO.mul(i))).mul(os)}return os}(n,t):function XK(n,t=n.length){const e=os.add(2*t),r=mn(n,0).mul(fu),s=mn(n,8),o=mn(n,t-8).mul(e),i=mn(n,t-16).mul(os);return tl(Dr(r.add(s),43).add(Dr(o,30)).add(i),r.add(Dr(s.add(os),18)).add(o),e)}(n,t);if(t<=64)return function JK(n,t=n.length){const e=os.add(2*t),r=mn(n,0).mul(os),s=mn(n,8),o=mn(n,t-8).mul(e),i=mn(n,t-16).mul(os),a=Dr(r.add(s),43).add(Dr(o,30)).add(i),l=tl(a,r.add(Dr(s.add(os),18)).add(o),e),u=mn(n,16).mul(e),c=mn(n,24),d=a.add(mn(n,t-32)).mul(e),h=l.add(mn(n,t-24)).mul(e);return tl(Dr(u.add(c),43).add(Dr(d,30)).add(h),u.add(Dr(c.add(r),18)).add(d),e)}(n,t);let r=e,s=e.mul(fu).add(113),o=U2(s.mul(os).add(113)).mul(os),i=[hu.UZERO,hu.UZERO],a=[hu.UZERO,hu.UZERO];r=r.mul(os).add(mn(n,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Dr(r.add(s).add(i[0]).add(mn(n,l+8)),37).mul(fu),s=Dr(s.add(i[1]).add(mn(n,l+48)),42).mul(fu),r=r.xor(a[1]),s=s.add(i[0]).add(mn(n,l+40)),o=Dr(o.add(a[0]),33).mul(fu),i=A0(n,l,i[1].mul(fu),r.add(a[0])),a=A0(n,l+32,o.add(a[1]),s.add(mn(n,l+16))),[o,r]=[r,o],l+=64}while(l!==u);const d=fu.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Dr(r.add(s).add(i[0]).add(mn(n,l+8)),37).mul(d),s=Dr(s.add(i[1]).add(mn(n,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(mn(n,l+40))),o=Dr(o.add(a[0]),33).mul(d),i=A0(n,l,i[1].mul(d),r.add(a[0])),a=A0(n,l+32,o.add(a[1]),s.add(mn(n,l+16))),[o,r]=[r,o],tl(tl(i[0],a[0],d).add(U2(s).mul(yO)).add(o),tl(i[1],a[1],d).add(r),d)}function nl(n,t){return"string"===t?rl(n):pu([n],t)}function pu(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=mu(n)),G().getBool("DEBUG")&&function AK(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function YK(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function Ss(){return G().platform.now()}function rl(n,t="utf-8"){return t=t||"utf-8",G().platform.encode(n,t)}function sl(n,t="utf-8"){return t=t||"utf-8",G().platform.decode(n,t)}function Do(n){return null!=G().platform.isTypedArray?G().platform.isTypedArray(n):mO(n)}function mu(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||du(n)||null==n||Do(n)&&e)t.push(n);else if(Array.isArray(n)||Do(n))for(let r=0;r<n.length;++r)mu(n[r],t,e);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)mu(n[s],t,e)}return t}class QK{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new tX)}profileKernel(t,e,r){let s;const o=()=>{s=r()};let i;const a=Ss();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Ss()-a})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{eX(d,c.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:i}=t;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],o,l[2])})})}}function eX(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class tX{logKernelProfile(t,e,r,s,o,i){const a="number"==typeof s?Kc(`${s}ms`,9):s.error,l=Kc(t,25),u=e.rank,c=e.size,d=Kc(e.shape.toString(),14);let h="";for(const f in o){const p=o[f];if(null!=p){const g=p.shape||e.shape,m=g.length;h+=`${f}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function sX(n,t,e,r){const s=Ge(t),o=function oX(n,t,e,r){const s=Z(t),o=r[r.length-1],i=new Array(o).fill(0),a=t.length,l="complex64"===e?up(n):n;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],lp(l[c+d],0,e).length)}return i}(n,t,e,s),i=t.length,a=R0(n,t,e,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function lp(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:cf(n)?`'${n}'`:"bool"===e?xO(n):parseFloat(n.toFixed(7)).toString(),Kc(r,t)}function xO(n){return 0===n?"false":"true"}function R0(n,t,e,r,s,o=!0){const i="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[lp(up(n)[0],0,e)]:"bool"===e?[xO(n[0])]:[n[0].toString()];if(1===l){if(a>20){let y=Array.from(n.slice(0,3*i)),v=Array.from(n.slice((a-3)*i,a*i));return"complex64"===e&&(y=up(y),v=up(v)),["["+y.map((w,x)=>lp(w,s[x],e)).join(", ")+", ..., "+v.map((w,x)=>lp(w,s[a-3+x],e)).join(", ")+"]"]}return["["+("complex64"===e?up(n):Array.from(n)).map((m,y)=>lp(m,s[y],e)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>20){for(let g=0;g<3;g++){const m=g*d;h.push(...R0(n.slice(m,m+d),u,e,c,s,!1))}h.push("...");for(let g=a-3;g<a;g++){const m=g*d;h.push(...R0(n.slice(m,m+d),u,e,c,s,g===a-1))}}else for(let g=0;g<a;g++){const m=g*d;h.push(...R0(n.slice(m,m+d),u,e,c,s,g===a-1))}const f=2===l?",":"";h[0]="["+(a>0?h[0]+f:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+f;let p=",\n";for(let g=2;g<l;g++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":p),h}function up(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class hr{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=Z(t),null!=r){const s=r.length;_(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Xn(e,this.size),this.strides=Ge(t)}set(t,...e){0===e.length&&(e=[0]),_(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return li().makeTensor(this.values,this.shape,this.dtype)}}let li=null,ed=null,CO=null;class on{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Z(t),this.strides=Ge(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return J(function*(){const e=yield t.data();return ed.buffer(t.shape,t.dtype,e)})()}bufferSync(){return ed.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return J(function*(){const e=yield t.data();return Eo(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return Eo(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return J(function*(){t.throwIfDisposed();const e=li().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>sl(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),li().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=li().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>sl(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return J(function*(){t.throwIfDisposed();const e=yield li().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),li().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return ed.print(this,t)}clone(){return this.throwIfDisposed(),ed.clone(this)}toString(t=!1){return sX(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),ed.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),li().makeVariable(this,t,e,r)}}function ne(){return kC("Tensor",()=>on)}Object.defineProperty(on,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),ne();class O0 extends on{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Pt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);li().disposeTensor(this),this.dataId=t.dataId,li().incRef(this,null)}dispose(){li().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(O0,Symbol.hasInstance,{value:n=>n instanceof on&&null!=n.assign&&n.assign instanceof Function});var F0=(()=>{return(n=F0||(F0={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",F0;var n})(),M0=(()=>{return(n=M0||(M0={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",M0;var n})(),P0=(()=>{return(n=P0||(P0={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",P0;var n})(),L0=(()=>{return(n=L0||(L0={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",L0;var n})();const uX={float32:P0,int32:F0,bool:M0,complex64:L0};function zs(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return uX[n][t]}function H2(n){return zs(n,"int32")}function SO(n){return null!=n&&"object"==typeof n&&"texture"in n&&n.texture instanceof WebGLTexture}function NO(n){return typeof GPUBuffer<"u"&&null!=n&&"object"==typeof n&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Wn(n,t){if(n.dtype===t.dtype)return[n,t];const e=zs(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function TO(n){const t=[];return IO(n,t,new Set),t}function IO(n,t,e){if(null==n)return;if(n instanceof on)return void t.push(n);if(!function dX(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const o=r[s];e.has(o)||(e.add(o),IO(o,t,e))}}function j2(n){return null!=n.kernelName}class _O{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let hX=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new _O}ready(){var e=this;return J(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(lo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return J(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new QK(r.backendInstance),!0})()}setupRegisteredKernels(){V2(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){V2(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof CC||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,lo(`Initialization of backend ${e} failed`),lo(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return lo(`Initialization of backend ${e} failed`),lo(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=$.runKernel(Af,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>$.runKernel(bf,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==D0(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=j2(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(j2(e)){const{kernelName:g,inputs:m,attrs:y}=e,v=D0(g,this.backendName);_(null!=v,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{const w=this.backend.numDataIds();u=v.kernelFunc({inputs:m,attrs:y,backend:this.backend});const x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,w,x);const N=x.map(I=>null!=I.rank?I:this.makeTensorFromTensorInfo(I));if(o){const I=this.getTensorsForGradient(g,m,N);s=this.saveTensorsForBackwardMode(I)}return N}}else{const{forwardFunc:g}=e,m=y=>{!o||(s=y.map(v=>this.keep(this.clone(v))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,m));const v=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,v),v}}const{inputs:d,attrs:h}=e,f=j2(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),o&&this.addTapeNode(c,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(g=>null!=d[g]?d[g].shape:null),outputShapes:r.map(g=>g.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=pO(e);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(_(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=e;"string"===(s=s||"float32")&&cf(e[0])&&(i=e.map(u=>rl(u)));const a=o.write(i,r,s),l=new on(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=function OK(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,s,o){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},o)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:o,dtype:i}=e,a=new on(o,i,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const i=new O0(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*xy(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof O0||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*xy(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return J(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:i},u=pO(e);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const f=s[h],p=Kr(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=TO(e),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,r,s,o=!1){if(_(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));_(i instanceof on,()=>"The result y returned by f() must be a tensor.");const a=function nX(n,t,e){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const d in c){const h=c[d];let f=!1;for(let p=0;p<t.length;p++)if(r[h.id]){u.outputs.forEach(g=>r[g.id]=!0),f=!0,s[u.id]=!0;break}if(f)break}}const o={};o[e.id]=!0;const i={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const f=u.inputs[h];r[f.id]&&(c[h]=f)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??function fX(n){const t=EC(Z(n),"float32");return $.makeTensor(t,n,"float32")}(i.shape),function rX(n,t,e,r){for(let s=t.length-1;s>=0;s--){const o=t[s],i=[];if(o.outputs.forEach(l=>{const u=n[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!Pt(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==n[c.id])n[c.id]=u;else{const d=n[c.id];n[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),pX);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return _(IC(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;_(r.every(l=>l instanceof on),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=e(...r,u),_(s.value instanceof on,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),_(IC(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];_(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),_(d.every(f=>f instanceof on),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return J(function*(){const s=Ss(),o=yield r.backend.time(e);return o.wallMs=Ss()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new _O;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function EO(){const n=fO();if(null==n._tfengine){const t=new PK(n);n._tfengine=new hX(t)}return function BK(n){hO=n}(n._tfengine.ENV),function iX(n){li=n}(()=>n._tfengine),n._tfengine}const $=EO();function pX(n,t){return $.runKernel(Zc,{a:n,b:t})}function DO(n){if(n||function mX(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function kO(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const Ns=G();function ol(n,t){let e=n;if(Do(n))return"string"===t?[]:[n.length];if(SO(n))return[n.height,n.width*(n.channels||"RGBA").length];if(NO(n))return[n.buffer.size/(null==t?4:xy(t))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||Do(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&AO(n,r,[]),r}function AO(n,t,e){if(e=e||[],!Array.isArray(n)&&!Do(n))return void _(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);_(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),_(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)AO(n[s],r,e.concat(s))}function RO(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function E(n,t,e,r="numeric"){if(n instanceof ne())return RO(r,n.dtype,t,e),n;let s=Xc(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),RO(r,s,t,e),null==n||!Do(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const o=ol(n,s);!Do(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?pu(n,s):mu(n,[],!0);return $.makeTensor(a,o,s)}function $0(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>E(o,`${t}[${i}]`,e,r))}Ns.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ns.registerFlag("IS_BROWSER",()=>kO()),Ns.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Ns.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ns.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Ns.registerFlag("PROD",()=>!1),Ns.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ns.getBool("DEBUG")),Ns.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ns.registerFlag("IS_TEST",()=>!1),Ns.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ns.getBool("DEBUG")),Ns.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Ns.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Ns.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const OO="__op";function M(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=OO;const s=(...o)=>{$.startScope(e);try{const i=r(...o);return du(i)&&console.error("Cannot return a Promise inside of tidy."),$.endScope(i),i}catch(i){throw $.endScope(null),i}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const il=M({complex_:function gX(n,t){const e=E(n,"real","complex"),r=E(t,"imag","complex");return Bs(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),$.runKernel(LC,{real:e,imag:r})}});function al(n,t,e,r){if(null==r)r=Xc(n);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(NO(n)||SO(n)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return $.backend.createTensorFromGPUData(n,t||e,r)}if(!Do(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ao(t);const s=Z(t),o=Z(e);_(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<e.length;++i){const a=e[i],l=i!==e.length-1||a!==Z(t.slice(i));_(e[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Do(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?pu(n,r):mu(n,[],!0),$.makeTensor(n,t,r)}function ko(n,t,e){return al(n,t,ol(n,e),e)}const gu={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ui{static join(t){return new ui(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t||(t instanceof Array||(t=[t]),0===(t=t.map(r=>Do(r)?r.buffer:r)).length))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let r=0;r<t.length;r++){const s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=e+s.byteLength;this.shards.push({buffer:s,start:e,end:o}),e=o}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(-1===r)throw new Error(`Could not find start shard for byte ${t}`);const o=new ArrayBuffer(e-t),i=new Uint8Array(o);let a=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],d=t+a-u.start,h=a,p=Math.min(e,u.end)-u.start,g=new Uint8Array(u.buffer,d,p-d);if(i.set(g,h),a+=g.length,e<u.end)break}return o}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(s){return t<s.start?-1:t>=s.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const r=function yX(n,t){let e=0,r=n.length;for(;e<=r;){const s=Math.floor((r-e)/2)+e,o=t(n[s]);if(0===o)return s;o<0?r=s:e=s+1}return-1}(this.shards,e);return-1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Us(){return $}function q2(){return $.memory()}function H(n,t){return $.tidy(n,t)}function ut(n){TO(n).forEach(e=>e.dispose())}function kr(n){return $.keep(n)}function wX(){return $.backendName}function FO(n,t,e=1){return $.registerBackend(n,t,e)}function MO(){return $.backend}function K2(n,t){return X2.apply(this,arguments)}function X2(){return X2=J(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(n)?n[i].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=J(function*(h){const f=yield l.bytes(),p=f.reduce((y,v)=>y+v.length,0)+4*f.length,g=new Uint8Array(p);let m=0;for(let y=0;y<f.length;y++){const v=f[y],w=new Uint8Array(new Uint32Array([v.length]).buffer);g.set(w,m),m+=4,g.set(v,m),m+=v.length}h(g)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=t&&(u.group=t),e.push(u)}return{data:SX(yield Promise.all(r)),specs:e}}),X2.apply(this,arguments)}function PO(n,t){const e=new ui(n),r={};let s=0;for(const o of t){const i=xX(o,(a,l)=>e.slice(s+a,s+l));r[o.name]=LO(o,e.slice(s,s+i)),s+=i}return r}function xX(n,t){const e=Z(n.shape);let r;if("quantization"in n)r=gu[n.quantization.dtype];else{if("string"===n.dtype){let s=0;for(let o=0;o<e;o++)s+=4+new Uint32Array(t(s,s+4))[0];return s}r=gu[n.dtype]}return e*r}function CX(n,t){return J2.apply(this,arguments)}function J2(){return(J2=J(function*(n,t){const e=Z(n.shape);let r;if("quantization"in n)r=gu[n.quantization.dtype];else{if("string"===n.dtype){let s=0;for(let o=0;o<e;o++)s+=4+new Uint32Array(yield t(s,s+4))[0];return s}r=gu[n.dtype]}return e*r})).apply(this,arguments)}function LO(n,t){const e=n.name,r=n.dtype,s=n.shape,o=Z(s);let i,a=0;if("quantization"in n){const l=n.quantization;if("uint8"===l.dtype||"uint16"===l.dtype){if(!("min"in l)||!("scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==l.dtype)throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}const u=gu[l.dtype],c="uint8"===l.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===l.dtype||"uint16"===l.dtype){i=new Float32Array(c.length);for(let d=0;d<c.length;d++)i[d]=c[d]*l.scale+l.min}else{if("float16"!==l.dtype)throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);i=function DX(){const n=function IX(){const n=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function _X(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function EX(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i];o[i]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(s)}}()(c)}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${e}': ${r}`);if("uint8"!==l.dtype&&"uint16"!==l.dtype)throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let d=0;d<c.length;d++)i[d]=Math.round(c[d]*l.scale+l.min)}a+=o*u}else if("string"===r){const l=Z(n.shape);i=[];for(let u=0;u<l;u++){const c=new Uint32Array(t.slice(a,a+4))[0];a+=4;const d=new Uint8Array(t.slice(a,a+c));i.push(d),a+=c}}else{const l=gu[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let p=0;p<u.length;p++)u[p]=i[2*p],c[p]=i[2*p+1];const d=ko(u,s,"float32"),h=ko(c,s,"float32"),f=il(d,h);return d.dispose(),h.dispose(),f}throw new Error(`Unsupported dtype in weight '${e}': ${r}`)}i=new Uint8Array(t)}a+=o*l}return ko(i,s,r)}function $O(n,t,e){return Z2.apply(this,arguments)}function Z2(){return(Z2=J(function*(n,t,e){let r=new Uint8Array(t);for(;r.byteLength<e;){const{done:s,value:o}=yield n.read();if(s&&null==o)throw new Error(`Reader is done but ${e-r.byteLength} bytes are still expected`);const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer})).apply(this,arguments)}function VO(n,t){return Y2.apply(this,arguments)}function Y2(){return Y2=J(function*(n,t){const e={},r=n.getReader();let s=new ArrayBuffer(0);for(const o of t){const i=yield CX(o,function(){var u=J(function*(c,d){return s=yield $O(r,s,d),s.slice(c,d)});return function(c,d){return u.apply(this,arguments)}}());s=yield $O(r,s,i);const a=s.slice(0,i);s=s.slice(i);const l=LO(o,a);if(e[o.name]=l,"webgpu"===wX()){const u=MO();"uploadToGPU"in u&&Z(l.shape)>=G().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return e}),Y2.apply(this,arguments)}function SX(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(o=>{if(t+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}!function lX(n){CO=n}(function bX(n){G().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const Q2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function BO(n){return Q2?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function zO(n){return ui.join(n)}function UO(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function WO(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function HO(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function eS(n,t){return tS.apply(this,arguments)}function tS(){return(tS=J(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),HO(n,e,r)})).apply(this,arguments)}function cp(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:BO(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:BO(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:new ui(n.weightData).byteLength}}function nS(n){const t=[];for(const e of n)t.push(...e.weights);return t}class Mn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Mn.instance&&(Mn.instance=new Mn),Mn.instance}static registerSaveRouter(t){Mn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Mn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Mn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Mn.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?Mn.getInstance().loadRouters:Mn.getInstance().saveRouters).forEach(i=>{const a=i(t,r);null!==a&&s.push(a)}),s}}const kX=n=>Mn.registerSaveRouter(n),AX=n=>Mn.registerLoadRouter(n),jO=n=>Mn.getSaveHandlers(n),RX=(n,t)=>Mn.getLoadHandlers(n,t),V0="tensorflowjs",yu="models_store",ul="model_info_store";function oS(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function iS(n){const t=n.result;t.createObjectStore(yu,{keyPath:"modelPath"}),t.createObjectStore(ul,{keyPath:"modelPath"})}let td=(()=>{class n{constructor(e){if(this.indexedDB=oS(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return J(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const i=this.indexedDB.open(V0,1);i.onupgradeneeded=()=>iS(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(yu,"readonly"),c=l.objectStore(yu).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{r.weightData=ui.join(r.weightData);const l=cp(r),u=a.transaction(ul,"readwrite");let d,h,c=u.objectStore(ul);try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(f){return o(f)}d.onsuccess=()=>{h=a.transaction(yu,"readwrite");const f=h.objectStore(yu);let p;try{p=f.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(g){return o(g)}p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=g=>{c=u.objectStore(ul);const m=c.delete(this.modelPath);m.onsuccess=()=>(a.close(),o(p.error)),m.onerror=y=>(a.close(),o(p.error))}},d.onerror=f=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return n.URL_SCHEME="indexeddb://",n})();const GO=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(td.URL_SCHEME)?function OX(n){return new td(n)}(n.slice(td.URL_SCHEME.length)):null;Mn.registerSaveRouter(GO),Mn.registerLoadRouter(GO);class MX{constructor(){this.indexedDB=oS()}listModels(){var t=this;return J(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(V0,1);s.onupgradeneeded=()=>iS(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(ul,"readonly"),l=i.objectStore(ul).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(t){var e=this;return J(function*(){return t=function FX(n){return n.startsWith(td.URL_SCHEME)?n.slice(td.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const o=e.indexedDB.open(V0,1);o.onupgradeneeded=()=>iS(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(ul,"readwrite"),l=a.objectStore(ul),u=l.get(t);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{c=i.transaction(yu,"readwrite");const p=c.objectStore(yu).delete(t);p.onsuccess=()=>r(u.result.modelArtifactsInfo),p.onerror=g=>s(u.error)};d.onsuccess=h,d.onerror=f=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const Oi="/",bu="tensorflowjs_models",qO="info",PX="model_topology",LX="weight_specs",$X="weight_data",VX="model_metadata";function KO(n){return{info:[bu,n,qO].join(Oi),topology:[bu,n,PX].join(Oi),weightSpecs:[bu,n,LX].join(Oi),weightData:[bu,n,$X].join(Oi),modelMetadata:[bu,n,VX].join(Oi)}}function XO(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function JO(n){const t=n.split(Oi);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Oi)}let nd=(()=>{class n{constructor(e){if(!G().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=KO(this.modelPath)}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),i=cp(e),a=ui.join(e.weightData);try{return r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function NX(n){if(Q2)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(a)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:i}}catch{throw XO(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return J(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=i;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(s.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(s.trainingConfig=u.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function TX(n){if(Q2){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),s})()}}return n.URL_SCHEME="localstorage://",n})();const ZO=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(nd.URL_SCHEME)?function zX(n){return new nd(n)}(n.slice(nd.URL_SCHEME.length)):null;Mn.registerSaveRouter(ZO),Mn.registerLoadRouter(ZO);class UX{constructor(){_(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),_(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return J(function*(){const e={},r=bu+Oi,s=Oi+qO;for(let o=0;o<t.LS.length;++o){const i=t.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(e[JO(i)]=JSON.parse(t.LS.getItem(i)))}return e})()}removeModel(t){var e=this;return J(function*(){const r=KO(t=function BX(n){return n.startsWith(nd.URL_SCHEME)?n.slice(nd.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return XO(r),s})()}}const rd="://";class is{constructor(){this.managers={}}static getInstance(){return null==is.instance&&(is.instance=new is),is.instance}static registerManager(t,e){_(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(rd)&&(t=t.slice(0,t.indexOf(rd))),_(t.length>0,()=>"scheme must not be an empty string.");const r=is.getInstance();_(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=is.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(is.getInstance().managers)}}function B0(n){if(-1===n.indexOf(rd))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${is.getSchemes().join(",")}`);return{scheme:n.split(rd)[0],path:n.split(rd)[1]}}function YO(n,t){return aS.apply(this,arguments)}function aS(){return(aS=J(function*(n,t,e=!1){_(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=Mn.getLoadHandlers(n);_(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),_(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],o=Mn.getSaveHandlers(t);_(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),_(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const i=o[0],a=B0(n).scheme,l=B0(n).path,u=a===B0(n).scheme,c=yield s.load();e&&u&&(yield is.getManager(a).removeModel(l));const d=yield i.save(c);return e&&!u&&(yield is.getManager(a).removeModel(l)),d.modelArtifactsInfo})).apply(this,arguments)}function WX(){return lS.apply(this,arguments)}function lS(){return(lS=J(function*(){const n=is.getSchemes(),t={};for(const e of n){const r=yield is.getManager(e).listModels();for(const s in r)t[e+rd+s]=r[s]}return t})).apply(this,arguments)}function HX(n){return uS.apply(this,arguments)}function uS(){return(uS=J(function*(n){const t=B0(n);return is.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function jX(n,t){return cS.apply(this,arguments)}function cS(){return(cS=J(function*(n,t){return YO(n,t,!1)})).apply(this,arguments)}function GX(n,t){return dS.apply(this,arguments)}function dS(){return(dS=J(function*(n,t){return YO(n,t,!0)})).apply(this,arguments)}class qX{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!G().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(t){return mO(t)}}if(G().get("IS_BROWSER")){G().setPlatform("browser",new qX);try{is.registerManager(nd.URL_SCHEME,new UX)}catch{}try{is.registerManager(td.URL_SCHEME,new MX)}catch{}}let sd;function Tt(n,t="float32",e){return t=t||"float32",ao(n),new hr(n,t,e)}G().get("IS_NODE")&&!G().get("IS_BROWSER")&&G().setPlatform("node",new class XX{constructor(){this.util=ee(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=G().global.fetch?G().global.fetch(t,e):(null==sd&&(sd=ee(410)),sd(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const Ce=M({cast_:function JX(n,t){const e=E(n,"x","cast");if(!function RK(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return $.runKernel(bf,{x:e},{dtype:t})}}),pa=M({clone_:function ZX(n){const e={x:E(n,"x","clone","string_or_numeric")};return $.runKernel(Af,e)}});function QO(n,t=!1){console.log(n.toString(t))}EO(),function aX(n){ed=n}({buffer:Tt,cast:Ce,clone:pa,print:QO});const ue=M({add_:function YX(n,t){let e=E(n,"a","add"),r=E(t,"b","add");return[e,r]=Wn(e,r),$.runKernel(Zc,{a:e,b:r})}}),hS=M({floorDiv_:function QX(n,t){let e=E(n,"a","floorDiv"),r=E(t,"b","floorDiv");return[e,r]=Wn(e,r),$.runKernel(Df,{a:e,b:r})}}),Ee=M({div_:function eJ(n,t){let e=E(n,"a","div"),r=E(t,"b","div");return[e,r]=Wn(e,r),"int32"===e.dtype&&"int32"===r.dtype?hS(e,r):$.runKernel(Sf,{a:e,b:r},{})}}),L=M({mul_:function tJ(n,t){let e=E(n,"a","mul"),r=E(t,"b","mul");return[e,r]=Wn(e,r),$.runKernel(Bf,{a:e,b:r})}}),$r=M({sqrt_:function nJ(n){const e={x:E(n,"x","sqrt","float32")};return $.runKernel(Qf,e)}}),cn=M({square_:function rJ(n){const t=E(n,"x","square");return $.runKernel("Square",{x:t},{})}}),Lt=M({zerosLike_:function sJ(n){const e={x:E(n,"x","zerosLike")};return $.runKernel(T0,e)}});function ma(n){return $.customGrad(n)}function Ke(n,t){if((Do(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Do(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return al(n,[],[],t)}const iJ=new Map,fS=new Map;class od{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Ao{constructor(){this.classNameMap={}}static getMap(){return null==Ao.instance&&(Ao.instance=new Ao),Ao.instance}static register(t){Ao.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function he(n,t,e){_(null!=n.className,()=>"Class being registered does not have the static className property defined."),_("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),_(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=t+">"+e;return Ao.register(n),iJ.set(s,n),fS.set(n,s),n}class cl extends od{minimize(t,e=!1,r){const{value:s,grads:o}=this.computeGradients(t,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return ut(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function oJ(n,t){_(IC(n),()=>"The f passed in variableGrads(f) must be a function"),_(null==t||Array.isArray(t)&&t.every(u=>u instanceof O0),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const u in $.registeredVariables)t.push($.registeredVariables[u])}const r=e?t.filter(u=>!u.trainable):null,s=t.length;_((t=t.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=$.gradients(n,t,null,!0);_(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),_(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return t.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}(t,e)}dispose(){null!=this.iterations_&&ut(this.iterations_)}saveIterations(){var t=this;return J(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Ke(t.iterations_,"int32")}})()}getWeights(){return J(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return J(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return J(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(cl,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class eF extends cl{static get className(){return"Adadelta"}constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=$.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=$.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:H(()=>Lt(o).variable(!1))}),null==this.accumulatedUpdates[s]&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:H(()=>Lt(o).variable(!1))});const a=Array.isArray(t)?t[s].tensor:t[r];if(null==a)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;H(()=>{const c=ue(L(l,this.rho),L(cn(a),1-this.rho)),d=L(Ee($r(ue(u,this.epsilon)),$r(ue(l,this.epsilon))),a),h=ue(L(u,this.rho),L(cn(d),1-this.rho));l.assign(c),u.assign(h);const f=ue(L(d,-this.learningRate),o);o.assign(f)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ut(this.accumulatedGrads.map(t=>t.variable)),ut(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return J(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return J(function*(){const r=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function id(n,t,e){return ao(n),e=e||Xc(t),$.runKernel(e2,{},{shape:n,value:t,dtype:e})}class tF extends cl{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=$.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:H(()=>id(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(t)?t[s].tensor:t[r];if(null==i)return;const a=this.accumulatedGrads[s].variable;H(()=>{const l=ue(a,cn(i));a.assign(l);const u=ue(L(Ee(i,$r(ue(l,$.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ut(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return J(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return J(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const ga=M({pow_:function aJ(n,t){let e=E(n,"base","pow"),r=E(t,"exp","pow");return[e,r]=Wn(e,r),$.runKernel(zf,{a:e,b:r})}}),De=M({sub_:function lJ(n,t){let e=E(n,"a","sub"),r=E(t,"b","sub");return[e,r]=Wn(e,r),$.runKernel(tp,{a:e,b:r})}});class nF extends cl{static get className(){return"Adam"}constructor(t,e,r,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],H(()=>{this.accBeta1=Ke(e).variable(),this.accBeta2=Ke(r).variable()}),null==s&&(this.epsilon=$.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);H(()=>{const r=De(1,this.accBeta1),s=De(1,this.accBeta2);e.forEach((o,i)=>{const a=$.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:H(()=>Lt(a).variable(!1))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:H(()=>Lt(a).variable(!1))});const u=Array.isArray(t)?t[i].tensor:t[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=ue(L(c,this.beta1),L(u,1-this.beta1)),f=ue(L(d,this.beta2),L(cn(u),1-this.beta2)),p=Ee(h,r),g=Ee(f,s);c.assign(h),d.assign(f);const m=ue(L(Ee(p,ue($r(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(L(this.accBeta1,this.beta1)),this.accBeta2.assign(L(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ut(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&ut(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return J(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return J(function*(){t=yield e.extractIterations(t),H(()=>{e.accBeta1.assign(ga(e.beta1,e.iterations_+1)),e.accBeta2.assign(ga(e.beta2,e.iterations_+1))});const r=t.length/2;e.accumulatedFirstMoment=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const fr=M({abs_:function uJ(n){const t=E(n,"x","abs");return $.runKernel("complex64"===t.dtype?Ay:Cy,{x:t})}});function ad(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const o=e-1-s,i=n[o]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function pr(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],o=t.length-r-1,i=t[o];(null==s||1===s&&i>1)&&e.unshift(o)}return e}function mt(n,t){const e=Math.max(n.length,t.length),r=new Array(e);for(let s=0;s<e;s++){let o=n[n.length-s-1];null==o&&(o=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===o)r[e-s-1]=i;else if(1===i)r[e-s-1]=o;else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);r[e-s-1]=o}}return r}const ya=M({maximum_:function cJ(n,t){let e=E(n,"a","maximum"),r=E(t,"b","maximum");return[e,r]=Wn(e,r),"bool"===e.dtype&&(e=Ce(e,"int32"),r=Ce(r,"int32")),mt(e.shape,r.shape),$.runKernel(Lf,{a:e,b:r})}});class rF extends cl{static get className(){return"Adamax"}constructor(t,e,r,s=null,o=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],H(()=>{this.iteration=Ke(0).variable(),this.accBeta1=Ke(e).variable()}),null==s&&(this.epsilon=$.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);H(()=>{const r=De(1,this.accBeta1),s=Ee(-this.learningRate,ue(L(this.iteration,this.decay),1));e.forEach((o,i)=>{const a=$.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:Lt(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:Lt(a).variable(!1)});const u=Array.isArray(t)?t[i].tensor:t[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=ue(L(c,this.beta1),L(u,1-this.beta1)),f=L(d,this.beta2),p=fr(u),g=ya(f,p);c.assign(h),d.assign(g);const m=ue(L(Ee(s,r),Ee(h,ue(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(ue(this.iteration,1)),this.accBeta1.assign(L(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ut(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&ut(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return J(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return J(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class pS extends cl{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=Array.isArray(t)?t[s].tensor:t[r];if(null==o)return;const i=$.registeredVariables[r];H(()=>{const a=ue(L(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=kr(Ke(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return J(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return J(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class sF extends pS{static get className(){return"Momentum"}constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Ke(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=$.registeredVariables[r];null==this.accumulations[s]&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:H(()=>Lt(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(t)?t[s].tensor:t[r];null!=a&&H(()=>{let l;const u=ue(L(this.m,i),a);l=ue(L(this.c,this.useNesterov?ue(a,L(u,this.m)):u),o),i.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ut(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return J(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return J(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class oF extends cl{static get className(){return"RMSProp"}constructor(t,e=.9,r=0,s=null,o=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==s&&(this.epsilon=$.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=$.registeredVariables[r],i=!1;null==this.accumulatedMeanSquares[s]&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:H(()=>Lt(o).variable(i))}),null==this.accumulatedMoments[s]&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:H(()=>Lt(o).variable(i))}),null==this.accumulatedMeanGrads[s]&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:H(()=>Lt(o).variable(i))});const a=Array.isArray(t)?t[s].tensor:t[r];if(null==a)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;H(()=>{const c=ue(L(l,this.decay),L(cn(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=ue(L(d,this.decay),L(a,1-this.decay)),f=Ee(L(a,this.learningRate),$r(De(c,ue(cn(h),this.epsilon)))),p=ue(L(u,this.momentum),f);l.assign(c),d.assign(h),u.assign(p);const g=De(o,p);o.assign(g)}else{const d=ue(L(l,this.decay),L(cn(a),1-this.decay)),h=ue(L(u,this.momentum),Ee(L(a,this.learningRate),$r(ue(d,this.epsilon))));l.assign(d),u.assign(h);const f=De(o,h);o.assign(f)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ut(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&ut(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&ut(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return J(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return J(function*(){t=yield e.extractIterations(t);const r=e.centered?t.length/3:t.length/2,s=!1;e.accumulatedMeanSquares=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.accumulatedMoments=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*r,3*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const dJ=[eF,tF,nF,rF,sF,oF,pS];function iF(n){return new Promise(t=>setTimeout(t)).then(n)}let mS=(()=>{class n{constructor(e){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return J(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=ui.join(e.weightData),o=window.URL.createObjectURL(new Blob([s],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const a=WO(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),l=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),u=r.modelJsonAnchor??document.createElement("a");if(u.download=r.modelJsonFileName,u.href=l,yield iF(()=>u.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=r.weightDataAnchor??document.createElement("a");c.download=r.weightDataFileName,c.href=o,yield iF(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:cp(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class gJ{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return J(function*(){return new Promise((e,r)=>{const s=new FileReader;s.onload=o=>{const i=JSON.parse(o.target.result),a=i.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==i.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const u=eS(i,c=>t.loadWeights(c));e(u)},s.onerror=o=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const i of t)e.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(t),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[e,i])}loadWeightsFile(t,e){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{r(i.target.result)},o.onerror=i=>s(`Failed to weights data from file of path '${t}'.`),o.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(o=>UO(o.name)),s={};for(const o of t)o.paths.forEach(i=>{const a=UO(i);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function vJ(n){return new gJ(n)}function aF(n,t,e,r){(function i(l){_(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,u){_(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),_(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),_(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=e??0,r=r??1);let s=0;return Promise.all(n.map(l=>(l.then(u=>{const c=e+ ++s/n.length*(r-e);return t(c),u}),l)))}function lF(n,t){return gS.apply(this,arguments)}function gS(){return(gS=J(function*(n,t){null==t&&(t={});const e=t.fetchFunc??G().platform.fetch,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield aF(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield aF(a,t.onProgress,.5,1)})).apply(this,arguments)}function xJ(n){return yS.apply(this,arguments)}function yS(){return(yS=J(function*(n,t="",e,r){return uF(i=>lF(i,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function uF(n){return function(){var t=J(function*(e,r="",s){const o=e.map(()=>!1),i={},a=null!=s?s.map(()=>!1):[],l=[];if(e.forEach((p,g)=>{let m=0;p.weights.forEach(y=>{const w=gu["quantization"in y?y.quantization.dtype:y.dtype]*Z(y.shape),x=()=>{o[g]=!0,null==i[g]&&(i[g]=[]),i[g].push({manifestEntry:y,groupOffset:m,sizeBytes:w})};null!=s?s.forEach((N,I)=>{N===y.name&&(x(),a[I]=!0)}):x(),l.push(y.name),m+=w})}),!a.every(p=>p)){const p=s.filter((g,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const u=o.reduce((p,g,m)=>(g&&p.push(m),p),[]),c=[];u.forEach(p=>{e[p].paths.forEach(g=>{const m=r+(r.endsWith("/")?"":"/")+g;c.push(m)})});const d=yield n(c),h={};let f=0;return u.forEach(p=>{const g=e[p].paths.length,m=new ui(d.slice(f,f+g));i[p].forEach(v=>{const x=PO(m.slice(v.groupOffset,v.groupOffset+v.sizeBytes),[v.manifestEntry]);for(const N in x)h[N]=x[N]}),f+=g}),h});return function(e){return t.apply(this,arguments)}}()}Mn.registerSaveRouter(n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(mS.URL_SCHEME)?function bJ(n="model"){return new mS(n)}(n.slice(mS.URL_SCHEME.length)):null);let cF=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(_("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=G().platform.fetch,_(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&_(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i=WO(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=e.weightData){const l=ui.join(e.weightData);s.body.append("model.weights.bin",new Blob([l],{type:"application/octet-stream"}),"model.weights.bin")}const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:cp(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}loadModelJSON(){var e=this;return J(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return s})()}load(){var e=this;return J(function*(){return e.loadOptions.streamWeights?e.loadStream():eS(yield e.loadModelJSON(),s=>e.loadWeights(s))})()}loadStream(){var e=this;return J(function*(){const r=yield e.loadModelJSON(),s=yield e.getWeightUrls(r.weightsManifest),o=nS(r.weightsManifest);return Object.assign(Object.assign({},r),{weightSpecs:o,getWeightStream:()=>function wJ(n,t){var e;const r=t.fetchFunc??G().platform.fetch;let o,s=0;return null===(e=t.onProgress)||void 0===e||e.call(t,0),new ReadableStream({pull:(i=J(function*(a){for(var l;s<n.length;){o||(o=(yield r(n[s],t.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:c}=yield o.read();if(!u)return void a.enqueue(c);s++,o=void 0,null===(l=t.onProgress)||void 0===l||l.call(t,s/n.length)}a.close()}),function(l){return i.apply(this,arguments)})});var i}(s,e.loadOptions)})})()}getWeightUrls(e){var r=this;return J(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function NJ(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||o,l=[],u=[];for(const c of e)for(const d of c.paths)null!=r.weightUrlConverter?u.push(r.weightUrlConverter(d)):l.push(a+d+i);return r.weightUrlConverter&&l.push(...yield Promise.all(u)),l})()}loadWeights(e){var r=this;return J(function*(){const s=yield r.getWeightUrls(e);return[nS(e),yield lF(s,r.loadOptions)]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function bS(n){return null!=n.match(cF.URL_SCHEME_REGEX)}const dF=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>bS(r)):bS(n),e)return vS(n,t)}return null};function vS(n,t){return new cF(n,t)}function TJ(n,t){return vS(n,t)}Mn.registerSaveRouter(dF),Mn.registerLoadRouter(dF);class wS{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class hF{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class IJ{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function _J(n,t,e,r){const s=arguments;return new IJ(fF(...s))}function fF(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new wS(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wS({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wS({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function EJ(n){return new hF(n)}function DJ(n){return new hF(n)}function pF(n,t,e){if(Gc(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=ol(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return al(n,t,r,e)}let vu,mF=!1;function yF(n){if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const t=2===n.rank?1:n.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function MJ(n,t){return CS.apply(this,arguments)}function CS(){return(CS=J(function*(n,t){let e=E(n,"img","toPixels");if(!(n instanceof on)){const u=e;e=Ce(u,"int32"),u.dispose()}yF(e);const[r,s]=e.shape.slice(0,2),o=2===e.rank?1:e.shape[2],i=yield e.data(),a="float32"===e.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){const c=[0,0,0,255];for(let h=0;h<o;h++){const f=i[u*o+h];if("float32"===e.dtype){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if("int32"===e.dtype&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);1===o?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[h]=f*a}const d=4*u;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(null!=t){mF||null!=D0(JC,$.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),mF=!0),t.width=s,t.height=r;const u=t.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return e!==n&&e.dispose(),l})).apply(this,arguments)}const U0=M({fromPixels_:function gF(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(null!=n.getContext)i=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(null!=D0(L2,$.backendName))return $.runKernel(L2,{pixels:n},{numChannels:t});const[u,c]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d,h;if(i)d=n.getContext("2d").getImageData(0,0,u,c).data;else if(r||e)d=n.data;else if(o||s||a){if(null==vu)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");vu=new OffscreenCanvas(1,1).getContext("2d")}else vu=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});vu.canvas.width=u,vu.canvas.height=c,vu.drawImage(n,0,0,u,c),d=vu.getImageData(0,0,u,c).data}if(4===t)h=new Int32Array(d);else{const p=u*c;h=new Int32Array(p*t);for(let g=0;g<p;g++)for(let m=0;m<t;++m)h[g*t+m]=d[4*g+m]}return pF(h,[c,u,t],"int32")}});function NS(n,t,e){const r=n.shape.length;_(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),_(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)_(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function LJ(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function TS(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function bF(n,t,e,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[t]=1:(s.splice(t,0,1),s.pop());return s}function vF(n,t,e){return e<=n?e:e-(t-1)}function wF(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function $J(n,t,e,r,s,o,i,a,l){const u=n.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&e>0){const f=t[0],p=e+1;c=xF(i,f,p,r,n),d=CF(a,f,p,s,n),h=bF(o,f,p,n)}else for(let f=0;f<u;f++)c[f]=NF(i,r,o,n,f,l),d[f]=TF(a,s,o,n,f,l),h[f]=SF(o,f,l);return{begin:c,end:d,strides:h}}function xF(n,t,e,r,s){const o=[...s],i=wF(e,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=vF(t,e,a);let u=r[l];n&1<<l&&(u=0),o[a]=u}return o}function CF(n,t,e,r,s){const o=[...s],i=wF(e,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=vF(t,e,a);let u=r[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=cu(0,o[a],s[a])}return o}function SF(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function NF(n,t,e,r,s,o){let i=t[s];(n&1<<s||o&1<<s||null==i)&&(i=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=cu(0,i,l-1),i}function TF(n,t,e,r,s,o){let i=t[s];const a=e[s]||1;(n&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?cu(0,i,l):cu(-1,i,l-1),i}function IS(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function _S(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function W0(n,t,e){let r;const s=n.shape.length;let o;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(i=>{_(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((i,a)=>i>=0?i:(_(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function ES(n,t,e,r,s,o,i,a,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!=(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let w=0;w<d.dims;w++)c&&0!=(1<<w&a)&&d.numAddAxisAfterEllipsis++,1<<w&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function VJ(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let f=!0,p=!0,g=!0;const m=[],y=[];for(let w=0;w<n.length;++w){if(0===h.strides[w])throw Error(`strides[${w}] must be non-zero`);const x=!!(h.shrinkAxisMask&1<<w),N=n[w];if(-1===N){m.push(x?1:-1);continue}const I=[h.beginMask&1<<w,h.endMask&1<<w],k=[h.strides[w]>0?0:-1,h.strides[w]>0?N:N-1];if(x&&h.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===h.strides[w];const A=!!(h.beginMask&1<<w&&h.endMask&1<<w);if(h.beginValid&&h.endValid){if(x){const q=h.begin[w]<0?N+h.begin[w]:h.begin[w];if(h.begin[w]=q,h.end[w]=h.begin[w]+1,q<0||q>=N)throw Error(`slice index ${h.begin[w]} of dimension ${w} out of bounds.`)}else h.begin[w]=IF(h.begin[w],0,h.strides[w],N,I,k),h.end[w]=IF(h.end[w],1,h.strides[w],N,I,k);const U=1===h.strides[w]&&0===h.begin[w]&&h.end[w]===N;f=f&&U,p=p&&(0===w&&1===h.strides[w]||U)}else f=f&&1===h.strides[w]&&A,p=p&&(0===w&&1===h.strides[w]||A);let R,F=!1;if(h.beginValid&&h.endValid?(R=h.end[w]-h.begin[w],F=!0):x?(R=1,F=!0):A&&N>=0&&(R=h.strides[w]<0?-N:N,F=!0),F){let U;U=0===R||R<0!=h.strides[w]<0?0:Math.trunc(R/h.strides[w])+(R%h.strides[w]!=0?1:0),m.push(U)}else m.push(-1)}for(let w=0;w<h.finalShapeGatherIndices.length;++w){const x=h.finalShapeGatherIndices[w];x>=0?y.push(m[x]):-2===x&&y.push(1)}return{finalShapeSparse:y.filter((w,x)=>-2!==h.finalShapeGatherIndices[x]),finalShape:y,isIdentity:f,sliceDim0:p,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function IF(n,t,e,r,s,o){if(s[t])return e>0?o[t]:o[t+1&1];{const i=n<0?r+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const _F=M({acos_:function zJ(n){const e={x:E(n,"x","acos")};return $.runKernel(df,e)}}),EF=M({acosh_:function UJ(n){const e={x:E(n,"x","acosh")};return $.runKernel(hf,e)}}),HJ=M({addN_:function WJ(n){_(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),_(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((s,o)=>E(s,`tensors${o}`,"addN")),e=t[0];return t.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Pt(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),$.runKernel(Sy,t)}}),DS=M({all_:function jJ(n,t=null,e=!1){const s={x:E(n,"x","all","bool")};return $.runKernel("All",s,{axis:t,keepDims:e})}}),H0=M({any_:function GJ(n,t=null,e=!1){const s={x:E(n,"x","any","bool")};return $.runKernel("Any",s,{axis:t,keepDims:e})}}),ld=M({argMax_:function qJ(n,t=0){const r={x:E(n,"x","argMax")};return $.runKernel(Ny,r,{axis:t})}}),DF=M({argMin_:function KJ(n,t=0){const r={x:E(n,"x","argMin")};return $.runKernel(Ty,r,{axis:t})}}),kF=M({asin_:function XJ(n){const e={x:E(n,"x","asin")};return $.runKernel(ff,e)}}),AF=M({asinh_:function JJ(n){const e={x:E(n,"x","asinh")};return $.runKernel(pf,e)}}),RF=M({atan_:function ZJ(n){const e={x:E(n,"x","atan")};return $.runKernel(mf,e)}}),OF=M({atan2_:function YJ(n,t){let e=E(n,"a","atan2"),r=E(t,"b","atan2");return[e,r]=Wn(e,r),$.runKernel(yf,{a:e,b:r})}}),FF=M({atanh_:function QJ(n){const e={x:E(n,"x","atanh")};return $.runKernel(gf,e)}});function dp(n,t,e,r,s="NHWC",o){return Ar(n,[...t,n[3]],e,o,r,null,null,va(s))}function Ro(n,t,e,r,s,o,i="channelsLast"){const[a,l]=hp(t);let u;if("channelsLast"===i)u=[a,l,n[3],n[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,n[1],n[1]]}return Ar(n,u,e,r,s,o,!1,i)}function ba(n,t,e,r,s,o,i="NDHWC"){const[a,l,u]=AS(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,n[4],n[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,n[1],n[1]]}return dl(n,c,e,r,s,!1,d,o)}function Ar(n,t,e,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=n}const[h,f,,p]=t,[g,m]=hp(e),[y,v]=hp(r),w=ud(h,y),x=ud(f,v),{padInfo:N,outHeight:I,outWidth:k}=function nZ(n,t,e,r,s,o,i,a,l){let u,c,d;if("number"==typeof n){u={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const f=function eZ(n,t,e,r,s){null==r&&(r=kS(n,t,e));const i=n[1];return[fp((n[0]-t+2*r)/e+1,s),fp((i-t+2*r)/e+1,s)]}([t,e],o,r,n,a);c=f[0],d=f[1]}else if("same"===n){c=Math.ceil(t/r),d=Math.ceil(e/s);const h=Math.max(0,(c-1)*r+o-t),f=Math.max(0,(d-1)*s+i-e),p=Math.floor(h/2),g=h-p,m=Math.floor(f/2);u={top:p,bottom:g,left:m,right:f-m,type:"SAME"}}else if("valid"===n)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-o+1)/r),d=Math.ceil((e-i+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],f="channelsLast"===l?n[1][1]:n[2][1],p="channelsLast"===l?n[2][0]:n[3][0],g="channelsLast"===l?n[2][1]:n[3][1];u={top:h,bottom:f,left:p,right:g,type:0===h&&0===f&&0===p&&0===g?"VALID":"EXPLICIT"},c=fp((t-o+h+f)/r+1,a),d=fp((e-i+p+g)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,g,m,w,x,o,a),A=i?p*d:p;let R;return"channelsFirst"===a?R=[l,A,I,k]:"channelsLast"===a&&(R=[l,I,k,A]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:I,outWidth:k,outChannels:A,padInfo:N,strideHeight:g,strideWidth:m,filterHeight:h,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:v,inShape:n,outShape:R,filterShape:t}}function dl(n,t,e,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=n;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=n}const[f,p,g,,m]=t,[y,v,w]=AS(e),[x,N,I]=AS(r),k=ud(f,x),A=ud(p,N),R=ud(g,I),{padInfo:F,outDepth:U,outHeight:q,outWidth:K}=function rZ(n,t,e,r,s,o,i,a,l,u,c){let d,h,f,p;if("valid"===n&&(n=0),"number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const m=function tZ(n,t,e,r,s,o){null==s&&(s=kS(n,t[0],r[0]));const i=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*s>=t[a]&&(i[a]=fp((n[a]-t[a]+2*s)/r[a]+1,o));return i}([t,e,r,1],[a,l,u],1,[s,o,i],n,c);h=m[0],f=m[1],p=m[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{h=Math.ceil(t/s),f=Math.ceil(e/o),p=Math.ceil(r/i);const g=(h-1)*s+a-t,m=(f-1)*o+l-e,y=(p-1)*i+u-r,v=Math.floor(g/2),w=g-v,x=Math.floor(m/2),N=m-x,I=Math.floor(y/2);d={top:x,bottom:N,left:I,right:y-I,front:v,back:w,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,u,c,d,y,v,w,k,A,R,a),Y=o?m*h:m;let Q;return"channelsFirst"===i?Q=[l,Y,U,q,K]:"channelsLast"===i&&(Q=[l,U,q,K,Y]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:U,outHeight:q,outWidth:K,outChannels:Y,padInfo:F,strideDepth:y,strideHeight:v,strideWidth:w,filterDepth:f,filterHeight:p,filterWidth:g,effectiveFilterDepth:k,effectiveFilterHeight:A,effectiveFilterWidth:R,dilationDepth:x,dilationHeight:N,dilationWidth:I,inShape:n,outShape:Q,filterShape:t}}function kS(n,t,e,r=1){const s=ud(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function hp(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function AS(n){return"number"==typeof n?[n,n,n]:n}function ud(n,t){return t<=1?n:n+(n-1)*(t-1)}function fp(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function hl(n){const[t,e,r]=hp(n);return 1===t&&1===e&&1===r}function Vr(n,t){return hl(n)||hl(t)}function wu(n){return hp(n).every(t=>t>0)}function va(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function as(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)_(qc(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{_(qc(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const V=M({reshape_:function sZ(n,t){const r={x:E(n,"x","reshape","string_or_numeric")};return $.runKernel(h0,r,{shape:t})}}),j0=M({avgPool_:function oZ(n,t,e,r,s){const o=E(n,"x","avgPool","float32");_(Vr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),_(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),as("avgPool",r,s);let d=$.runKernel(Iy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d=Ce(d,o.dtype),l?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),MF=M({avgPool3d_:function iZ(n,t,e,r,s,o="NDHWC"){const i=E(n,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),_(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),_("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),_("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),as("avgPool3d",r,s);let d=$.runKernel(_y,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d=Ce(d,a.dtype),l?V(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),_n=M({concat_:function aZ(n,t=0){_(n.length>=1,()=>"Pass at least one tensor to concat");const e=$0(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?pa(e[0]):$.runKernel(Ry,e,{axis:t})}}),Ft=M({matMul_:function lZ(n,t,e=!1,r=!1){let s=E(n,"a","matMul"),o=E(t,"b","matMul");return[s,o]=Wn(s,o),$.runKernel(Ey,{a:s,b:o},{transposeA:e,transposeB:r})}}),ci=M({sigmoid_:function uZ(n){const e={x:E(n,"x","sigmoid","float32")};return $.runKernel(Zf,e)}}),rt=M({slice_:function cZ(n,t,e){const r=E(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return $.runKernel(y0,{x:r},{begin:t,size:e})}}),xu=M({tanh_:function dZ(n){const e={x:E(n,"x","tanh","float32")};return $.runKernel(rp,e)}}),fZ=M({basicLSTMCell_:function hZ(n,t,e,r,s,o){const i=E(n,"forgetBias","basicLSTMCell"),a=E(t,"lstmKernel","basicLSTMCell"),l=E(e,"lstmBias","basicLSTMCell"),u=E(r,"data","basicLSTMCell"),c=E(s,"c","basicLSTMCell"),d=E(o,"h","basicLSTMCell"),h=_n([u,d],1),f=Ft(h,a),p=ue(f,l),m=p.shape[1]/4,y=[p.shape[0],m],v=rt(p,[0,0],y),w=rt(p,[0,m],y),x=rt(p,[0,2*m],y),N=rt(p,[0,3*m],y),I=ue(L(ci(v),xu(w)),L(c,ci(ue(i,x))));return[I,L(xu(I),ci(N))]}}),G0=M({batchToSpaceND_:function pZ(n,t,e){const r=E(n,"x","batchToSpaceND"),s=t.reduce((a,l)=>a*l);return _(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),_(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),_(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),$.runKernel(Dy,{x:r},{blockShape:t,crops:e})}});function mZ(n){let t;return t=0===n.rank||1===n.rank?V(n,[1,1,1,n.size]):2===n.rank?V(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?V(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const pp=M({batchNorm_:function gZ(n,t,e,r,s,o){null==o&&(o=.001);const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),_(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:mZ(i),scale:u,offset:c,mean:a,variance:l},p=$.runKernel(zy,h,{varianceEpsilon:o});return V(p,i.shape)}}),PF=M({batchNorm2d_:function yZ(n,t,e,r,s,o){const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),_(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),_(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),_(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&_(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&_(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),pp(i,a,l,c,u,o)}}),LF=M({batchNorm3d_:function bZ(n,t,e,r,s,o){const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),_(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),_(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),_(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&_(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&_(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),pp(i,a,l,c,u,o)}}),$F=M({batchNorm4d_:function vZ(n,t,e,r,s,o){const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),_(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),_(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),_(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&_(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&_(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),pp(i,a,l,c,u,o)}}),VF=M({bincount_:function wZ(n,t,e){const r=E(n,"x","bincount"),s=E(t,"weights","bincount");return _("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),_(e>=0,()=>`size must be non-negative, but got ${e}.`),_(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),$.runKernel(MC,{x:r,weights:s},{size:e})}}),CZ=M({bitwiseAnd_:function xZ(n,t){const e=E(n,"x","bitwiseAnd"),r=E(t,"y","bitwiseAnd");if(!Pt(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if("int32"!==e.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);return $.runKernel(ky,{a:e,b:r})}}),NZ=M({broadcastArgs_:function SZ(n,t){const e=E(n,"s0","broadcastArgs","int32"),r=E(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return $.runKernel(PC,{s0:e,s1:r})}}),cd=M({broadcastTo_:function TZ(n,t){let e=E(n,"broadcastTo","x");const r=e.shape;if(ao(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=V(e,u)}const s=e.shape,o=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?pa(e):$.runKernel(sp,{x:e},{reps:o})}}),BF=M({ceil_:function IZ(n){const e={x:E(n,"x","ceil","float32")};return $.runKernel(vf,e)}}),Ts=M({clipByValue_:function _Z(n,t,e){const r=E(n,"x","clipByValue");return _(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?id(r.shape,t,r.dtype):$.runKernel(wf,{x:r},{clipValueMin:t,clipValueMax:e})}}),zF=M({concat1d_:function EZ(n){return _n(n,0)}}),UF=M({concat2d_:function DZ(n,t){return _n(n,t)}}),WF=M({concat3d_:function kZ(n,t){return _n(n,t)}}),HF=M({concat4d_:function AZ(n,t){return _n(n,t)}}),fl=M({conv2d_:function RZ(n,t,e,r,s="NHWC",o=[1,1],i){const a=E(n,"x","conv2d","float32"),l=E(t,"filter","conv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),_(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),as("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];_(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),_(Vr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),_(wu(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),_(wu(e),()=>"Error in conv2D: Strides should be larger than 0.");const p=$.runKernel(Oy,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),RS=M({conv1d_:function OZ(n,t,e,r,s="NWC",o=1,i){const a=E(n,"x","conv1d"),l=E(t,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=V(a,[1,a.shape[0],a.shape[1]])),_(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),_(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),as("conv1d",r,i),_(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),_(Vr(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),_(wu(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),_(wu(e),()=>"Error in conv1D: Stride should be larger than 0."),_("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=V(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=V(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=fl(h,d,[1,e],r,"NHWC",[1,o],i);return V(m,c?[m.shape[2],m.shape[3]]:[m.shape[0],m.shape[2],m.shape[3]])}}),OS=M({conv2DBackpropInput_:function FZ(n,t,e,r,s,o="NHWC",i){_(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,u=!1;3===t.rank&&(u=!0,l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),_(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),_(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),_(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];_(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),_(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),as("conv2dDerInput",s,i);const p=$.runKernel(Fy,{dy:l,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),FS=M({conv2dTranspose_:function MZ(n,t,e,r,s,o){const i=E(n,"x","conv2dTranspose"),a=E(t,"filter","conv2dTranspose");return OS(e,i,a,r,s,"NHWC",o)}}),jF=M({conv3d_:function PZ(n,t,e,r,s="NDHWC",o=[1,1,1]){const i=E(n,"x","conv3d"),a=E(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),_(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),_(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),_(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),_(Vr(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),_("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),_(wu(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),_(wu(e),()=>"Error in conv3D: Strides should be larger than 0.");const h=$.runKernel(My,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:o});return u?V(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),GF=M({conv3DBackpropInput_:function LZ(n,t,e,r,s){_(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,i=t,a=!1;4===t.rank&&(a=!0,i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const l=o[4],u=i.shape[4];_(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),_(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),_(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),_(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),_(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=$.runKernel(BC,{dy:i,filter:e},{pad:s,strides:r,inputShape:o});return a?V(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),qF=M({conv3dTranspose_:function $Z(n,t,e,r,s){const o=E(n,"x","conv3dTranspose"),i=E(t,"filter","conv3dTranspose");return GF(e,o,i,r,s)}}),q0=M({cos_:function VZ(n){const e={x:E(n,"x","cos","float32")};return $.runKernel(xf,e)}}),MS=M({cosh_:function BZ(n){const e={x:E(n,"x","cosh","float32")};return $.runKernel(Cf,e)}}),K0=M({cumprod_:function zZ(n,t=0,e=!1,r=!1){const o={x:E(n,"x","cumprod")};return $.runKernel(zC,o,{axis:t,exclusive:e,reverse:r})}}),PS=M({cumsum_:function UZ(n,t=0,e=!1,r=!1){const o={x:E(n,"x","cumsum")};return $.runKernel(Py,o,{axis:t,exclusive:e,reverse:r})}}),LS=M({denseBincount_:function WZ(n,t,e,r=!1){const s=E(n,"x","denseBincount"),o=E(t,"weights","denseBincount");return _("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),_(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),_(e>=0,()=>`size must be non-negative, but got ${e}.`),_(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),$.runKernel(WC,{x:s,weights:o},{size:e,binaryOutput:r})}}),KF=M({depthToSpace_:function HZ(n,t,e="NHWC"){const r=E(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],i="NHWC"===e?r.shape[3]:r.shape[1];return _(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),_(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),_(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${r.shape}`),_(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`),$.runKernel(HC,{x:r},{blockSize:t,dataFormat:e})}}),mp=M({depthwiseConv2d_:function jZ(n,t,e,r,s="NHWC",o=[1,1],i){const a=E(n,"x","depthwiseConv2d","float32"),l=E(t,"filter","depthwiseConv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),_(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];_(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),as("depthwiseConv2d",r,i);const p=$.runKernel(Ly,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),qZ=M({diag_:function GZ(n){const e={x:E(n,"x","diag")};return $.runKernel(qC,e)}}),XF=M({dilation2d_:function KZ(n,t,e,r,s=[1,1],o="NHWC"){const i=E(n,"x","dilation2d"),a=E(t,"filter","dilation2d");_(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),_(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),_("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),_(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h=$.runKernel($y,{x:l,filter:a},{strides:e,pad:r,dilations:s});return u?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),di=M({equal_:function XZ(n,t){let e=E(n,"a","equal","string_or_numeric"),r=E(t,"b","equal","string_or_numeric");return[e,r]=Wn(e,r),mt(e.shape,r.shape),$.runKernel(Vy,{a:e,b:r})}}),Xr=M({where_:function JZ(n,t,e){const r=E(t,"a","where"),s=E(e,"b","where"),o=E(n,"condition","where","bool"),i=mt(mt(o.shape,r.shape),s.shape),a=cd(o,i),l=cd(r,i),u=cd(s,i);return $.runKernel(g0,{condition:a,t:l,e:u})}}),JF=M({divNoNan_:function ZZ(n,t){let e=E(n,"a","div"),r=E(t,"b","div");[e,r]=Wn(e,r);const s=Ee(e,r),o=Lt(s),i=di(r,o);return Xr(i,o,s)}}),ZF=M({dot_:function YZ(n,t){const e=E(n,"t1","dot"),r=E(t,"t2","dot");_(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(_(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const i=V(e,[1,-1]),a=V(r,[-1,1]),l=Ft(i,a);return V(l,[])}if(1===e.rank&&2===r.rank){const i=V(e,[1,-1]),a=V(r,[r.shape[0],r.shape[1]]),l=Ft(i,a);return V(l,[l.size])}if(2===e.rank&&1===r.rank){const i=V(r,[-1,1]),a=Ft(e,i);return V(a,[a.size])}{const i=V(r,[r.shape[0],r.shape[1]]);return Ft(e,i)}}}),dd=M({einsum_:function QZ(n,...t){const e=t.map((s,o)=>E(s,`tensors${o}`,"einsum"));return $.runKernel(ZC,e,{equation:n})}}),gp=M({elu_:function eY(n){const e={x:E(n,"x","elu","float32")};return $.runKernel(Nf,e)}}),nY=M({ensureShape_:function tY(n,t){const e=E(n,"x","ensureShape","string_or_numeric");if(!function kK(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(null!==n[e]&&null!==t[e]&&n[e]!==t[e])return!1;return!0}(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}}),$S=M({erf_:function rY(n){let t=E(n,"x","erf");return _("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Ce(t,"float32")),$.runKernel(Tf,{x:t})}});function VS(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function YF(n,t,e){const r=n.length+t.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[o++]):s.push(t[i++]);return s}function Rr(n,t){const e=[],r=n.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&e.push(n[o]);return[e,t.map(o=>n[o])]}function Jn(n,t){return YF(n,t.map(r=>1),t)}function Br(n,t,e){_(VS(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Pn(n,t){if(VS(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function pl(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Zn(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Oo=M({max_:function sY(n,t=null,e=!1){const s={x:E(n,"x","max")};return $.runKernel(Zy,s,{reductionIndices:t,keepDims:e})}}),yp=M({min_:function oY(n,t=null,e=!1){const s={x:E(n,"x","min")};return $.runKernel(t0,s,{axis:t,keepDims:e})}}),$e=M({sum_:function iY(n,t=null,e=!1){let r=E(n,"x","sum");return"bool"===r.dtype&&(r=Ce(r,"int32")),$.runKernel(b0,{x:r},{axis:t,keepDims:e})}});function QF(n,t,e=null){if(0===n.rank)return fr(n);if(1!==n.rank&&null===e)return QF(V(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return $e(fr(n),e);if(t===1/0)return Oo(fr(n),e);if(t===-1/0)return yp(fr(n),e);if("euclidean"===t||2===t)return $r($e(ga(fr(n),Ke(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Oo($e(fr(n),e[0]),e[1]-1);if(t===1/0)return Oo($e(fr(n),e[1]),e[0]);if(t===-1/0)return yp($e(fr(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return $r($e(cn(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const bp=M({norm_:function aY(n,t="euclidean",e=null,r=!1){const s=QF(n=E(n,"x","norm"),t,e);let o=s.shape;if(r){const i=Rt(e,n.shape);o=Jn(s.shape,i)}return V(s,o)}}),eM=M({euclideanNorm_:function lY(n,t=null,e=!1){return bp(n,"euclidean",t,e)}}),ls=M({exp_:function uY(n){const e={x:E(n,"x","exp")};return $.runKernel(If,e)}}),zr=M({expandDims_:function cY(n,t=0){const e=E(n,"x","expandDims","string_or_numeric");return _(t<=e.rank,()=>"Axis must be <= rank of the tensor"),$.runKernel(By,{input:e},{dim:t})}}),tM=M({expm1_:function dY(n){const e={x:E(n,"x","expm1")};return $.runKernel(_f,e)}}),Fo=M({tile_:function hY(n,t){const e=E(n,"x","tile","string_or_numeric");return _(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),$.runKernel(sp,{x:e},{reps:t})}}),BS=M({eye_:function fY(n,t,e,r="float32"){null==t&&(t=n);const s=Tt([n,t],r),o=n<=t?n:t;for(let a=0;a<o;++a)s.set(1,a,a);const i=V(s.toTensor(),[n,t]);if(null==e)return i;if(1===e.length)return Fo(zr(i,0),[e[0],1,1]);if(2===e.length)return Fo(zr(zr(i,0),0),[e[0],e[1],1,1]);if(3===e.length)return Fo(zr(zr(zr(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),vp=M({floor_:function pY(n){const e={x:E(n,"x","floor","float32")};return $.runKernel(Ef,e)}}),wp=M({gather_:function mY(n,t,e=0,r=0){const s=E(n,"x","gather"),o=E(t,"indices","gather","int32");return $.runKernel(Uy,{x:s,indices:o},{axis:e,batchDims:r})}}),Ws=M({greater_:function gY(n,t){let e=E(n,"a","greater","string_or_numeric"),r=E(t,"b","greater","string_or_numeric");return[e,r]=Wn(e,r),mt(e.shape,r.shape),$.runKernel(Wy,{a:e,b:r})}}),ml=M({greaterEqual_:function yY(n,t){let e=E(n,"a","greaterEqual","string_or_numeric"),r=E(t,"b","greaterEqual","string_or_numeric");return[e,r]=Wn(e,r),mt(e.shape,r.shape),$.runKernel(kf,{a:e,b:r})}}),X0=M({imag_:function bY(n){const e={input:E(n,"input","imag")};return $.runKernel(s2,e)}}),nM=M({isFinite_:function vY(n){const e={x:E(n,"x","isFinite")};return $.runKernel(Rf,e)}}),rM=M({isInf_:function wY(n){const e={x:E(n,"x","isInf")};return $.runKernel(Of,e)}}),sM=M({isNaN_:function xY(n){const e={x:E(n,"x","isNaN")};return $.runKernel(Ff,e)}}),J0=M({leakyRelu_:function CY(n,t=.2){const r={x:E(n,"x","leakyRelu")};return $.runKernel(Hy,r,{alpha:t})}}),xp=M({less_:function SY(n,t){let e=E(n,"a","less","string_or_numeric"),r=E(t,"b","less","string_or_numeric");return[e,r]=Wn(e,r),mt(e.shape,r.shape),$.runKernel(jy,{a:e,b:r})}}),Cu=M({lessEqual_:function NY(n,t){let e=E(n,"a","lessEqual","string_or_numeric"),r=E(t,"b","lessEqual","string_or_numeric");return[e,r]=Wn(e,r),mt(e.shape,r.shape),$.runKernel(Gy,{a:e,b:r})}});function TY(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return $.runKernel(o2,{},{start:n,stop:t,num:e})}const oM=M({localResponseNormalization_:function IY(n,t=5,e=1,r=1,s=.5){const o=E(n,"x","localResponseNormalization");_(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),_(qc(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=V(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=$.runKernel(Jy,{x:i},{depthRadius:t,bias:e,alpha:r,beta:s});return a?V(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),uo=M({log_:function _Y(n){const e={x:E(n,"x","log","float32")};return $.runKernel(Mf,e)}}),Z0=M({log1p_:function EY(n){const e={x:E(n,"x","log1p")};return $.runKernel(Pf,e)}}),In=M({neg_:function DY(n){const e={x:E(n,"x","neg")};return $.runKernel(r0,e)}}),hd=M({softplus_:function kY(n){const e={x:E(n,"x","softplus")};return $.runKernel(Yf,e)}}),iM=M({logSigmoid_:function AY(n){const t=E(n,"x","logSigmoid");return ma(r=>({value:In(hd(In(r))),gradFunc:i=>L(i,ci(In(r)))}))(t)}}),zS=M({logSoftmax_:function RY(n,t=-1){const e=E(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return ma((s,o)=>{const a=Oo(s,t,!0),l=De(s,a),u=De(Ce(l,"float32"),uo($e(ls(l),t,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[f]=h,g=ls(f);return De(d,L($e(d,t,!0),g))}}})(e)}}),Y0=M({logSumExp_:function OY(n,t=null,e=!1){const r=E(n,"x","logSumExp"),s=Rt(t,r.shape),o=Oo(r,s,!0),i=De(r,o),a=ls(i),l=$e(a,s),u=uo(l),c=ue(V(o,u.shape),u);if(e){const d=Jn(c.shape,s);return V(c,d)}return c}}),Fi=M({logicalAnd_:function FY(n,t){const e=E(n,"a","logicalAnd","bool"),r=E(t,"b","logicalAnd","bool");return mt(e.shape,r.shape),$.runKernel(qy,{a:e,b:r})}}),Q0=M({logicalNot_:function MY(n){const e={x:E(n,"x","logicalNot","bool")};return $.runKernel(Ky,e)}}),US=M({logicalOr_:function PY(n,t){const e=E(n,"a","logicalOr","bool"),r=E(t,"b","logicalOr","bool");return mt(e.shape,r.shape),$.runKernel(Xy,{a:e,b:r})}}),aM=M({logicalXor_:function LY(n,t){const e=E(n,"a","logicalXor","bool"),r=E(t,"b","logicalXor","bool");return mt(e.shape,r.shape),Fi(US(n,t),Q0(Fi(n,t)))}}),e1=2147483648,WS=M({searchSorted_:function $Y(n,t,e="left"){const r=E(n,"sortedSequence","searchSorted"),s=E(t,"values","searchSorted"),i=s.shape[s.shape.length-1],a=V(r,[-1,r.shape[r.shape.length-1]]),l=V(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Z(l.shape)>=e1)throw new Error(`values tensor size must less than ${e1}`);if(a.shape[1]>=e1)throw new Error(`trailing dim_size must less than ${e1} for int32 output type, was ${a.shape[1]}`);return $.runKernel(S2,{sortedSequence:a,values:l},{side:e})}});function VY(n,t){return WS(n,t,"left")}const t1=M({maxPool_:function BY(n,t,e,r,s){const o=E(n,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),_(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),_(Vr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),as("maxPool",r,s);const d=$.runKernel(Yy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return l?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),lM=M({maxPool3d_:function zY(n,t=[1,1,1],e,r,s,o="NDHWC"){const i=E(n,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),_(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),_("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),as("maxPool3d",r,s);const d=$.runKernel(Qy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return l?V(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),WY=M({maxPoolWithArgmax_:function UY(n,t,e,r,s=!1){const i={x:E(n,"x","maxPoolWithArgmax")},l=$.runKernel(u2,i,{filterSize:t,strides:e,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}}),Hn=M({mean_:function HY(n,t=null,e=!1){const s={x:E(n,"x","mean")};return $.runKernel(e0,s,{axis:t,keepDims:e})}});function ar(n,t="float32"){if(ao(n),"complex64"===t){const r=ar(n,"float32"),s=ar(n,"float32");return il(r,s)}const e=Kr(Z(n),t);return $.makeTensor(e,n,t)}function Is(n,t="float32"){if(ao(n),"complex64"===t){const r=Is(n,"float32"),s=ar(n,"float32");return il(r,s)}const e=EC(Z(n),t);return $.makeTensor(e,n,t)}function jY(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=E(n,"x","meshgrid",n instanceof on?n.dtype:"float32");if(void 0===t)return[r];let s=E(t,"y","meshgrid",t instanceof on?t.dtype:"float32");const o=Z(r.shape),i=Z(s.shape);return"xy"===e?(r=V(r,[1,-1]),s=V(s,[-1,1]),[Ft(Is([i,1],r.dtype),r),Ft(s,Is([1,o],s.dtype))]):(r=V(r,[-1,1]),s=V(s,[1,-1]),[Ft(r,Is([1,i],r.dtype)),Ft(Is([o,1],s.dtype),s)])}const Su=M({minimum_:function GY(n,t){let e=E(n,"a","minimum"),r=E(t,"b","minimum");return[e,r]=Wn(e,r),"bool"===e.dtype&&(e=Ce(e,"int32"),r=Ce(r,"int32")),mt(e.shape,r.shape),$.runKernel($f,{a:e,b:r})}}),uM=M({mirrorPad_:function qY(n,t,e){_("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=E(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");_(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)_(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),_(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return $.runKernel(n0,{x:r},{paddings:t,mode:e})}}),cM=M({mod_:function KY(n,t){let e=E(n,"a","mod"),r=E(t,"b","mod");return[e,r]=Wn(e,r),$.runKernel(Vf,{a:e,b:r})}}),n1=M({moments_:function XY(n,t=null,e=!1){const r=Rt(t,(n=E(n,"x","moments")).shape),s=Hn(n,r,e);let o=s.shape;e||(o=Jn(s.shape,r));const i=cn(De(Ce(n,"float32"),V(s,o)));return{mean:s,variance:Hn(i,r,e)}}}),ZY=M({multiRNNCell_:function JY(n,t,e,r){const s=E(t,"data","multiRNNCell"),o=$0(e,"c","multiRNNCell"),i=$0(r,"h","multiRNNCell");let a=s;const l=[];for(let d=0;d<n.length;d++){const h=n[d](a,o[d],i[d]);l.push(h[0]),l.push(h[1]),a=h[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}}),QY=M({multinomial_:function YY(n,t,e,r=!1){const s=E(n,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();const l={logits:1===i?V(s,[1,-1]):s},c=$.runKernel(c2,l,{numSamples:t,seed:e,normalized:r});return 1===i?V(c,[c.size]):c}}),fd=M({notEqual_:function eQ(n,t){let e=E(n,"a","notEqual","string_or_numeric"),r=E(t,"b","notEqual","string_or_numeric");return[e,r]=Wn(e,r),mt(e.shape,r.shape),$.runKernel(s0,{a:e,b:r})}}),r1=M({oneHot_:function tQ(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:E(n,"indices","oneHot","int32")};return $.runKernel(a0,i,{dtype:s,depth:t,onValue:e,offValue:r})}}),co=M({onesLike_:function nQ(n){const e={x:E(n,"x","onesLike")};return $.runKernel(o0,e)}}),sQ=M({outerProduct_:function rQ(n,t){const e=E(n,"v1","outerProduct"),r=E(t,"v2","outerProduct");_(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const s=V(e,[-1,1]),o=V(r,[1,-1]);return Ft(s,o)}}),gl=M({pad_:function oQ(n,t,e=0){const r=E(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return $.runKernel(u0,{x:r},{paddings:t,constantValue:e})}}),aQ=M({pad1d_:function iQ(n,t,e=0){return _(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),gl(n,[t],e)}}),uQ=M({pad2d_:function lQ(n,t,e=0){return _(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),gl(n,t,e)}}),dQ=M({pad3d_:function cQ(n,t,e=0){return _(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),gl(n,t,e)}}),fQ=M({pad4d_:function hQ(n,t,e=0){return _(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),gl(n,t,e)}}),s1=M({spaceToBatchND_:function pQ(n,t,e){const r=E(n,"x","spaceToBatchND");return _(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),_(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),_(r.shape.reduce((i,a,l)=>l>0&&l<=t.length?i&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),$.runKernel(v0,{x:r},{blockShape:t,paddings:e})}}),dM=M({pool_:function mQ(n,t,e,r,s,o,i){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const a=E(n,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_(Vr(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const c=Ro(l.shape,t,o,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function yQ(n,t){const r=n.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[p,g]=function gQ(n,t,e){const r=e.map(c=>c[0]),s=e.map(c=>c[1]),o=n.concat(r,s),i=t.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],a[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),m=f?r:"valid",y=f?l:s1(l,d,p),w=("avg"===e?()=>j0(y,t,o,m,i):()=>t1(y,t,o,m,i))(),x=f?w:G0(w,d,g);return u?V(x,[x.shape[1],x.shape[2],x.shape[3]]):x}}),o1=M({prelu_:function bQ(n,t){const e=E(n,"x","prelu"),r=E(t,"alpha","prelu");return $.runKernel(c0,{x:e,alpha:r})}}),hM=M({prod_:function vQ(n,t=null,e=!1){let r=E(n,"x","prod");return"bool"===r.dtype&&(r=Ce(r,"int32")),$.runKernel(d0,{x:r},{axis:t,keepDims:e})}}),xQ=M({raggedGather_:function wQ(n,t,e,r){const s=n.map((c,d)=>E(c,`tensors${d}`,"raggedGather","int32")),o=E(t,"paramsDenseValues","raggedGather"),i=E(e,"indices","raggedGather","int32"),u=$.runKernel(p2,{paramsNestedSplits:s,paramsDenseValues:o,indices:i},{outputRaggedRank:r});return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}}),SQ=M({raggedRange_:function CQ(n,t,e){const r=E(n,"starts","raggedRange"),s=E(t,"limits","raggedRange",r.dtype),o=E(e,"deltas","raggedRange",r.dtype),a=$.runKernel(m2,{starts:r,limits:s,deltas:o});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),TQ=M({raggedTensorToTensor_:function NQ(n,t,e,r,s){const o=E(n,"shape","raggedTensorToTensor","int32"),i=E(t,"values","raggedTensorToTensor"),a=E(e,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,h)=>E(d,`tensors${h}`,"raggedTensorToTensor","int32"));return $.runKernel(g2,{shape:o,values:i,defaultValue:a,rowPartitionTensors:l},{rowPartitionTypes:s})}}),_Q=M({rand_:function IQ(n,t,e){ao(n);const r=Z(n);let s=null;if(null==e||"float32"===e)s=new Float32Array(r);else if("int32"===e)s=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);s=new Uint8Array(r)}for(let o=0;o<r;o++)s[o]=t();return $.makeTensor(s,n,e)}});var i1=ee(340);class HS{constructor(t,e,r,s,o){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=i1.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class EQ{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;const o=s||Math.random();this.randu=i1.alea(o.toString()),this.randn=new HS(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,o,i;for(;;){do{s=this.randn.nextValue(),i=1+this.c*s}while(i<=0);if(i*=i*i,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-i+Math.log(i)),o=this.randu(),o<e||Math.log(o)<r)break}return i*=1/this.beta*this.d,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class DQ{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=i1.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const FQ=M({randomGamma_:function OQ(n,t,e=1,r="float32",s){if(ao(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const o=new EQ(t,e,r,s),i=Tt(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),GS=M({randomNormal_:function MQ(n,t=0,e=1,r,s){if(ao(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new HS(t,e,r,!1,s),i=Tt(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),LQ=M({randomStandardNormal_:function PQ(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return GS(n,0,1,t,e)}}),Nu=M({randomUniform_:function $Q(n,t=0,e=1,r="float32",s){ao(n);const o=Tt(n,r),i=new DQ(t,e,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),BQ=M({randomUniformInt_:function VQ(n,t,e,r){return Nu(n,t,e,"int32",r)}});function pd(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return $.runKernel(y2,{},{start:n,stop:t,step:e,dtype:r})}const Cp=M({real_:function zQ(n){const e={input:E(n,"input","real")};return $.runKernel(b2,e)}}),fM=M({reciprocal_:function UQ(n){const e={x:E(n,"x","reciprocal")};return $.runKernel(Uf,e)}}),Mi=M({relu_:function WQ(n){const e={x:E(n,"x","relu")};return $.runKernel(Wf,e)}}),qS=M({relu6_:function HQ(n){const e={x:E(n,"x","relu6")};return $.runKernel(Hf,e)}}),Mo=M({reverse_:function jQ(n,t){const r={x:E(n,"x","reverse")};return $.runKernel(m0,r,{dims:t})}}),qQ=M({reverse1d_:function GQ(n){const t=E(n,"x","reverse");return _(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Mo(t,0)}}),XQ=M({reverse2d_:function KQ(n,t){const e=E(n,"x","reverse");return _(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Mo(e,t)}}),ZQ=M({reverse3d_:function JQ(n,t){const e=E(n,"x","reverse");return _(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Mo(e,t)}}),QQ=M({reverse4d_:function YQ(n,t){const e=E(n,"x","reverse");return _(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Mo(e,t)}}),KS=M({round_:function eee(n){const e={x:E(n,"x","round")};return $.runKernel(jf,e)}}),XS=M({rsqrt_:function tee(n){const e={x:E(n,"x","rsqrt","float32")};return $.runKernel(Gf,e)}}),JS=M({selu_:function nee(n){const e={x:E(n,"x","selu")};return $.runKernel(qf,e)}}),ZS=M({separableConv2d_:function ree(n,t,e,r,s,o=[1,1],i="NHWC"){const a=E(n,"x","separableConv2d"),l=E(t,"depthwiseFilter","separableConv2d"),u=E(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");_(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),_(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),_(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),_(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),_(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],f=l.shape[3];_(u.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${u.shape[2]}.`);const p=mp(c,l,r,s,i,o),m=fl(p,u,1,"valid",i);return d?V(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});function YS(){return(YS=J(function*(n,t){const e=E(n,"x","setdiff1d"),r=E(t,"y","setdiff1d");_(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),_(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),_(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),o=yield r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const l=new hr([a],e.dtype),u=new hr([a],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}const oee=function see(n,t){return YS.apply(this,arguments)},pM=M({sign_:function iee(n){const e={x:E(n,"x","sign")};return $.runKernel(Jf,e)}}),QS=M({sin_:function aee(n){const e={x:E(n,"x","sin","float32")};return $.runKernel(Kf,e)}}),eN=M({sinh_:function lee(n){const e={x:E(n,"x","sinh")};return $.runKernel(Xf,e)}}),a1=M({slice1d_:function uee(n,t,e){const r=E(n,"x","slice1d");return _(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),rt(r,[t],[e])}}),tN=M({slice2d_:function cee(n,t,e){const r=E(n,"x","slice2d");return _(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),rt(r,t,e)}}),l1=M({slice3d_:function dee(n,t,e){const r=E(n,"x","slice3d");return _(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),rt(r,t,e)}}),Sp=M({slice4d_:function hee(n,t,e){const r=E(n,"x","slice4d");return _(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),rt(r,t,e)}}),u1=M({softmax_:function fee(n,t=-1){const e=E(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return $.runKernel(x0,{logits:e},{dim:t})}}),c1=M({fft_:function pee(n){return _("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),$.runKernel("FFT",{input:n})}}),Np=M({ifft_:function mee(n){return _("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),$.runKernel(r2,{input:n})}}),nN=M({irfft_:function gee(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=V(n,[e,t]);r=Np(s)}else{const s=[e,2*(t-1)],o=V(Cp(n),[e,t]),i=V(X0(n),[e,t]),a=Mo(rt(o,[0,1],[e,t-2]),1),l=L(Mo(rt(i,[0,1],[e,t-2]),1),Ke(-1)),u=_n([o,a],1),c=_n([i,l],1),d=V(il(u,c),[s[0],s[1]]);r=Np(d)}if(r=Cp(r),3===n.rank&&0!==n.shape[0]){const s=r,o=n.shape[0];r=V(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),Hs=M({split_:function yee(n,t,e=0){const s={x:E(n,"x","split")};return $.runKernel(w0,s,{numOrSizeSplits:t,axis:e})}}),d1=M({rfft_:function bee(n,t){_("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const p=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=t,s=rt(n,p,g),e=t}else if(null!=t&&t>e){const p=n.shape.map(g=>g);p[n.shape.length-1]=t-e,s=_n([n,ar(p)],n.shape.length-1),e=t}else s=n;const o=Lt(s),i=V(il(s,o),[r,e]),a=c1(i),l=Math.floor(e/2)+1,u=Cp(a),c=X0(a),d=Hs(u,[l,e-l],u.shape.length-1),h=Hs(c,[l,e-l],c.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,V(il(d[0],h[0]),f)}}),rN=M({squaredDifference_:function vee(n,t){let e=E(n,"a","squaredDifference"),r=E(t,"b","squaredDifference");return[e,r]=Wn(e,r),mt(e.shape,r.shape),$.runKernel(ep,{a:e,b:r},{})}}),Yn=M({squeeze_:function wee(n,t){const e=E(n,"x","squeeze","string_or_numeric");return V(e,el(e.shape,t).newShape)}}),_s=M({stack_:function xee(n,t=0){const e=$0(n,"tensors","stack","string_or_numeric");return _(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&_(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),$.runKernel(l0,e,{axis:t})}}),md=M({step_:function Cee(n,t=0){const r={x:E(n,"x","step")};return $.runKernel(op,r,{alpha:t})}}),mM=M({stridedSlice_:function See(n,t,e,r,s=0,o=0,i=0,a=0,l=0){const c={x:E(n,"x","stridedSlice","string_or_numeric")};return $.runKernel(k2,c,{begin:t,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}}),gM=M({tan_:function Nee(n){const e={x:E(n,"x","tan","float32")};return $.runKernel(np,e)}});function Qn(n,t){Gc(n);const e=ol(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return al(n,null,e,t)}function Pi(n,t,e){if(Gc(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=ol(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return al(n,t,r,e)}function Tee(n,t,e){if(Gc(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=ol(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return al(n,t,r,e)}function Iee(n,t,e){if(Gc(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=ol(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return al(n,t,r,e)}function _ee(n,t,e){if(Gc(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=ol(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return al(n,t=t||r,r,e)}function yM(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(o+" update.rank != "+(s+n.length-r));for(let i=0;i<s;++i)if(e.shape[i]!==t.shape[i])throw new Error(o+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-s;++i)if(e.shape[i+s]!==n[i+r])throw new Error(o+` updates.shape[${i+s}] (${e.shape[i+s]}) != shape[${i+s}] (${n[i+s]})`)}function sN(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}yM(e,t,n)}function Tu(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,o=e.length;let i=1;for(let d=s;d<o;++d)i*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:Z(t.shape)/a,sliceSize:i,strides:[...Ge(e.slice(0,s)),1],outputSize:Z(e)}}const Dee=M({tensorScatterUpdate_:function Eee(n,t,e){const r=E(n,"tensor","tensorScatterupdate"),s=E(t,"indices","tensorScatterupdate","int32"),o=E(e,"updates","tensorScatterupdate");if(sN(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);return $.runKernel(C2,{tensor:r,indices:s,updates:o},{})}}),bM=M({topk_:function kee(n,t=1,e=!0){const r=E(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const o={x:r},i={k:t,sorted:e},[a,l]=$.runKernel(F2,o,i);return{values:a,indices:l}}}),oN=M({truncatedNormal_:function Aee(n,t=0,e=1,r,s){if(ao(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new HS(t,e,r,!0,s),i=Tt(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),vM=M({unique_:function Ree(n,t=0){const e=E(n,"x","unique","string_or_numeric");_(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[o,i]=$.runKernel(P2,r,s);return{values:o,indices:i}}}),iN=M({unsortedSegmentSum_:function Oee(n,t,e){const r=E(n,"x","unsortedSegmentSum"),s=E(t,"segmentIds","unsortedSegmentSum","int32");return _(qc(e),()=>"numSegments must be of dtype int"),$.runKernel(N0,{x:r,segmentIds:s},{numSegments:e})}}),Po=M({unstack_:function Fee(n,t=0){const e=E(n,"x","unstack","string_or_numeric");return _(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),$.runKernel(S0,{value:e},{axis:t})}});function Mee(n,t){return WS(n,t,"right")}function wM(n,t=!0,e,r){return $.makeVariable(n,t,e,r)}function aN(n,t){const e=[];for(let o=0;o<t.length;o++)t[o]&&e.push(o);const r=Tt(n,"int32"),s=Tt([e.length,n.length],"int32");for(let o=0;o<e.length;o++){const i=r.indexToLoc(e[o]);s.values.set(i,o*n.length)}return s.toTensor()}function lN(){return(lN=J(function*(n){const t=E(n,"condition","whereAsync","bool"),e=yield t.data(),r=aN(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const xM=function Pee(n){return lN.apply(this,arguments)};function uN(){return(uN=J(function*(n,t,e){const r=E(n,"tensor","boolMask"),s=E(t,"mask","boolMask","bool"),o=e??0,i=s.rank,a=r.shape;_(i>0,()=>"mask cannot be scalar"),Bs(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=o;g<o+i;g++)l*=a[g];const u=a.slice(0,o).concat([l],a.slice(o+i)),c=V(r,u),d=V(s,[-1]),h=yield xM(d),f=Yn(h,[1]),p=wp(c,f,o);return n!==r&&r.dispose(),t!==s&&s.dispose(),f.dispose(),c.dispose(),d.dispose(),h.dispose(),p})).apply(this,arguments)}const $ee=function Lee(n,t,e){return uN.apply(this,arguments)},$t=M({transpose_:function Vee(n,t,e){const r=E(n,"x","transpose");if(null==t&&(t=r.shape.map((i,a)=>a).reverse()),_(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{_(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:t};return"complex64"===r.dtype?H(()=>{let i=Cp(r),a=X0(r);return i=$.runKernel(Yc,{x:i},o),a=$.runKernel(Yc,{x:a},o),e&&(a=In(a)),il(i,a)}):$.runKernel(Yc,s,o)}}),zee=M({movingAverage_:function Bee(n,t,e,r,s=!0){const o=E(n,"v","movingAverage"),i=E(t,"x","movingAverage"),a=E(e,"decay","movingAverage");(function cX(n,t){_(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(o,i),_(Pt(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=Ke(1),u=De(l,a);let c=L(De(i,o),u);if(s){_(null!=r,()=>"When using zeroDebias: true, step is required.");const d=E(r,"step","movingAverage");c=Ee(c,De(l,ga(a,d)))}return ue(o,c)}}),Wee=M({scatterND_:function Uee(n,t,e){ao(e);const r=E(n,"indices","scatterND","int32"),s=E(t,"updates","scatterND");return sN(s,r,e),$.runKernel(x2,{indices:r,updates:s},{shape:e})}}),Gee=M({sparseToDense_:function jee(n,t,e,r=0){ao(e);const s=E(n,"sparseIndices","sparseToDense","int32"),o=E(t,"sparseValues","sparseToDense","string_or_numeric"),i=E(r,"defaultValue","sparseToDense",o.dtype);return function Hee(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,e,i),$.runKernel(E2,{sparseIndices:s,sparseValues:o,defaultValue:i},{outputShape:e})}}),Kee=M({gatherND_:function qee(n,t){const e=E(t,"indices","gatherND","int32"),s={params:E(n,"x","gatherND","string_or_numeric"),indices:e};return $.runKernel(n2,s)}}),CM=M({dropout_:function Jee(n,t,e,r){const s=E(n,"x","dropout");if(_("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),_(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof on?s.clone():s;const o=function Xee(n,t){if(null==t)return n.shape.slice();if(Pt(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),i=1-t,a=Ee(vp(ue(Nu(o,0,1,"float32",r),i)),i);return L(s,a)}});function SM(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function cN(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+r-1);s[o]=t-e*Math.cos(i)}return Qn(s,"float32")}function dN(){return(dN=J(function*(n,t,e=1){const r=E(n,"predictions","inTopK"),s=E(t,"targets","inTopK");_(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),_(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Bs(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];_(e>0&&e<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${e}`);const i=yield r.data(),a=yield s.data(),[l,u]=[i.length/o,o],c=Lr("bool",l);for(let d=0;d<l;d++){const h=d*u,f=i.subarray(h,h+u),p=[];for(let g=0;g<f.length;g++)p.push({value:f[g],index:g});p.sort((g,m)=>m.value-g.value),c[d]=0;for(let g=0;g<e;g++)if(p[g].index===a[d]){c[d]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),ko(c,s.shape,"bool")})).apply(this,arguments)}const Yee=function Zee(n,t){return dN.apply(this,arguments)},hN=M({conv2DBackpropFilter_:function Qee(n,t,e,r,s,o="NHWC",i){let a=n;3===n.rank&&(a=V(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]])),_(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),_(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),_(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return _(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),_(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),as("conv2dDerFilter",s,i),$.runKernel($C,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:e})}});function h1(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return L(n,md(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function f1(n,t){let e=t;const r=pr(n.shape,t.shape);return r.length>0&&(e=$e(e,r)),V(e,n.shape)}function p1(n,t,e,r){if("linear"===t)return n;if("relu"===t)return Mi(n);if("elu"===t)return gp(n);if("relu6"===t)return qS(n);if("prelu"===t)return o1(n,e);if("leakyrelu"===t)return J0(n,r);if("sigmoid"===t)return ci(n);throw new Error(`Unknown fused activation ${t}.`)}const m1=(n,t)=>!(n>0)||"linear"===t,NM=M({fusedConv2d_:function ete({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===m1($.state.gradientDepth,l=l||"linear")){_("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=fl(n,t,e,r,s,o,i);return null!=a&&(I=ue(I,a)),p1(I,l,u,c)}const d=E(n,"x","conv2d","float32"),h=E(t,"filter","conv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=V(d,[1,d.shape[0],d.shape[1],d.shape[2]])),_(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),_(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),as("fused conv2d",r,i);const g="NHWC"===s?f.shape[3]:f.shape[1];_(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),_(Vr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const m=Ar(f.shape,h.shape,e,o,r,i);let y,v;if(null!=a&&(y=E(a,"bias","fused conv2d"),[y]=Wn(y,d),"NHWC"===s?mt(m.outShape,y.shape):(_(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),_(0===y.shape.length||y.shape[0]===m.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`))),null!=u){const I=u.shape;if(_(I.length<=1||3===I.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),1===I.length)_(1===I[0]||I[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${m.outChannels}).`);else if(3===I.length)try{mt(I,m.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${m.outShape}).`)}v=E(u,"prelu weights","fused conv2d")}const w=(I,k)=>{_("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[A,R,F,U]=k,q=h1(I,F,l);_(hl(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const Q=[OS(R.shape,q,A,e,r),hN(R,q,A.shape,e,r)];if(null!=U){const se=f1(U,q);Q.push(se)}return Q},x={x:f,filter:h,bias:y,preluActivationWeights:v},N={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?ma((k,A,R)=>{let F=$.runKernel(_0,x,N);return R([A,k,F]),p&&(F=V(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:w}})(f,h):ma((k,A,R,F)=>{let U=$.runKernel(_0,x,N);return F([A,k,U,R]),p&&(U=V(U,[U.shape[1],U.shape[2],U.shape[3]])),{value:U,gradFunc:w}})(f,h,y)}}),TM=M({depthwiseConv2dNativeBackpropFilter_:function tte(n,t,e,r,s,o=[1,1],i){let a=n;3===n.rank&&(a=V(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]])),$.runKernel(jC,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:e})}}),IM=M({depthwiseConv2dNativeBackpropInput_:function nte(n,t,e,r,s,o=[1,1],i){let a=t,l=!1;3===t.rank&&(l=!0,a=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=$.runKernel(GC,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:n});return l?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),ste=M({fusedDepthwiseConv2d_:function rte({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===m1($.state.gradientDepth,l)){let N=mp(n,t,e,r,s,o,i);return null!=a&&(N=ue(N,a)),p1(N,l,u,c)}const d=E(n,"x","depthwiseConv2d","float32"),h=E(t,"filter","depthwiseConv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=V(d,[1,d.shape[0],d.shape[1],d.shape[2]])),_(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),_(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),_(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==o&&(o=[1,1]),_(Vr(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),as("fused depthwiseConv2d",r,i);const g=Ar(f.shape,h.shape,e,o,r,i,!0);let m,y;null!=a&&(m=E(a,"bias","fused conv2d"),[m]=Wn(m,d),mt(g.outShape,m.shape)),null!=u&&(y=E(u,"prelu weights","fused depthwiseConv2d"));const v=(N,I)=>{_(hl(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[k,A,R,F]=I,U=h1(N,R,l),q=IM(A.shape,U,k,e,r,o,i),K=TM(A,U,k.shape,e,r,o,i);return null!=F?[q,K,f1(m,U)]:[q,K]},w={x:f,filter:h,bias:m,preluActivationWeights:y},x={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?ma((I,k,A)=>{let R=$.runKernel(E0,w,x);return A([k,I,R]),p&&(R=V(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(f,h):ma((I,k,A,R)=>{let F=$.runKernel(E0,w,x);return R([k,I,F,A]),p&&(F=V(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:v}})(f,h,m)}}),fN=M({fusedMatMul_:function ote({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(!1===m1($.state.gradientDepth,o)){let U=Ft(n,t,e,r);return null!=s&&(U=ue(U,s)),p1(U,o,i,a)}let l=E(n,"a","fused matMul"),u=E(t,"b","fused matMul");[l,u]=Wn(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=Z(p),y=Z(g);_(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=mt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,f]),x=V(l,e?[m,c,h]:[m,h,c]),N=V(u,r?[y,f,d]:[y,d,f]);let I,k;null!=s&&(I=E(s,"bias","fused matMul"),[I]=Wn(I,l),mt(w,I.shape)),null!=i&&(k=E(i,"prelu weights","fused matMul"));const A=(U,q)=>{const[K,Y,Q,se]=q,ie=h1(V(U,Q.shape),Q,o);let te,ae;return e||r?!e&&r?(te=Ft(ie,Y,!1,!1),ae=Ft(ie,K,!0,!1)):e&&!r?(te=Ft(Y,ie,!1,!0),ae=Ft(K,ie,!1,!1)):(te=Ft(Y,ie,!0,!0),ae=Ft(ie,K,!0,!0)):(te=Ft(ie,Y,!1,!0),ae=Ft(K,ie,!0,!1)),null!=s?[te,ae,f1(se,ie)]:[te,ae]},R={a:x,b:N,bias:I,preluActivationWeights:k},F={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?ma((q,K,Y)=>{const Q=$.runKernel(I0,R,F);return Y([q,K,Q]),{value:V(Q,w),gradFunc:A}})(x,N):ma((q,K,Y,Q)=>{const se=$.runKernel(I0,R,F);return Q([q,K,se,Y]),{value:V(se,w),gradFunc:A}})(x,N,I)}}),ate=M({hammingWindow_:function ite(n){return cN(n,.54,.46)}}),_M=M({hannWindow_:function lte(n){return cN(n,.5,.5)}}),EM=M({frame_:function ute(n,t,e,r=!1,s=0){let o=0;const i=[];for(;o+t<=n.size;)i.push(rt(n,o,t)),o+=e;if(r)for(;o<n.size;){const a=o+t-n.size,l=_n([rt(n,o,t-a),id([a],s)]);i.push(l),o+=e}return 0===i.length?Pi([],[0,t]):V(_n(i),[i.length,t])}}),dte=M({stft_:function cte(n,t,e,r,s=_M){null==r&&(r=SM(t));const o=EM(n,t,e),i=L(o,s(t));return d1(i,r)}}),fte=M({cropAndResize_:function hte(n,t,e,r,s="bilinear",o=0){const i=E(n,"image","cropAndResize"),a=E(t,"boxes","cropAndResize","float32"),l=E(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return _(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),_(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),_(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),_(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),_(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),_("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),$.runKernel(UC,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),mte=M({flipLeftRight_:function pte(n){const t=E(n,"image","flipLeftRight","float32");return _(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),$.runKernel(t2,{image:t},{})}}),yte=M({grayscaleToRGB_:function gte(n){const t=E(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];_(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),_(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,Fo(t,s)}}),vte=M({rgbToGrayscale_:function bte(n){const t=E(n,"image","RGBToGrayscale"),r=t.shape[t.rank-1];_(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),_(3===r,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=t.dtype,o=Ce(t,"float32"),i=Qn([.2989,.587,.114]);let a;switch(t.rank){case 2:a=dd("ij,j->i",o,i);break;case 3:a=dd("ijk,k->ij",o,i);break;case 4:a=dd("ijkl,l->ijk",o,i);break;case 5:a=dd("ijklm,m->ijkl",o,i);break;case 6:a=dd("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=zr(a,-1),Ce(a,s)}}),xte=M({rotateWithOffset_:function wte(n,t,e=0,r=.5){const s=E(n,"image","rotateWithOffset","float32");return _(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),$.runKernel($2,{image:s},{radians:t,fillValue:e,center:r})}});function gd(n,t,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=n.shape[0];return e=Math.min(e,i),_(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),_(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),_(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),_(1===t.rank,()=>"scores must be a 1D tensor"),_(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),_(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const Ste=M({nonMaxSuppression_:function Cte(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=E(n,"boxes","nonMaxSuppression","float32"),i=E(t,"scores","nonMaxSuppression","float32"),a=gd(o,i,e,r,s);return $.runKernel(d2,{boxes:o,scores:i},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function Nte(n,t,e){const r=function Tte(n,t,e){return function _te(n,t,e){let r=0,s=n.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=e(t,n[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(n,t,e||Ite)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function Ite(n,t){return n>t?1:n<t?-1:0}function pN(n,t,e,r,s){return yN(n,t,e,r,s,0)}function mN(n,t,e,r,s,o){return yN(n,t,e,r,s,0,!1,o,!0)}function gN(n,t,e,r,s,o){return yN(n,t,e,r,s,o,!0)}function yN(n,t,e,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let m=0;m<t.length;m++)t[m]>s&&u.push({score:t[m],boxIndex:m,suppressBeginIndex:0});u.sort(DM);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<e&&u.length>0;){const m=u.pop(),{score:y,boxIndex:v,suppressBeginIndex:w}=m;if(y<s)break;let x=!1;for(let N=d.length-1;N>=w;--N){const I=Ete(n,v,d[N]);if(I>=r){x=!0;break}if(m.score=m.score*Dte(r,c,I),m.score<=s)break}m.suppressBeginIndex=d.length,x||(m.score===y?(d.push(v),h.push(m.score)):m.score>s&&Nte(u,m,DM))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const g={selectedIndices:d};return i&&(g.selectedScores=h),l&&(g.validOutputs=f),g}function Ete(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-o)*(l-i),p=(d-u)*(h-c);if(f<=0||p<=0)return 0;const g=Math.max(o,u),m=Math.max(i,c),y=Math.min(a,d),v=Math.min(l,h),w=Math.max(y-g,0)*Math.max(v-m,0);return w/(f+p-w)}function Dte(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function DM(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function bN(){return(bN=J(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=E(n,"boxes","nonMaxSuppressionAsync"),i=E(t,"scores","nonMaxSuppressionAsync"),a=gd(o,i,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=pN(u,c,e,r,s);return o!==n&&o.dispose(),i!==t&&i.dispose(),Qn(d,"int32")})).apply(this,arguments)}const Ote=M({nonMaxSuppressionWithScore_:function Rte(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=gd(i,a,e,r,s,o),d=$.runKernel(f2,{boxes:i,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function vN(){return(vN=J(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=gd(i,a,e,r,s,o);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:f}=gN(c,d,e,r,s,o);return i!==n&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Qn(h,"int32"),selectedScores:Qn(f)}})).apply(this,arguments)}const Lte=M({nonMaxSuppressionPadded_:function Pte(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=gd(i,a,e,r,s,null),p=$.runKernel(h2,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:p[0],validOutputs:p[1]}}});function wN(){return(wN=J(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=gd(i,a,e,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([i.data(),a.data()]),{selectedIndices:p,validOutputs:g}=mN(h,f,u,c,d,o);return i!==n&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Qn(p,"int32"),validOutputs:Ke(g,"int32")}})).apply(this,arguments)}const kM=M({resizeBilinear_:function Bte(n,t,e=!1,r=!1){const s=E(n,"images","resizeBilinear");_(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),_(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),_(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,u=$.runKernel(p0,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return i?V(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),AM=M({resizeNearestNeighbor_:function zte(n,t,e=!1,r=!1){const s=E(n,"images","resizeNearestNeighbor");_(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),_(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),_("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),_(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,u=$.runKernel(f0,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return i?V(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Hte=M({threshold_:function Ute(n,t="binary",e=!1,r=.5){const s=E(n,"image","threshold"),l=s.shape[0]*s.shape[1];let c,d,h,f,u=L(Qn([r]),255);if(_(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),_(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),_("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),_("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[c,d,h]=Hs(s,[1,1,1],-1);const m=L(c,.2989),y=L(d,.587),v=L(h,.114);f=ue(ue(m,y),v)}else f=n;"otsu"===t&&(u=function Wte(n,t){let o,i,a,l,u,c,e=Qn([-1]),r=Qn([0]),s=Qn([0]);for(let d=0;d<n.size-1;d++){o=rt(n,0,d+1),i=rt(n,d+1),u=Ee($e(o),t),c=Ee($e(i),t);const h=$e(L(o,pd(0,o.size)));a=Ee(h,$e(o));const f=id(i.shape,o.size),p=ue(pd(0,i.size),f),g=L(i,p);l=Ee($e(g),$e(i));const m=De(a,l),y=De(a,l),v=L(u,c);s=L(L(v,m),y);const w=Ws(s,r);r=Xr(w,s,r),e=Xr(w,Qn([d]),e)}return e}(VF(Ce(KS(f),"int32"),ko([]),256),l));const p=e?Cu(f,u):Ws(f,u);return Ce(L(p,255),"int32")}}),Gte=M({transform_:function jte(n,t,e="nearest",r="constant",s=0,o){const i=E(n,"image","transform","float32"),a=E(t,"transforms","transform","float32");return _(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),_(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),_(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),$.runKernel(M2,{image:i,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),Kte=M({bandPart_:function qte(n,t,e){const r=E(n,"a","bandPart");_(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,l;"number"==typeof t?(_(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),_(t<=o,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`),a=E(t<0?o:t,"numLower","bandPart")):(_("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),a=Xr(xp(t,0),o,Su(t,o))),"number"==typeof e?(_(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),_(e<=i,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`),l=E(e<0?i:e,"numUpper","bandPart")):(_("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=Xr(xp(e,0),i,Su(e,i)));const u=V(pd(0,o,1,"int32"),[-1,1]),c=pd(0,i,1,"int32"),d=De(u,c),h=Fi(Cu(d,a),ml(d,In(l))),f=ar([o,i],r.dtype);return V(_s(Po(V(r,[-1,o,i])).map(p=>Xr(h,p,f))),s)}}),Jte=M({gramSchmidt_:function Xte(n){let t;if(Array.isArray(n)){t=!1,_(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)_(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else t=!0,n=Hs(n,n.shape[0],0).map(s=>Yn(s,[0]));_(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push($.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=L($e(L(e[i],o)),e[i]);o=De(o,a)}return Ee(o,bp(o,"euclidean"))}));return t?_s(e,0):e}});function RM(n,t=!1){return $.tidy(()=>{_(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=BS(e),o=pa(n);const i=Pi([[1]],[1,1]);let a=pa(i);const l=e>=r?r:e;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=$.tidy(()=>{const f=rt(o,[u,u],[e-u,1]),p=bp(f),g=rt(o,[u,u],[1,1]),m=Xr(Ws(g,0),Pi([[-1]]),Pi([[1]])),y=De(g,L(m,p)),v=Ee(f,y);a=1===v.shape[0]?pa(i):_n([i,rt(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const w=In(Ee(Ft(m,y),p)),x=rt(o,[u,0],[e-u,r]),N=L(w,a),I=$t(a);if(0===u)o=De(x,Ft(N,Ft(I,x)));else{const R=De(x,Ft(N,Ft(I,x)));o=_n([rt(o,[0,0],[u,r]),R],0)}const k=$t(N),A=rt(s,[0,u],[e,s.shape[1]-u]);if(0===u)s=De(A,Ft(Ft(A,a),k));else{const R=De(A,Ft(Ft(A,a),k));s=_n([rt(s,[0,0],[e,u]),R],1)}return[a,o,s]}),ut([c,d,h])}return!t&&e>r&&(s=rt(s,[0,0],[e,r]),o=rt(o,[0,0],[r,r])),[s,o]})}const Yte=M({qr_:function Zte(n,t=!1){if(_(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return RM(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),r=Po(V(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=RM(l,t);s.push(u),o.push(c)}),[V(_s(s,0),n.shape),V(_s(o,0),n.shape)]}}});var us=(()=>{return(n=us||(us={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",us;var n})();const wa=M({computeWeightedLoss_:function Qte(n,t,e=us.SUM_BY_NONZERO_WEIGHTS){const r=E(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=E(t,"weights","computeWeightedLoss"));const o=null==s?r:L(r,s);if(e===us.NONE)return o;if(e===us.SUM)return $e(o);if(e===us.MEAN){if(null==s)return Hn(o);{const i=r.size/s.size,a=Ee($e(o),$e(s));return i>1?Ee(a,Ke(i)):a}}if(e===us.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Ee($e(o),Ke(r.size));{const i=L(s,Is(r.shape)),a=Ce($e(fd(i,Ke(0))),"float32");return Ee($e(o),a)}}throw Error(`Unknown reduction: ${e}`)}}),tne=M({absoluteDifference_:function ene(n,t,e,r=us.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","absoluteDifference"),o=E(t,"predictions","absoluteDifference");let i=null;null!=e&&(i=E(e,"weights","absoluteDifference")),Bs(s.shape,o.shape,"Error in absoluteDifference: ");const a=fr(De(s,o));return wa(a,i,r)}}),rne=M({cosineDistance_:function nne(n,t,e,r,s=us.SUM_BY_NONZERO_WEIGHTS){const o=E(n,"labels","cosineDistance"),i=E(t,"predictions","cosineDistance");let a=null;null!=r&&(a=E(r,"weights","cosineDistance")),Bs(o.shape,i.shape,"Error in cosineDistance: ");const l=Ke(1),u=De(l,$e(L(o,i),e,!0));return wa(u,a,s)}}),one=M({hingeLoss_:function sne(n,t,e,r=us.SUM_BY_NONZERO_WEIGHTS){let s=E(n,"labels","hingeLoss");const o=E(t,"predictions","hingeLoss");let i=null;null!=e&&(i=E(e,"weights","hingeLoss")),Bs(s.shape,o.shape,"Error in hingeLoss: ");const a=Ke(1);s=De(L(Ke(2),s),a);const l=Mi(De(a,L(s,o)));return wa(l,i,r)}}),ane=M({huberLoss_:function ine(n,t,e,r=1,s=us.SUM_BY_NONZERO_WEIGHTS){const o=E(n,"labels","huberLoss"),i=E(t,"predictions","huberLoss");let a=null;null!=e&&(a=E(e,"weights","huberLoss")),Bs(o.shape,i.shape,"Error in huberLoss: ");const l=Ke(r),u=fr(De(i,o)),c=Su(u,l),d=De(u,c),h=ue(L(Ke(.5),cn(c)),L(l,d));return wa(h,a,s)}}),une=M({logLoss_:function lne(n,t,e,r=1e-7,s=us.SUM_BY_NONZERO_WEIGHTS){const o=E(n,"labels","logLoss"),i=E(t,"predictions","logLoss");let a=null;null!=e&&(a=E(e,"weights","logLoss")),Bs(o.shape,i.shape,"Error in logLoss: ");const l=Ke(1),u=Ke(r),c=In(L(o,uo(ue(i,u)))),d=L(De(l,o),uo(ue(De(l,i),u))),h=De(c,d);return wa(h,a,s)}}),dne=M({meanSquaredError_:function cne(n,t,e,r=us.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","meanSquaredError"),o=E(t,"predictions","meanSquaredError");let i=null;null!=e&&(i=E(e,"weights","meanSquaredError")),Bs(s.shape,o.shape,"Error in meanSquaredError: ");const a=rN(s,o);return wa(a,i,r)}}),pne=M({sigmoidCrossEntropy_:function fne(n,t,e,r=0,s=us.SUM_BY_NONZERO_WEIGHTS){let o=E(n,"multiClassLabels","sigmoidCrossEntropy");const i=E(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","sigmoidCrossEntropy")),Bs(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Ke(r),c=Ke(1),d=Ke(.5);o=ue(L(o,De(c,u)),L(d,u))}const l=function hne(n,t){const e=E(n,"labels","sigmoidCrossEntropyWithLogits"),r=E(t,"logits","sigmoidCrossEntropyWithLogits");Bs(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Mi(r),o=L(r,e),i=Z0(ls(In(fr(r))));return ue(De(s,o),i)}(o,i);return wa(l,a,s)}}),yne=M({softmaxCrossEntropy_:function gne(n,t,e,r=0,s=us.SUM_BY_NONZERO_WEIGHTS){let o=E(n,"onehotLabels","softmaxCrossEntropy");const i=E(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","softmaxCrossEntropy")),Bs(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Ke(r),c=Ke(1),d=Ke(o.shape[1]);o=ue(L(o,De(c,u)),Ee(u,d))}const l=function mne(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return ma((s,o,i)=>{const l=Y0(o,[e],!0),u=De(Ce(o,"float32"),l);i([s,u]);const c=In(L(u,s));return{value:$e(c,[e]),gradFunc:(f,p)=>{const[g,m]=p,y=Jn(f.shape,[e]);return[L(V(f,y),De(Ce(g,"float32"),ls(m))),L(V(f,y),De(ls(m),Ce(g,"float32")))]}}})(n,t)}(o,i);return wa(l,a,s)}}),Fne={fft:c1,ifft:Np,rfft:d1,irfft:nN},Mne={hammingWindow:ate,hannWindow:_M,frame:EM,stft:dte},Ur={flipLeftRight:mte,grayscaleToRGB:yte,resizeNearestNeighbor:AM,resizeBilinear:kM,rgbToGrayscale:vte,rotateWithOffset:xte,cropAndResize:fte,nonMaxSuppression:Ste,nonMaxSuppressionAsync:function kte(n,t,e){return bN.apply(this,arguments)},nonMaxSuppressionWithScore:Ote,nonMaxSuppressionWithScoreAsync:function Fte(n,t,e){return vN.apply(this,arguments)},nonMaxSuppressionPadded:Lte,nonMaxSuppressionPaddedAsync:function $te(n,t,e){return wN.apply(this,arguments)},threshold:Hte,transform:Gte},OM={bandPart:Kte,gramSchmidt:Jte,qr:Yte},Pne={absoluteDifference:tne,computeWeightedLoss:wa,cosineDistance:rne,hingeLoss:one,huberLoss:ane,logLoss:une,meanSquaredError:dne,sigmoidCrossEntropy:pne,softmaxCrossEntropy:yne},Lne={sparseFillEmptyRows:M({sparseFillEmptyRows_:function bne(n,t,e,r){const s=E(n,"indices","sparseFillEmptyRows","int32"),o=E(t,"values","sparseFillEmptyRows"),i=E(e,"denseShape","sparseFillEmptyRows","int32"),a=E(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u=$.runKernel(N2,{indices:s,values:o,denseShape:i,defaultValue:a});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),sparseReshape:M({sparseReshape_:function wne(n,t,e){const r=E(n,"inputIndices","sparseReshape","int32"),s=E(t,"inputShape","sparseReshape","int32"),o=E(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a=$.runKernel(T2,{inputIndices:r,inputShape:s,newShape:o});return{outputIndices:a[0],outputShape:a[1]}}}),sparseSegmentMean:M({sparseSegmentMean_:function Cne(n,t,e){const r=E(n,"data","sparseSegmentMean"),s=E(t,"indices","sparseSegmentMean","int32"),o=E(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return $.runKernel(I2,{data:r,indices:s,segmentIds:o})}}),sparseSegmentSum:M({sparseSegmentSum_:function Nne(n,t,e){const r=E(n,"data","sparseSegmentSum"),s=E(t,"indices","sparseSegmentSum","int32"),o=E(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return $.runKernel(_2,{data:r,indices:s,segmentIds:o})}})},$ne={stringNGrams:M({stringNGrams_:function Ine(n,t,e,r,s,o,i,a){const l=E(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=E(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const h=$.runKernel(A2,{data:l,dataSplits:u},{separator:e,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),stringSplit:M({stringSplit_:function Ene(n,t,e=!0){const r=E(n,"input","stringSplit","string"),s=E(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=$.runKernel(R2,{input:r,delimiter:s},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),stringToHashBucketFast:M({stringToHashBucketFast_:function kne(n,t){const e=E(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return $.runKernel(O2,{input:e},r)}}),staticRegexReplace:M({staticRegexReplace_:function Rne(n,t,e,r=!0){const s=E(n,"input","staticRegexReplace","string");return $.runKernel(C0,{x:s},{pattern:t,rewrite:e,replaceGlobal:r})}})},yd=class Vne{static sgd(t){return new pS(t)}static momentum(t,e,r=!1){return new sF(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,o=!1){return new oF(t,e,r,s,o)}static adam(t=.001,e=.9,r=.999,s=null){return new nF(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new eF(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,o=0){return new rF(t,e,r,s,o)}static adagrad(t,e=.1){return new tF(t,e)}},Bne=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function FM(){return new Promise(n=>Bne(()=>n()))}function xN(n,t){const e=n[0].length;n.forEach((s,o)=>{_(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),_(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,o)=>{for(let i=0;i<e;i++)_(i===t||s[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Li(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var Lo=(()=>{return(n=Lo||(Lo={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",Lo;var n})();function MM(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const o=e[s],i=r[r.length-e.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${o} but shape[${s+n}] = ${a}`)}else r[i]=o}return r}function PM(n){const t={FIRST_DIM_SIZE:Lo.FIRST_DIM_SIZE,VALUE_ROWIDS:Lo.VALUE_ROWIDS,ROW_LENGTHS:Lo.ROW_LENGTHS,ROW_SPLITS:Lo.ROW_SPLITS,ROW_LIMITS:Lo.ROW_LIMITS,ROW_STARTS:Lo.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function LM(n){return 0===n.length?0:n[0]===Lo.FIRST_DIM_SIZE?n.length-1:n.length}function $M(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const o=n[s],i=t[s+1];if(o>=0&&i>=0&&1!==o&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${o} but ragged tensor input.flatValues.shape[${s-n.length}] = ${i}`)}}const CN=30;function g1(n){return n<=CN?n:_C(n,Math.floor(Math.sqrt(n)))}function SN(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function Tp(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=t.length;for(let i=0;i<o;++i)s=s.concat([n[i+1]/t[i],t[i]]);s=s.concat(n.slice(o+1))}return s}function Ip(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<n;++i)i>=2*t+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function _p(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let o=1;o<n.length;++o)s.push(o<=t.length?r?t[o-1]*n[o]:n[o]/t[o-1]:n[o]);return s}function NN(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function TN(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function IN(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===Z(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=n.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<e;++d)u*=a[d],l.push(a[d]);const c=[...Ge(n.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}const y1=1.7580993408473768,b1=1.0507009873554805,_N=.3275911,EN=.254829592,DN=-.284496736,kN=1.421413741,AN=-1.453152027,RN=1.061405429;function xa(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function VM(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function BM(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function zM(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function ON(n,t){return{real:n[2*t],imag:n[2*t+1]}}function UM(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function WM(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function HM(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const zne=/->/g;function MN(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(zne,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");_(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const o=r.split(","),i=o.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const f=s[h];if(!o.some(p=>-1!==p.indexOf(f)))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);-1===a.indexOf(f)&&a.push(f)}for(let h=0;h<r.length;++h){const f=r[h];-1===a.indexOf(f)&&","!==f&&a.push(f)}const l=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let f=0;f<o[h].length;++f)l[h].push(a.indexOf(o[h][f]))}const u=a.length,d=[];for(let h=s.length;h<u;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function PN(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function LN(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const o=e[s].shape;for(let i=0;i<t[s].length;++i)void 0===r[t[s][i]]?r[t[s][i]]=o[i]:_(r[t[s][i]]===o[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function $N(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<e.length;++i){const l=Une(t,e[i]);for(const u of l)-1===o.indexOf(u)&&(r[i].push(u),o.push(u))}return{path:e,steps:r}}function VN(n){return n.every((t,e)=>t===e)}function Une(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function BN(n,t,e=0){let r=[];if("number"==typeof t)_(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{_(t.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(-1!==o){const i=t.reduce((a,l)=>l>0?a+l:a);t[o]=n.shape[e]-i}_(n.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function qM(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function KM(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function XM(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function JM(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function ZM(n,t){return`size ${n} must be non-negative, not ${t}`}function YM(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function QM(n,t){return`Input to reshape is a SparseTensor with ${Z(n)}\n  dense values, but the requested shape requires a multiple of ${Z(t)}. inputShape=${n} outputShape= ${t}`}function eP(n,t){return`Input to reshape is a tensor with ${Z(n)} dense values, but the requested shape has ${Z(t)}. inputShape=${n} outputShape=${t}`}function zN(){return"segment ids must be >= 0"}function tP(){return"segment ids are not increasing"}function nP(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function rP(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function sP(n,t){let r,e=!1;for(n<=CN?(r=n,e=!0):r=_C(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=_C(n,r+1);return r}function oP(n,t,e){const r=[],s=n.length;for(let o=0;o<s;o++)r.push(o!==t?n[o]:e);return r}function UN(n,t,e,r){const s=t.shape.length,o=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=n.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<e;d++)a.push(n.shape[d]),u*=n.shape[d];for(let d=r;d<s;d++)a.push(t.shape[d]);for(let d=e+1;d<o;d++)a.push(n.shape[d]),c*=n.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function Ca(n){try{return n.map(t=>sl(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function iP(n){return n.map(t=>rl(t))}!function hJ(){for(const n of dJ)he(n)}();const aP={kernelName:Cy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,md(Ce(e,"float32"),-1))}}},Wne={kernelName:df,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=cn(Ce(e,"float32")),s=$r(De(Ke(1),r));return In(Ee(n,s))}}}},Hne={kernelName:hf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=$r(De(cn(Ce(e,"float32")),1));return Ee(n,r)}}}},jne={kernelName:Zc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=mt(e.shape,r.shape);return{a:()=>{let a=n;const l=pr(e.shape,s);return l.length>0&&(a=$e(a,l)),V(a,e.shape)},b:()=>{let a=n;const l=pr(r.shape,s);return l.length>0&&(a=$e(a,l)),V(a,r.shape)}}}},Gne={kernelName:Sy,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}},qne={kernelName:Ny,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(e)}}},Kne={kernelName:Ty,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(e)}}},Xne={kernelName:ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,$r(De(Ke(1),cn(Ce(e,"float32")))))}}},Jne={kernelName:pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=$r(ue(Ke(1),cn(Ce(e,"float32"))));return Ee(n,r)}}}},Zne={kernelName:yf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=mt(e.shape,r.shape);return{a:()=>{const a=ue(cn(e),cn(r));let l=L(n,Ee(r,a));const u=pr(e.shape,s);return u.length>0&&(l=$e(l,u)),V(l,e.shape)},b:()=>{const a=ue(cn(e),cn(r));let l=In(L(n,Ee(e,a)));const u=pr(r.shape,s);return u.length>0&&(l=$e(l,u)),V(l,r.shape)}}}},Yne={kernelName:mf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,ue(cn(Ce(e,"float32")),1))}}},Qne={kernelName:gf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,De(Ke(1),cn(Ce(e,"float32"))))}}},tre=M({avgPool3dGrad_:function ere(n,t,e,r,s,o){const i=E(n,"dy","avgPool3dGrad"),a=E(t,"input","avgPool3dGrad");let l=i,u=a,c=!1;4===a.rank&&(c=!0,l=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=V(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),_(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),_(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),as("avgPool3dGrad",s,o);const f=$.runKernel(FC,{dy:l,input:u},{filterSize:e,strides:r,pad:s,dimRoundingMode:o});return c?V(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),nre={kernelName:_y,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:a}=e;return{x:()=>tre(n,r,s,o,i,a)}}},sre=M({avgPoolGrad_:function rre(n,t,e,r,s){const o=E(n,"dy","avgPoolGrad"),i=E(t,"input","avgPoolGrad");_(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;3===i.rank&&(u=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),_(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),_(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=$.runKernel(OC,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return u?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),ore={kernelName:Iy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:o,pad:i}=e;return{x:()=>sre(n,r,s,o,i)}}},ire={kernelName:Ey,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,s]=t,{transposeA:o,transposeB:i}=e;return o||i?!o&&i?{a:()=>Ft(n,s,!1,!1),b:()=>Ft(n,r,!0,!1)}:o&&!i?{a:()=>Ft(s,n,!1,!0),b:()=>Ft(r,n,!1,!1)}:{a:()=>Ft(s,n,!0,!0),b:()=>Ft(n,r,!0,!0)}:{a:()=>Ft(n,s,!1,!0),b:()=>Ft(r,n,!0,!1)}}},are={kernelName:Dy,gradFunc:(n,t,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>s1(n,r,s)}}},lre={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const s=e.inputShape,o=e.shape,i=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>$e(n,a,!0)}}},ure={kernelName:bf,gradFunc:n=>({x:()=>n.clone()})},cre={kernelName:vf,gradFunc:n=>({x:()=>Lt(n)})},dre={kernelName:wf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:s,clipValueMax:o}=e;return{x:()=>Xr(Fi(ml(r,s),Cu(r,o)),n,Lt(n))}}},hre={kernelName:Ay,inputsToSave:["x"],gradFunc:aP.gradFunc},fre={kernelName:Ry,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(l=>l.shape),{axis:s}=e,o=Rt(s,t[0].shape)[0],i=r.map(l=>l[o]);return Hs(n,i,o).map(l=>()=>l)}},pre={kernelName:Oy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{dilations:o,strides:i,pad:a,dataFormat:l}=e;return _(hl(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>OS(r.shape,n,s,i,a,l),filter:()=>hN(r,n,s.shape,i,a,l)}}},mre={kernelName:Fy,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>fl(n,s,o,i,a,1,l),filter:()=>hN(n,r,s.shape,o,i,a,l)}}},yre=M({conv3DBackpropFilter_:function gre(n,t,e,r,s){let o=n;4===n.rank&&(o=V(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let i=t;return 4===i.rank&&(i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),_(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),_(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),_(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),_(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),_(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`),$.runKernel(VC,{x:o,dy:i},{strides:r,pad:s,filterShape:e})}}),bre={kernelName:My,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:o}=e;_(hl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,a]=t;return{x:()=>GF(i.shape,n,a,s,o),filter:()=>yre(i,n,a.shape,s,o)}}},vre={kernelName:xf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(In(QS(Ce(e,"float32"))),n)}}},wre={kernelName:Cf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(eN(Ce(e,"float32")),n)}}},xre={kernelName:Py,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s,exclusive:o,reverse:i}=e;return{x:()=>{const a=Pn([s],r.rank);let l=PS(n,s,o,!i);return null!=a&&(l=$t(l,a)),l}}}},Cre={kernelName:Ly,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:i}=e,a=r??[1,1];_(hl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=t;return _(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),_(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),_(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),_(Vr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),as("depthwiseConv2d",o,i),{x:()=>IM(l.shape,n,u,s,o,a,i),filter:()=>TM(l,n,u.shape,s,o,a,i)}}},Sre={kernelName:$y,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,o={x:r,filter:s,dy:n},i={x:r,filter:s,dy:n};return{x:()=>$.runKernel(KC,o,e),filter:()=>$.runKernel(XC,i,e)}}},Nre={kernelName:Nf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>$.runKernel(YC,r)}}},Tre={kernelName:Tf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=L(ls(In(cn(e))),2/Math.sqrt(Math.PI));return{x:()=>L(n,r)}}},Ire={kernelName:If,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,e)}}},_re={kernelName:By,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>V(n,e.shape)}}},Ere={kernelName:_f,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,ls(e))}}},Dre={kernelName:Ef,gradFunc:n=>({x:()=>Lt(n)})},kre={kernelName:Df,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=mt(e.shape,r.shape);return{a:()=>{const a=Ee(n,Ce(r,"float32")),l=pr(e.shape,s);return l.length>0?V($e(a,l),e.shape):a},b:()=>{let a=L(n,Ce(e,"float32"));const l=pr(r.shape,s);l.length>0&&(a=V($e(a,l),r.shape));const u=cn(r);return In(Ee(a,Ce(u,"float32")))}}}},Are={kernelName:zy,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[s,o,i,a]=t,l=a??Ke(1),u=pr(o.shape,s.shape),c=[];if(1===o.rank){for(let x=0;x<s.shape.length-1;++x)c.push(s.shape[x]);c.push(1)}const d=De(s,o),h=L(n,l),f=XS(ue(i,Ke(r))),p=L(L(L(f,f),f),Ke(-.5));return{x:()=>V(L(L(n,1===o.rank?Fo(V(f,[1,1,1,o.shape[0]]),c):f),l),s.shape),mean:()=>{let x=L(L(f,Ke(-1)),h);return 1===o.rank&&(x=$e(x,u)),V(x,o.shape)},variance:()=>{let x=L(L(p,d),h);return 1===o.rank&&(x=$e(x,u)),V(x,o.shape)},scale:()=>{const x=L(d,f);let N=L(n,x);return 1===o.rank&&(N=$e(N,u)),V(N,o.shape)},offset:()=>{let x=n;return 1===o.rank&&(x=$e(x,u)),V(x,o.shape)}}}},Rre={kernelName:Uy,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,s]=t,{axis:o,batchDims:i}=e,a=Rt(o,r.shape)[0],l=(u,c,d)=>()=>{const h=u.shape,f=c.size,p=h.slice(0,a),g=p.length,m=h.slice(o,h.length).slice(1),y=m.length,v=lP(0,g),w=lP(g+1,g+1+y),x=uP([p,[f],m]),N=V(d,x),I=V(c,[f]),k=uP([[g],v,w]),A=$t(N,k);let R=iN(A,I,u.shape[a]);const F=pl(k);return R=$t(R,F),R};if(1===i){const c=r.split(r.shape[0],0);return{x:()=>_s(c.map((f,p)=>l(f,s.slice(p,1),n.slice(p,1))())).reshape(r.shape),indices:()=>s}}return{x:l(r,s,n),indices:()=>s}}};function lP(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function uP(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const Ore={kernelName:kf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>Lt(e),b:()=>Lt(r)}}},Fre={kernelName:Af,gradFunc:n=>({x:()=>Ce(n,"float32")})},Mre={kernelName:Rf,gradFunc:n=>({x:()=>Lt(n)})},Pre={kernelName:Of,gradFunc:n=>({x:()=>Lt(n)})},Lre={kernelName:Ff,gradFunc:n=>({x:()=>Lt(n)})},$re={kernelName:Hy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:s}=e,o=Ws(r,0);return{x:()=>Xr(o,n,L(n,s))}}},Vre={kernelName:Pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,ue(e,1))}}},Bre={kernelName:Mf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,Ce(e,"float32"))}}},zre={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;return{logits:()=>{const i=ls(r);return De(n,L($e(n,s,!0),i))}}}},Wre=M({localResponseNormalizationBackprop_:function Ure(n,t,e,r=5,s=1,o=1,i=.5){return $.runKernel(i2,{x:n,y:t,dy:e},{depthRadius:r,bias:s,alpha:o,beta:i})}}),Hre={kernelName:Jy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{depthRadius:o,bias:i,alpha:a,beta:l}=e;return{x:()=>Wre(r,s,n,o,i,a,l)}}};function cP(n,t,e,r){return t.rank<e.rank&&(t=V(t,Jn(t.shape,r))),n.rank<e.rank&&(n=V(n,Jn(n.shape,r))),{x:()=>L(n,Ce(di(e,t),n.dtype))}}const dP={kernelName:Zy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:s}=r,o=t[0],l=cP(n,t[1],o,Rt(s,o.shape));return{x:()=>l.x()}}},jre={kernelName:Lf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>L(n,Ce(ml(e,r),"float32")),b:()=>L(n,Ce(xp(e,r),"float32"))}}},qre=M({maxPool3dGrad_:function Gre(n,t,e,r,s,o,i){const a=E(n,"dy","maxPool3dGrad"),l=E(t,"input","maxPool3dGrad"),u=E(e,"output","maxPool3dGrad");let c=a,d=l,h=u,f=!1;4===l.rank&&(f=!0,c=V(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=V(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=V(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),_(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),_(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),_(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),as("maxPool3dGrad",o,i);const m=$.runKernel(l2,{dy:c,input:d,output:h},{filterSize:r,strides:s,pad:o,dimRoundingMode:i});return f?V(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Kre={kernelName:Qy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>qre(n,r,s,o,i,a,l)}}},Jre=M({maxPoolGrad_:function Xre(n,t,e,r,s,o,i){const a=E(n,"dy","maxPoolGrad"),l=E(t,"input","maxPoolGrad"),u=E(e,"output","maxPoolGrad");return _(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),_(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),_(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),as("maxPoolGrad",o,i),$.runKernel(a2,{dy:a,input:l,output:u},{filterSize:r,strides:s,pad:o,dimRoundingMode:i})}}),hP={kernelName:u0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>rt(n,o,r.shape)}}};const fP={kernelName:v0,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>G0(n,r,s)}}},pP={kernelName:w0,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>_n(n,r)}}},Gse=[aP,Wne,Hne,jne,Gne,qne,Kne,Xne,Jne,Zne,Yne,Qne,nre,ore,ire,are,lre,ure,cre,dre,hre,fre,mre,pre,bre,vre,wre,xre,Cre,Sre,{kernelName:Sf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=mt(e.shape,r.shape);return{a:()=>{const a=Ee(n,Ce(r,"float32")),l=pr(e.shape,s);return l.length>0?V($e(a,l),e.shape):a},b:()=>{let a=L(n,Ce(e,"float32"));const l=pr(r.shape,s);l.length>0&&(a=V($e(a,l),r.shape));const u=cn(r);return In(Ee(a,Ce(u,"float32")))}}}},Nre,Tre,Ire,_re,Ere,kre,Dre,Are,Rre,Ore,Fre,Mre,Pre,Lre,$re,Vre,Bre,zre,Hre,dP,dP,jre,Kre,{kernelName:Yy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:o,strides:i,pad:a}=e;return{x:()=>Jre(n,r,s,o,i,a)}}},{kernelName:e0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e,o=Rt(s,r.shape),l=Z(Rr(r.shape,o)[1]);return{x:()=>{const c=r.shape.slice();o.forEach(f=>{c[f]=1});const d=V(n,c);return Ee(L(d,Is(r.shape,"float32")),l)}}}},{kernelName:t0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:s}=r,[o,i]=t,l=cP(n,i,o,Rt(s,o.shape));return{x:()=>l.x()}}},{kernelName:$f,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>L(n,Ce(Cu(e,r),"float32")),b:()=>L(n,Ce(Ws(e,r),"float32"))}}},{kernelName:n0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>rt(n,o,r.shape)}}},{kernelName:Vf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=mt(e.shape,r.shape);return{a:()=>{const a=pr(e.shape,s);return a.length>0?V($e(n,a),e.shape):n},b:()=>{const a=L(n,In(vp(Ee(e,r)))),l=pr(r.shape,s);return l.length>0?V($e(a,l),r.shape):a}}}},{kernelName:Bf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=mt(e.shape,r.shape);return{a:()=>{const a=L(n,Ce(r,"float32")),l=pr(e.shape,s);return l.length>0?V($e(a,l),e.shape):a},b:()=>{const a=L(n,Ce(e,"float32")),l=pr(r.shape,s);return l.length>0?V($e(a,l),r.shape):a}}}},{kernelName:r0,gradFunc:n=>({x:()=>In(n)})},{kernelName:a0,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>ar(e.shape,"float32")}}},{kernelName:o0,gradFunc:n=>({x:()=>Lt(n)})},{kernelName:l0,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return Po(n,r).map(o=>()=>o)}},hP,hP,{kernelName:zf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,s]=t,o=e,i=r,a=mt(o.shape,i.shape);return{a:()=>{const c=Ce(i,"float32");let d=L(n,L(c,ga(o,De(c,Ke(1)))));const h=pr(o.shape,a);return h.length>0&&(d=$e(d,h)),V(d,o.shape)},b:()=>{const c=Ws(o,0),d=Xr(c,uo(o),Lt(o));let h=L(n,L(s,d));const f=pr(i.shape,a);return f.length>0&&(h=$e(h,f)),V(h,i.shape)}}}},{kernelName:c0,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,s=Ws(e,0);return{x:()=>Xr(s,n,L(n,r)),alpha:()=>{let o=Xr(s,Lt(n),L(n,e));const i=pr(r.shape,n.shape);return i.length>0&&(o=$e(o,i)),V(o,r.shape)}}}},{kernelName:d0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;let o=[];return o=null==s?r.shape.map((i,a)=>a):"number"==typeof s?[s]:s,{x:()=>function dse(n,t,e){const r=n.shape.length,s=r-e.length,o=Pn(e,r);let i=n;null!=o&&(i=$t(n,o));const a=i.shape.slice(),u=a.splice(r-e.length,e.length).reduce((h,f)=>h*f,1);a.push(u);let d=function cse(n,t,e){const r=n.shape.slice();r[e]=1;const s=V(t,r),o=K0(n,e,!0,!1),i=K0(n,e,!0,!0),a=L(o,i);return L(s,a)}(i.reshape(a),t,s);if(d=d.reshape(i.shape),null!=o){const h=pl(o);d=$t(d,h)}return d}(r,n,o)}}},{kernelName:Uf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,In(cn(e)))}}},{kernelName:Hf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=L(Cu(e,6),md(e));return{x:()=>L(n,Ce(r,"float32"))}}},{kernelName:Wf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,Ce(md(e),"float32"))}}},{kernelName:h0,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>V(n,e.shape)}}},{kernelName:p0,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>$.runKernel(w2,s,e)}}},{kernelName:f0,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>$.runKernel(v2,s,e)}}},{kernelName:m0,gradFunc:(n,t,e)=>{const{dims:r}=e,s=Rt(r,n.shape);return{x:()=>Mo(n,s)}}},{kernelName:jf,gradFunc:n=>({x:()=>Lt(n)})},{kernelName:Gf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>In(Ee(n,L(ga(e,1.5),2)))}}},{kernelName:g0,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>Ce(Lt(e),"float32"),t:()=>L(n,Ce(e,n.dtype)),e:()=>L(n,Ce(Q0(e),n.dtype))}}},{kernelName:qf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Ws(e,Ke(0)),s=Ke(y1),o=Ke(b1),i=L(n,o),a=L(L(n,s),ls(Ce(e,"float32")));return Xr(r,i,a)}}}},{kernelName:Zf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,L(e,De(Ke(1),e)))}}},{kernelName:Jf,gradFunc:n=>({x:()=>Lt(n)})},{kernelName:Kf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(q0(Ce(e,"float32")),n)}}},{kernelName:Xf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(MS(Ce(e,"float32")),n)}}},{kernelName:y0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:s,size:o}=e,i=r.shape,[a,l]=W0(r,s,o),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>gl(n,u)}}},{kernelName:x0,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:s}=e,i=L(n,r);return{logits:()=>De(i,L($e(i,[s],!0),r))}}},{kernelName:Yf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,ci(e))}}},fP,fP,pP,pP,{kernelName:Qf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,L($r(Ce(e,"float32")),2))}}},{kernelName:ep,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ke(2);return{a:()=>L(n,L(s,De(e,r))),b:()=>L(n,L(s,De(r,e)))}}},{kernelName:D2,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,L(Ce(e,"float32"),2))}}},{kernelName:op,gradFunc:n=>({x:()=>Lt(n)})},{kernelName:tp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=mt(e.shape,r.shape);return{a:()=>{let a=n;const l=pr(e.shape,s);return l.length>0&&(a=$e(a,l)),V(a,e.shape)},b:()=>{let a=n;const l=pr(r.shape,s);return l.length>0&&(a=$e(a,l)),V(In(a),r.shape)}}}},{kernelName:b0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,s=r.shape.slice(),{axis:o}=e;Rt(o,r.shape).forEach(u=>{s[u]=1});const a=V(n,s),l=L(a,Is(r.shape,"float32"));return{x:()=>l}}},{kernelName:np,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ee(n,cn(q0(e)))}}},{kernelName:rp,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(De(Ke(1),cn(e)),n)}}},{kernelName:sp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:s}=e;return{x:()=>{let i=Lt(r);if(1===r.rank)for(let a=0;a<s[0];++a)i=ue(i,rt(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)i=ue(i,rt(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=ue(i,rt(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=ue(i,rt(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},{kernelName:Yc,gradFunc:(n,t,e)=>{const r=e,{perm:s}=r,o=pl(s);return{x:()=>$t(n,o)}}},{kernelName:S0,gradFunc:(n,t,e)=>{const r=e,{axis:s}=r;return{value:()=>_s(n,s)}}},{kernelName:N0,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function Hse(n,t){const e=ya(t,Lt(t)),r=wp(n,e);let s=ml(t,Ke(0,"int32"));const o=r.rank-s.rank;for(let a=0;a<o;++a)s=zr(s,a+1);s=Fi(s,Is(r.shape,"bool"));const i=Lt(r);return Xr(s,r,i)}(n,e)}}},{kernelName:T0,gradFunc:n=>({x:()=>Lt(n)})}];for(const n of Gse)jK(n);ne().prototype.abs=function(){return this.throwIfDisposed(),fr(this)},ne().prototype.acos=function(){return this.throwIfDisposed(),_F(this)},ne().prototype.acosh=function(){return this.throwIfDisposed(),EF(this)},ne().prototype.add=function(n){return this.throwIfDisposed(),ue(this,n)},ne().prototype.all=function(n,t){return this.throwIfDisposed(),DS(this,n,t)},ne().prototype.any=function(n,t){return this.throwIfDisposed(),H0(this,n,t)},ne().prototype.argMax=function(n){return this.throwIfDisposed(),ld(this,n)},ne().prototype.argMin=function(n){return this.throwIfDisposed(),DF(this,n)},ne().prototype.asScalar=function(){return this.throwIfDisposed(),_(1===this.size,()=>"The array must have only 1 element."),V(this,[])},ne().prototype.asType=function(n){return this.throwIfDisposed(),Ce(this,n)},ne().prototype.as1D=function(){return this.throwIfDisposed(),V(this,[this.size])},ne().prototype.as2D=function(n,t){return this.throwIfDisposed(),V(this,[n,t])},ne().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),V(this,[n,t,e])},ne().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),V(this,[n,t,e,r])},ne().prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),V(this,[n,t,e,r,s])},ne().prototype.asin=function(){return this.throwIfDisposed(),kF(this)},ne().prototype.asinh=function(){return this.throwIfDisposed(),AF(this)},ne().prototype.atan=function(){return this.throwIfDisposed(),RF(this)},ne().prototype.atan2=function(n){return this.throwIfDisposed(),OF(this,n)},ne().prototype.atanh=function(){return this.throwIfDisposed(),FF(this)},ne().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),j0(this,n,t,e,r)},ne().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),G0(this,n,t)},ne().prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),pp(this,n,t,e,r,s)},ne().prototype.broadcastTo=function(n){return this.throwIfDisposed(),cd(this,n)},ne().prototype.cast=function(n){return this.throwIfDisposed(),Ce(this,n)},ne().prototype.ceil=function(){return this.throwIfDisposed(),BF(this)},ne().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Ts(this,n,t)},ne().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof on&&(n=[n]),_n([this,...n],t)},ne().prototype.conv1d=function(n,t,e,r,s,o){return this.throwIfDisposed(),RS(this,n,t,e,r,s,o)},ne().prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),FS(this,n,t,e,r,s)},ne().prototype.conv2d=function(n,t,e,r,s,o){return this.throwIfDisposed(),fl(this,n,t,e,r,s,o)},ne().prototype.cos=function(){return this.throwIfDisposed(),q0(this)},ne().prototype.cosh=function(){return this.throwIfDisposed(),MS(this)},ne().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),K0(this,n,t,e)},ne().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),PS(this,n,t,e)},ne().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),KF(this,n,t)},ne().prototype.depthwiseConv2d=function(n,t,e,r,s,o){return this.throwIfDisposed(),mp(this,n,t,e,r,s,o)},ne().prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),XF(this,n,t,e,r,s)},ne().prototype.divNoNan=function(n){return this.throwIfDisposed(),JF(this,n)},ne().prototype.div=function(n){return this.throwIfDisposed(),Ee(this,n)},ne().prototype.dot=function(n){return this.throwIfDisposed(),ZF(this,n)},ne().prototype.elu=function(){return this.throwIfDisposed(),gp(this)},ne().prototype.equal=function(n){return this.throwIfDisposed(),di(this,n)},ne().prototype.erf=function(){return this.throwIfDisposed(),$S(this)},ne().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),eM(this,n,t)},ne().prototype.exp=function(){return this.throwIfDisposed(),ls(this)},ne().prototype.expandDims=function(n){return this.throwIfDisposed(),zr(this,n)},ne().prototype.expm1=function(){return this.throwIfDisposed(),tM(this)},ne().prototype.fft=function(){return this.throwIfDisposed(),c1(this)},ne().prototype.flatten=function(){return this.throwIfDisposed(),V(this,[this.size])},ne().prototype.floor=function(){return this.throwIfDisposed(),vp(this)},ne().prototype.floorDiv=function(n){return this.throwIfDisposed(),hS(this,n)},ne().prototype.gather=function(n,t,e){return this.throwIfDisposed(),wp(this,n,t,e)},ne().prototype.greaterEqual=function(n){return this.throwIfDisposed(),ml(this,n)},ne().prototype.greater=function(n){return this.throwIfDisposed(),Ws(this,n)},ne().prototype.ifft=function(){return this.throwIfDisposed(),Np(this)},ne().prototype.irfft=function(){return this.throwIfDisposed(),nN(this)},ne().prototype.isFinite=function(){return this.throwIfDisposed(),nM(this)},ne().prototype.isInf=function(){return this.throwIfDisposed(),rM(this)},ne().prototype.isNaN=function(){return this.throwIfDisposed(),sM(this)},ne().prototype.leakyRelu=function(n){return this.throwIfDisposed(),J0(this,n)},ne().prototype.lessEqual=function(n){return this.throwIfDisposed(),Cu(this,n)},ne().prototype.less=function(n){return this.throwIfDisposed(),xp(this,n)},ne().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),oM(this,n,t,e,r)},ne().prototype.logSigmoid=function(){return this.throwIfDisposed(),iM(this)},ne().prototype.logSoftmax=function(n){return this.throwIfDisposed(),zS(this,n)},ne().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),Y0(this,n,t)},ne().prototype.log=function(){return this.throwIfDisposed(),uo(this)},ne().prototype.log1p=function(){return this.throwIfDisposed(),Z0(this)},ne().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Fi(this,n)},ne().prototype.logicalNot=function(){return this.throwIfDisposed(),Q0(this)},ne().prototype.logicalOr=function(n){return this.throwIfDisposed(),US(this,n)},ne().prototype.logicalXor=function(n){return this.throwIfDisposed(),aM(this,n)},ne().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Ft(this,n,t,e)},ne().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),t1(this,n,t,e,r)},ne().prototype.max=function(n,t){return this.throwIfDisposed(),Oo(this,n,t)},ne().prototype.maximum=function(n){return this.throwIfDisposed(),ya(this,n)},ne().prototype.mean=function(n,t){return this.throwIfDisposed(),Hn(this,n,t)},ne().prototype.min=function(n,t){return this.throwIfDisposed(),yp(this,n,t)},ne().prototype.minimum=function(n){return this.throwIfDisposed(),Su(this,n)},ne().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),uM(this,n,t)},ne().prototype.mod=function(n){return this.throwIfDisposed(),cM(this,n)},ne().prototype.mul=function(n){return this.throwIfDisposed(),L(this,n)},ne().prototype.neg=function(){return this.throwIfDisposed(),In(this)},ne().prototype.norm=function(n,t,e){return this.throwIfDisposed(),bp(this,n,t,e)},ne().prototype.notEqual=function(n){return this.throwIfDisposed(),fd(this,n)},ne().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),r1(this,n,t,e)},ne().prototype.onesLike=function(){return this.throwIfDisposed(),co(this)},ne().prototype.pad=function(n,t){return this.throwIfDisposed(),gl(this,n,t)},ne().prototype.pool=function(n,t,e,r,s,o){return this.throwIfDisposed(),dM(this,n,t,e,r,s,o)},ne().prototype.pow=function(n){return this.throwIfDisposed(),ga(this,n)},ne().prototype.prelu=function(n){return this.throwIfDisposed(),o1(this,n)},ne().prototype.prod=function(n,t){return this.throwIfDisposed(),hM(this,n,t)},ne().prototype.reciprocal=function(){return this.throwIfDisposed(),fM(this)},ne().prototype.relu=function(){return this.throwIfDisposed(),Mi(this)},ne().prototype.relu6=function(){return this.throwIfDisposed(),qS(this)},ne().prototype.reshapeAs=function(n){return this.throwIfDisposed(),V(this,n.shape)},ne().prototype.reshape=function(n){return this.throwIfDisposed(),V(this,n)},ne().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),kM(this,n,t,e)},ne().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),AM(this,n,t,e)},ne().prototype.reverse=function(n){return this.throwIfDisposed(),Mo(this,n)},ne().prototype.rfft=function(){return this.throwIfDisposed(),d1(this)},ne().prototype.round=function(){return this.throwIfDisposed(),KS(this)},ne().prototype.rsqrt=function(){return this.throwIfDisposed(),XS(this)},ne().prototype.selu=function(){return this.throwIfDisposed(),JS(this)},ne().prototype.separableConv2d=function(n,t,e,r,s,o){return this.throwIfDisposed(),ZS(this,n,t,e,r,s,o)},ne().prototype.sigmoid=function(){return this.throwIfDisposed(),ci(this)},ne().prototype.sign=function(){return this.throwIfDisposed(),pM(this)},ne().prototype.sin=function(){return this.throwIfDisposed(),QS(this)},ne().prototype.sinh=function(){return this.throwIfDisposed(),eN(this)},ne().prototype.slice=function(n,t){return this.throwIfDisposed(),rt(this,n,t)},ne().prototype.softmax=function(n){return this.throwIfDisposed(),u1(this,n)},ne().prototype.softplus=function(){return this.throwIfDisposed(),hd(this)},ne().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),s1(this,n,t)},ne().prototype.split=function(n,t){return this.throwIfDisposed(),Hs(this,n,t)},ne().prototype.sqrt=function(){return this.throwIfDisposed(),$r(this)},ne().prototype.square=function(){return this.throwIfDisposed(),cn(this)},ne().prototype.squaredDifference=function(n){return this.throwIfDisposed(),rN(this,n)},ne().prototype.squeeze=function(n){return this.throwIfDisposed(),Yn(this,n)},ne().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof on?[this,n]:[this,...n];return _s(e,t)},ne().prototype.step=function(n){return this.throwIfDisposed(),md(this,n)},ne().prototype.stridedSlice=function(n,t,e,r,s,o,i,a){return this.throwIfDisposed(),mM(this,n,t,e,r,s,o,i,a)},ne().prototype.sub=function(n){return this.throwIfDisposed(),De(this,n)},ne().prototype.sum=function(n,t){return this.throwIfDisposed(),$e(this,n,t)},ne().prototype.tan=function(){return this.throwIfDisposed(),gM(this)},ne().prototype.tanh=function(){return this.throwIfDisposed(),xu(this)},ne().prototype.tile=function(n){return this.throwIfDisposed(),Fo(this,n)},ne().prototype.toBool=function(){return this.throwIfDisposed(),Ce(this,"bool")},ne().prototype.toFloat=function(){return this.throwIfDisposed(),Ce(this,"float32")},ne().prototype.toInt=function(){return this.throwIfDisposed(),Ce(this,"int32")},ne().prototype.topk=function(n,t){return this.throwIfDisposed(),bM(this,n,t)},ne().prototype.transpose=function(n){return this.throwIfDisposed(),$t(this,n)},ne().prototype.unique=function(n){return this.throwIfDisposed(),vM(this,n)},ne().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),iN(this,n,t)},ne().prototype.unstack=function(n){return this.throwIfDisposed(),Po(this,n)},ne().prototype.where=function(n,t){return this.throwIfDisposed(),Xr(n,this,t)},ne().prototype.zerosLike=function(){return this.throwIfDisposed(),Lt(this)};class $i extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$i.prototype)}}class $o extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$o.prototype)}}class z extends Error{constructor(t){super(t),Object.setPrototypeOf(this,z.prototype)}}class vt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,vt.prototype)}}class WN extends Error{constructor(t){super(t),Object.setPrototypeOf(this,WN.prototype)}}Error;class gP{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function Iu(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function ho(n,t){if(!n)throw new WN(t)}function yP(n,t){let e=0;for(const r of n)r===t&&e++;return e}function Es(n){return 1===n.length?n[0]:n}function Jt(n){return Array.isArray(n)?n:[n]}function Sa(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function _u(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Vo={};function HN(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function jN(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>jN(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?jN(r):n[e]=r.value)}}}function Ep(n,t={},e={},r="object",s=!1){if("string"==typeof n){const o=n;let i;if(o in e)i=e[o];else if(o in Vo)i=Vo[o];else if(i=t[o],null==i)throw new z(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const o=n;if(null==o.className||null==o.config)throw new z(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const i=o.className;let a,l;if(i in e?[a,l]=e[i]:i in Vo?[a,l]=Vo.className:i in t&&([a,l]=t[i]),null==a)throw new z(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const f of Object.keys(Vo))u[f]=Vo[f];for(const f of Object.keys(e))u[f]=e[f];o.config.customObjects=u;const d=Object.assign({},Vo);for(const f of Object.keys(e))Vo[f]=e[f];jN(o.config);const h=l(a,o.config,e,s);return Vo=Object.assign({},d),h}{const u=Object.assign({},Vo);for(const d of Object.keys(e))Vo[d]=e[d];const c=new a(o.config);return Vo=Object.assign({},u),c}}}function v1(n,t){return-1*function qse(n,t){return n<t?-1:n>t?1:0}(n,t)}function yl(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function Kse(n){if(null==n)throw new z(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Eu(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new z(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function GN(n,t,e=0,r=1/0){return ho(e>=0),ho(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function Or(n,t){Array.isArray(n)?(_(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>Or(e,`element ${r+1} of ${t}`))):_(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${bP(n)}.`)}function bP(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>bP(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function vP(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let Jse=0;function wP(){return Jse++}const w1={};function x1(n=""){return n in w1||(w1[n]=0),w1[n]+=1,n+w1[n].toString()}const Zse=["channelsFirst","channelsLast"],Yse=["nearest","bilinear"],Qse=["valid","same","causal"],eoe=["max","avg"],toe=["sum","mul","concat","ave"],bd=new Map;function er(n){Eu(Zse,"DataFormat",n)}function fo(n){Eu(Qse,"PaddingMode",n)}function xP(n){Eu(eoe,"PoolMode",n)}const Dp=[];function Du(n,t){Dp.push(n);try{const e=t();return Dp.pop(),e}catch(e){throw Dp.pop(),e}}function SP(n){if(!TP(n))throw new Error("Not a valid tensor name: '"+n+"'");return function roe(){return 0===Dp.length?"":Dp.join("/")+"/"}()+n}function NP(n){if(!TP(n))throw new Error("Not a valid tensor name: '"+n+"'");bd.has(n)||bd.set(n,0);const t=bd.get(n);if(bd.set(n,bd.get(n)+1),t>0){const e=`${n}_${t}`;return bd.set(e,1),e}return n}const soe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function TP(n){return!!n.match(soe)}function ooe(n){return n===parseInt(n.toString(),10)}function bl(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function vd(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function vl(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function hi(n,t){if(t<n)throw new z(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let C1;function mr(){return null==C1&&(C1=MO().epsilon()),C1}function Vi(n,t){return Ce(n,t)}function kp(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),V(n,e)}function ku(n,t,e){return H(()=>{switch(n.rank){case 1:return a1(n,t,e);case 2:return tN(n,[t,0],[e,n.shape[1]]);case 3:return l1(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Sp(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return rt(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return rt(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function qN(n,t,e){return H(()=>{switch(n.rank){case 1:return a1(n,t,e);case 2:return tN(n,[0,t],[n.shape[0],e]);case 3:return l1(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Sp(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function S1(n,t,e,r){return H(()=>{switch(n.rank){case 1:return a1(n,t,e);case 2:switch(r){case 1:return ku(n,t,e);case 2:return qN(n,t,e);default:throw new z(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return ku(n,t,e);case 2:return l1(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return qN(n,t,e);default:throw new z(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return ku(n,t,e);case 2:return Sp(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Sp(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return qN(n,t,e);default:throw new z(`The axis is not within the rank of the tensor ${r}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function KN(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),_n(n,t)}function _P(n,t){switch(n.rank){case 1:return zF([n,t]);case 2:return UF([n,t],0);case 3:return WF([n,t],0);case 4:return HF([n,t],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function XN(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new z(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Fo(n,t)}function N1(n,t=0,e=1,r,s){return GS(n,t,e,r,s)}function Bi(n,t,e,r){if(n.rank<2||t.rank<2)throw new vt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new vt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return fN({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?JN(n.rank,r,"channelsLast"):null,activation:e});{const s=n.shape.slice(),o=s.pop();n=V(n,[-1,o]);const i=t.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:t.rank},(p,g)=>0===g?t.rank-2:g<=t.rank-2?g-1:g);t=V($t(t,c),[l,-1]);const d=[...s,...u];return V(fN({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?JN(n.rank,r,"channelsLast"):null,activation:e}),d)}}function EP(n,t,e){return H(()=>(t=Array.isArray(t)?Qn(t,"int32"):Ce(t,"int32"),wp(n,t,e)))}function Ap(n){return L(n,n)}function JN(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new z(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return V(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return V(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return V(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return V(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return V(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return V(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new z(`Unsupported input rank by biasAdd: ${t.rank}`)}function pi(n,t,e){return H(()=>(null==e&&(e="channelsLast"),er(e),ue(n,JN(n.rank,t,e))))}function DP(n,t,e,r){return H(()=>CM(n,t,e,r))}function Rp(n,t,e=!1){return e?n():t()}const poe=["fanIn","fanOut","fanAvg"],moe=["normal","uniform","truncatedNormal"];class Bo extends od{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}he((()=>{class n extends Bo{apply(e,r){return ar(e,r)}}return n.className="Zeros",n})());let kP=(()=>{class n extends Bo{apply(e,r){return Is(e,r)}}return n.className="Ones",n})();he(kP),he((()=>{class n extends Bo{constructor(e){if(super(),"object"!=typeof e)throw new z(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new z(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return H(()=>L(Ke(this.value),Is(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),he((()=>{class n extends Bo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Nu(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),he((()=>{class n extends Bo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new vt(`randomNormal does not support dType ${r}.`);return N1(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),he((()=>{class n extends Bo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new vt(`truncatedNormal does not support dType ${r}.`);return oN(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),he((()=>{class n extends Bo{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return H(()=>{if(2!==e.length||e[0]!==e[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return L(this.gain,BS(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let po=(()=>{class n extends Bo{constructor(e){if(super(),e.scale<0)throw new z(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale??1,this.mode=e.mode??"fanIn",function goe(n){Eu(poe,"FanMode",n)}(this.mode),this.distribution=e.distribution??"normal",function yoe(n){Eu(moe,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function boe(n,t="channelsLast"){let e,r;if(er(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const s=bl(n,2);e=n[1]*s,r=n[0]*s}else if("channelsLast"===t){const s=bl(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=bl(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),o=s[0],i=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(o+i)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new vt(`${this.getClassName()} does not support dType ${r}.`);return oN(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return Nu(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();he(po);let AP=(()=>{class n extends po{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return po.className}}return n.className="GlorotUniform",n})();he(AP);let RP=(()=>{class n extends po{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return po.className}}return n.className="GlorotNormal",n})();he(RP);let OP=(()=>{class n extends po{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return po.className}}return n.className="HeNormal",n})();he(OP);let FP=(()=>{class n extends po{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return po.className}}return n.className="HeUniform",n})();he(FP);let MP=(()=>{class n extends po{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return po.className}}return n.className="LeCunNormal",n})();he(MP);let PP=(()=>{class n extends po{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return po.className}}return n.className="LeCunUniform",n})();he(PP),he((()=>{class n extends Bo{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain??this.DEFAULT_GAIN,this.seed=e.seed}apply(e,r){return H(()=>{if(e.length<2)throw new vt("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const s=Z(e.slice(0,-1)),o=e[e.length-1],i=s*o;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const l=N1([Math.max(o,s),Math.min(o,s)],0,1,r,this.seed),u=OM.qr(l,!1);let c=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(o,s)*Math.min(o,s)],[Math.min(o,s)+1]);return c=L(c,h.sign()),s<o&&(c=c.transpose()),L(Ke(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const LP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function $P(n,t={}){return Ep(n,Ao.getMap().classNameMap,t,"initializer")}function Ln(n){return HN(n)}function En(n){if("string"==typeof n){const t=n in LP?LP[n]:n;if("GlorotNormal"===t)return new RP;if("GlorotUniform"===t)return new AP;if("HeNormal"===t)return new OP;if("HeUniform"===t)return new FP;if("LeCunNormal"===t)return new MP;if("LeCunUniform"===t)return new PP;{const e={};return e.className=t,e.config={},$P(e)}}return n instanceof Bo?n:$P(n)}function ZN(n){return Array.isArray(n)&&Array.isArray(n[0])}function T1(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function st(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new z(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Gt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new z(`Expected exactly 1 Shape; got ${n.length}`)}return n}function I1(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return t}const VP="Variable";class zi{constructor(t,e="float32",r=VP,s=!0,o=null){this.dtype=e??"float32",this.shape=t.shape,this.id=wP(),this.originalName=SP(r=r??VP),this.name=NP(this.originalName),this.trainable_=s,this.constraint=o,this.val=wM(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function voe(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function YN(n){return n.map(t=>t.read())}function QN(n){n.forEach(t=>{t[0].write(t[1])})}class gr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Ui{constructor(t,e,r,s,o,i,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=a,this.id=wP(),null!=i&&(this.originalName=SP(i),this.name=NP(this.originalName)),this.rank=e.length}}let woe=0;class _1{constructor(t,e){this.callArgs=e,this.id=woe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let xoe=0;class Ot extends od{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xoe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=Sa(r)+"_"+x1(r)}if(this.name=e,this.trainable_=t.trainable??!0,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let o=null;null!=t.batchSize&&(o=t.batchSize),r=[o].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new $o(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new z(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Es(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Es(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new $i(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new $i(`Layer ${this.name} is not connected, no input to return.`);return Es(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new $i(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new $i(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Es(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=Jt(t);if(null==this.inputSpec||0===this.inputSpec.length)return;const r=Jt(this.inputSpec);if(e.length!==r.length)throw new z(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let s=0;s<e.length;s++){const o=e[s],i=r[s];if(null==i)continue;const a=o.rank;if(null!=i.ndim&&a!==i.ndim)throw new z(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(null!=i.maxNDim&&a>i.maxNDim)throw new z(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(null!=i.minNDim&&a<i.minNDim)throw new z(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(null!=i.dtype&&o.dtype!==i.dtype)throw new z(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${o.dtype}.`);if(i.axes){const l=o.shape;for(const u in i.axes){const c=Number(u),d=i.axes[u],h=c>=0?l[c]:l[l.length+c];if(null!=d&&-1===[d,null].indexOf(h))throw new z(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${l}.`)}}if(null!=i.shape)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=o.shape[l];if(null!=u&&null!=c&&u!==c)throw new z(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${o.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=Jt(t),s=function Noe(n){let t=!0;for(const e of Jt(n))if(!(e instanceof Ui)){t=!1;break}return t}(t),o=function Toe(n){let t=!0;for(const e of Jt(n))if(e instanceof Ui){t=!1;break}return t}(t);if(s===o)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return Du(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const a of Jt(t))i.push(a.shape);this.build(Es(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let i=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,i);const a=Jt(i),l=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),l.push(u);if(i=Es(l),null!=this.activityRegularizer)throw new vt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function Coe(n){n=Jt(n);const t=[];for(const e of n)t.push(e.shape);return Es(t)}(t),a=this.computeOutputShape(i);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new Ui(u,c,this,Jt(t),e,this.name,d)):new Ui(u,a,this,Jt(t),e,this.name),this.addInboundNode(t,l,null,null,i,a,e),this._refCount++,null!=this.activityRegularizer)throw new vt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=t[s]&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new $i(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new $i(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new $o(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return I1(this.weights)}build(t){this.built=!0}getWeights(t=!1){return YN(t?this.trainableWeights:this.weights)}setWeights(t){H(()=>{const e=this.weights;if(e.length!==t.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],s=YN(e);for(let o=0;o<s.length;++o){const i=s[o],a=e[o],l=t[o];if(!Pt(i.shape,l.shape))throw new z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}QN(r)})}addWeight(t,e,r,s,o,i,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new z(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():En("zeros"));const u=s.apply(e,r),c=new zi(u,r,t,i,a);return u.dispose(),null!=o&&this.addLoss(()=>o.apply(c.read())),null==i&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=Jt(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}setMaskMetadata(t,e,r){if(!this.supportsMasking)return;const s=this.computeMask(t,r),o=Jt(e),i=Jt(s);if(o.length!==i.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let a=0;a<o.length;a++)o[a].kerasMask=i[a]}addInboundNode(t,e,r,s,o,i,a=null){const l=Jt(t);e=Jt(e),r=Jt(r),s=Jt(s),o=T1(o),i=T1(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new _1({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function BP(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const u=BP(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const c of u)-1===s.indexOf(c)&&s.push(c)}return s}}}let Op=(()=>{class n extends Ot{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:x1("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const o=new Ui(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new _1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();he(Op);class wl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof wl)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new z(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function Ioe(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return Ce(t,n.dtype)}catch{throw new z(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Ui){if(null==this.id2Value[t.id])throw new z(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Ui){if(null==this.id2Value[t.id])throw new z(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&ut(this.id2Mask)}}const E1=new gP,D1=new gP;function Fp(n,t,e,r){const s=null!=e&&e.training,o=Array.isArray(n),i=o?n:[n],a=i.map(p=>p.name),l=[],u=t.names();for(const p of a)-1!==u.indexOf(p)?l.push(t.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=a.join(",")+"|"+t.names().sort().join(",");let h,d=E1.get(c);if(null==d){const p=function Eoe(n,t){_(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const s=UP(n[0],t);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const o of n){const{sorted:i,recipientMap:a}=UP(o,t);for(const l of i)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:Doe(r)}}(i,t);d=p.sorted,h=p.recipientCounts,E1.put(c,d),D1.put(c,h)}h={},s||Object.assign(h,D1.get(c));const f=new wl(t);for(let p=0;p<d.length;++p){if(null!=r){const R=q2().numTensors;R>r.maxNumTensors&&(r.maxNumTensors=R),R<r.minNumTensors&&(r.minNumTensors=R)}const g=d[p],m=g.sourceLayer;if(m instanceof Op)continue;const y=[],v=[],w=[];let x=!1;for(const R of g.inputs){const F=f.getValue(R),U=f.getMask(R);y.push(F),v.push(U),null!=U&&(x=!0),s||(h[R.name]--,0===h[R.name]&&!t.hasKey(R)&&-1===a.indexOf(R.name)&&!F.isDisposed&&!0!==R.sourceLayer.stateful&&w.push(F))}x&&((e=e||{}).mask=v[0]);const N=Jt(m.apply(y,e));let I=null;m.supportsMasking&&(I=m.computeMask(y,v));const k=koe(g),A=Array.isArray(k)?k:[k];for(let R=0;R<A.length;++R){f.hasKey(A[R])||f.add(A[R],N[R],Array.isArray(I)?I[0]:I);const F=a.indexOf(A[R].name);-1!==F&&(l[F]=N[R])}s||ut(w)}return f.disposeMasks(),o?l:l[0]}function Doe(n){const t={};for(const e in n)t[e]=n[e].size;return t}function UP(n,t){const e=new Set,r=[],s={};for(const a of t.names())e.add(a);const o=[],i=[];for(o.push(n);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(0===a.inputs.length||l)o.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)null==s[u.name]&&(s[u.name]=new Set),s[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function koe(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function eT(n,t){return H(()=>$r($e(L(n,n),t,!0)))}G().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function _oe(n){E1?.setMaxEntries(n),D1?.setMaxEntries(n)});class Mp extends od{getConfig(){return{}}}he((()=>{class n extends Mp{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return H(()=>{const r=eT(e,this.axis),s=Ts(r,0,this.maxValue);return L(e,Ee(s,ue(mr(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),he((()=>{class n extends Mp{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return H(()=>Ee(e,ue(mr(),eT(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),he((()=>{class n extends Mp{apply(e){return Mi(e)}}return n.className="NonNeg",n})()),he((()=>{class n extends Mp{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return H(()=>{const r=eT(e,this.axis),s=ue(L(this.rate,Ts(r,this.minValue,this.maxValue)),L(1-this.rate,r));return L(e,Ee(s,ue(mr(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const WP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function yr(n){return HN(n)}function HP(n,t={}){return Ep(n,Ao.getMap().classNameMap,t,"constraint")}function br(n){return null==n?null:"string"==typeof n?HP({className:n in WP?WP[n]:n,config:{}}):n instanceof Mp?n:HP(n)}function xl(n){return tT.apply(this,arguments)}function tT(){return(tT=J(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const s in n){const o=n[s];if("number"!=typeof o){const i=o;t.push(i.data()),e.push(s),r.push(i)}}if(t.length>0){const s=yield Promise.all(t);for(let o=0;o<s.length;++o)n[e[o]]=s[o][0];ut(r)}})).apply(this,arguments)}function jP(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class wd{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return J(function*(){})()}onEpochEnd(t,e){return J(function*(){})()}onBatchBegin(t,e){return J(function*(){})()}onBatchEnd(t,e){return J(function*(){})()}onTrainBegin(t){return J(function*(){})()}onTrainEnd(t){return J(function*(){})()}setModel(t){}}class Roe{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return J(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return J(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class Ooe extends wd{constructor(){super()}onEpochBegin(t){var e=this;return J(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return J(function*(){null==e&&(e={});const s=e.size??0;r.seen+=s;for(const o in e){const i=e[o];if("number"==typeof i)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+i*s;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const l=H(()=>ue(r.totals[o],L(i,s)));r.totals[o]=l,a?.dispose()}}})()}onEpochEnd(t,e){var r=this;return J(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:H(()=>{const o=L(Ee(1,r.seen),r.totals[s]);e[s]=o,r.totals[s].dispose(),kr(e[s])}))})()}}class Foe extends wd{onTrainBegin(t){var e=this;return J(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return J(function*(){null==e&&(e={}),r.epoch.push(t);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var t=this;return J(function*(){const e=[],r=[],s=[];for(const i in t.history){const a=t.history[i];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(i),s.push(l))}const o=yield Promise.all(e);for(let i=0;i<o.length;++i)t.history[r[i]][s[i]].dispose(),t.history[r[i]][s[i]]=o[i][0]})()}}class Moe extends wd{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||FM,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");TC(this.yieldEvery)&&(this.maybeWait=function Xse(n,t,e){let s,r=null!=e?e():Ss();return(...i)=>{const a=null!=e?e():Ss();return a-r<t||(r=a,s=n(...i)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var s=this;return J(function*(){const o=[];null!=s.yield&&(yield xl(r),o.push(s.yield(t,e,r))),o.push(s.nextFrameFunc()),yield Promise.all(o)})()}onEpochBegin(t,e){var r=this;return J(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield xl(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return J(function*(){const s=[];null!=r.epochEnd&&(yield xl(e),s.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(t,e){var r=this;return J(function*(){null!=r.batchBegin&&(yield xl(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return J(function*(){const s=[];null!=r.batchEnd&&(yield xl(e),s.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):TC(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return J(function*(){null!=e.trainBegin&&(yield xl(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return J(function*(){null!=e.trainEnd&&(yield xl(t),yield e.trainEnd(t))})()}}function GP(n,t){return null==n&&(n={}),n instanceof wd?[n]:Array.isArray(n)&&n[0]instanceof wd?n:Jt(n).map(r=>new Moe(r,t))}let Poe=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){_(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(o=>{if(o===e)throw new z("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const s in n.constructors){const o=+s;e>=o&&r.push(...n.constructors[o])}return r.map(s=>new s)}}return n.constructors={},n})();function qP(n,t,e,r,s,o,i,a,l){const u=new Foe,c=[new Ooe,...Poe.createCallbacks(t)];null!=n&&c.push(...n),c.push(u);const d=new Roe(c);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:o,batchSize:i,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:u}}function Na(n,t={},e=!1){return Ep(n,Ao.getMap().classNameMap,t,"layer",e)}function k1(n,t){return H(()=>{"float32"!==n.dtype&&(n=Ce(n,"float32"));const e=$e(Ap(n),t,!0),r=id(e.shape,mr()),s=$r(ya(e,r));return Ee(n,s)})}function A1(n,t){return H(()=>Hn(Ap(De(t,n)),-1))}function nT(n,t){return H(()=>Hn(fr(De(t,n)),-1))}function rT(n,t){return H(()=>{const e=De(n,t),r=Ts(fr(n),mr(),Number.MAX_VALUE),s=fr(Ee(e,r));return L(100,Hn(s,-1))})}function Pp(n,t,e=!1){return H(()=>{if(e)t=u1(t);else{const r=$e(t,t.shape.length-1,!0);t=Ee(t,r)}return t=Ts(t,mr(),1-mr()),In($e(L(Ce(n,"float32"),uo(t)),t.shape.length-1))})}function R1(n,t,e=!1){return H(()=>{const r=Ce(vp(function uoe(n){const t=[bl(n.shape)];return V(n,t)}(n)),"int32"),s=(t=Ts(t,mr(),1-mr())).shape;return Pp(V(r1(r,s[s.length-1]),s),t,e)})}function O1(n,t){return H(()=>{let e;return e=Ts(t,mr(),1-mr()),e=uo(Ee(e,De(1,e))),Hn(function Uoe(n,t){if(!Pt(n.shape,t.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return H(()=>{const e=Mi(t),r=In(fr(t));return ue(De(e,L(t,n)),Z0(ls(r)))})}(n,e),-1)})}function KP(n,t){return H(()=>{const e=k1(n,-1),r=k1(t,-1),s=L(e,r);return In($e(s,-1))})}const F1={meanSquaredError:A1,meanAbsoluteError:nT,meanAbsolutePercentageError:rT,meanSquaredLogarithmicError:function Loe(n,t){return H(()=>{const e=Ts(t,mr(),Number.MAX_VALUE),r=uo(ue(1,e)),s=Ts(n,mr(),Number.MAX_VALUE),o=uo(ue(1,s));return Hn(Ap(De(r,o)),-1)})},squaredHinge:function $oe(n,t){return H(()=>{const e=ya(0,De(1,L(n,t)));return Hn(Ap(e),-1)})},hinge:function Voe(n,t){return H(()=>{const e=ya(0,De(1,L(n,t)));return Hn(e,-1)})},categoricalHinge:function Boe(n,t){return H(()=>{const e=$e(L(n,t),-1),r=Oo(L(De(1,n),t),-1);return ya(0,ue(1,De(r,e)))})},logcosh:function zoe(n,t){return H(()=>{const e=Math.log(2),r=De(t,n),s=De(ue(r,hd(L(-2,r))),e);return Hn(s,-1)})},categoricalCrossentropy:Pp,sparseCategoricalCrossentropy:R1,binaryCrossentropy:O1,kullbackLeiblerDivergence:function Woe(n,t){return H(()=>{const e=Ts(n,mr(),1),r=Ts(t,mr(),1);return $e(L(n,uo(Ee(e,r))),-1)})},poisson:function Hoe(n,t){return H(()=>{const e=uo(ue(mr(),t));return Hn(De(t,L(n,e)),-1)})},cosineProximity:KP};function sT(n){if("string"==typeof n){if(n in F1)return F1[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(t)}return n}function XP(n,t){return H(()=>{const e=L(.5,co(t)),r=Vi(Ws(t,e),n.dtype);return Hn(di(n,r),-1)})}function JP(n,t){return H(()=>Vi(di(ld(n,-1),ld(t,-1)),"float32"))}function Koe(n,t){return O1(n,t)}function Xoe(n,t){return n.rank===t.rank&&(n=Yn(n,[n.rank-1])),(t=ld(t,-1)).dtype!==n.dtype&&(t=Ce(t,n.dtype)),Ce(di(n,t),"float32")}const YP=Pp,QP=R1,M1={binaryAccuracy:XP,categoricalAccuracy:JP,precision:function qoe(n,t){return H(()=>{const e=function ZP(n,t){return H(()=>Ce($e(Fi(di(n,1),di(t,1))),"float32"))}(n,t),r=function Goe(n,t){return H(()=>Ce($e(Fi(di(n,0),di(t,1))),"float32"))}(n,t),s=ue(e,r);return Ce(Xr(Ws(s,0),Ee(e,s),0),"float32")})},categoricalCrossentropy:YP,sparseCategoricalCrossentropy:QP,mse:A1,MSE:A1,mae:nT,MAE:nT,mape:rT,MAPE:rT,cosine:KP};function rie(n){if("string"==typeof n&&n in M1)return M1[n];if("string"!=typeof n&&null!=n)return n;throw new z(`Unknown metric ${n}`)}function P1(n){if(ho(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(F1))if(F1[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(M1))if(M1[e]===n){t=e;break}return void 0!==t?t:n.name}}function t4(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!oT(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function oT(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!oT(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!oT(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function L1(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function lie(n,t,e){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}L1([`${n.name} (${n.getClassName()})`,s,r,n.countParams().toString()],t,e)}function uie(n,t,e,r){let s,o;try{o=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{o="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)i.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),u=0===i.length?"":i[0];L1([`${a} (${l})`,o,s,n.countParams().toString(),u],t,r);for(let d=1;d<i.length;++d)L1(["","","","",i[d]],t,r)}function n4(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function iT(n,t){if(null===n)return null;if("string"==typeof n)return _u(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const o=n[s];n4(t,s,o)?e.push(o):e.push(iT(o,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const o=_u(r);e[o]=iT(s,o)}}return e}}function aT(n,t){if(null==n)return null;if("string"==typeof n)return Sa(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const o=n[s];n4(t,s,o)?e.push(o):e.push(aT(o,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];e[Sa(r)]="name"!==r&&"className"!==r||"string"!=typeof s?aT(s,r):s}return e}}class mi extends Ot{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const v=this.getClassName().toLowerCase();this.name=x1(v)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],yl(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);yl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const x=v.nodeIndex,N=v.tensorIndex;this.outputLayers.push(v.sourceLayer),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(N)}for(const v of this.inputs){const w=v.sourceLayer,x=v.nodeIndex,N=v.tensorIndex;ho(0===x,"input layer has >1 nodes"),ho(0===N,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(N)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const w=this.inputLayers[v];if(!(w instanceof Op))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${v} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);const e={},r={},s={},o={},i={},a=[],l=(v,w,x,N,I,k)=>{(null==N||null==I||null==k)&&(N=v.sourceLayer,I=v.nodeIndex,k=v.tensorIndex);const A=N.inboundNodes[I];if(-1!==x.indexOf(A))throw new $o(`The tensor ${v.name} at layer "${N.name}" is part of a cycle.`);if(-1!==w.indexOf(A))return;this.containerNodes.add(mi.nodeKey(N,I)),N.id in i||(i[N.id]=Object.keys(i).length),-1===x.indexOf(A)&&x.push(A);const R=A.inboundLayers.length;for(let F=0;F<R;F++)l(A.inputTensors[F],w,x,A.inboundLayers[F],A.nodeIndices[F],A.tensorIndices[F]);for(w.push(A);x.indexOf(A)>=0;)x.splice(x.indexOf(A),1);a.push(A)},u=[],c=[];for(const v of this.outputs)l(v,u,c);const d=a.slice().reverse();for(const v of d){r[v.id]=v,v.id in e||(e[v.id]=0);let w=e[v.id];w=Math.max(w,s[v.outboundLayer.id]??0),s[v.outboundLayer.id]=w,o[v.outboundLayer.id]=v.outboundLayer,e[v.id]=w;for(let N=0;N<v.inboundLayers.length;N++){const A=v.inboundLayers[N].inboundNodes[v.nodeIndices[N]];e[A.id]=Math.max(w+1,e[A.id]??0),r[A.id]=A}}const h={};for(const v in e){const w=e[v];w in h||(h[w]=[]),h[w].push(r[v])}const f={};for(const v in s){const w=s[v];w in f||(f[w]=[]),f[w].push(o[v])}let p=Object.keys(f).map(v=>parseInt(v,10)).sort(v1);this.layers=[];for(const v of p){const w=f[v];w.sort((x,N)=>{const I=i[x.id],k=i[N.id];return I<k?-1:I>k?1:0});for(const x of w)x instanceof mi&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=f,p=Object.keys(h).map(v=>parseInt(v,10)).sort(v1);const g=this.inputs.slice(),m=[];for(const v of p)for(const w of h[v]){const x=w.outboundLayer;if(null!=x){for(const N of w.inputTensors)if(-1===g.indexOf(N))throw new $o(`Graph disconnected: cannot obtain value for tensor ${N} at layer "${x.name}". The following previous layers were accessed without issue: ${m}`);for(const N of w.outputTensors)g.push(N);m.push(x.name)}}this.nodesByDepth=h;const y=this.layers.map(v=>v.name);for(const v of y){const w=y.filter(x=>x===v).length;if(1!==w)throw new $o(`The name "${v}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new _1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let s=0;const o=(n=>{const t=Object.keys(n);if(0===t.length)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))})(t);o&&this.parseWeights(t);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=o?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(null!=r[c])throw new z(`Duplicate weight name: ${c}`);r[c]=u,s++}const i=[];for(const a in t){let l=a;if(null==r[a]){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(null!=r[l])i.push([r[l],t[a]]);else if(e)throw new z(`Provided weight data has no target variable: ${a}`);delete r[l]}if(e){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new z(`${a.length} of ${s} weights are not set: ${a}`)}QN(i)}parseWeights(t){for(const e in Object.keys(t)){const r=e.split("/"),s=["vars","layer_checkpoint_dependencies"],o=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");o!==e&&(t[o]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.22.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=aT(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return H(()=>{t=Jt(t);const r=new wl;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Fp(this.outputs,r,e)})}computeMask(t,e){return H(()=>{let r;return t=Jt(t),r=null==e?Iu(null,t.length):Jt(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=T1(t);if(e.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(v1);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(g=>g.id).indexOf(c.id))continue;const d=[];for(let g=0;g<u.inboundLayers.length;g++)d.push(r[`${u.inboundLayers[g].name}_${u.nodeIndices[g]}_${u.tensorIndices[g]}`]);const f=T1(c.computeOutputShape(Es(d))),p=c.inboundNodes.indexOf(u);for(let g=0;g<f.length;g++)r[`${c.name}_${p}_${g}`]=f[g]}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const l=i[a];ho(l in r),o.push(r[l])}return Es(o)}runInternalGraph(t,e){null==e&&(e=Iu(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(v1);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,f=c.outputTensors,p=new Array;for(const g of h)g.id in r&&p.push(r[g.id]);if(p.length===h.length){let m,y,v,w,g={};if(null!=c.callArgs&&(g=c.callArgs),1===p.length){const[x,N]=p[0];null==g.mask&&(g.mask=N),v=Jt(d.call(x,g)),w=Jt(d.computeMask(x,N)),m=[x],y=[N]}else m=p.map(x=>x[0]),y=p.map(x=>x[1]),null==g.mask&&(g.mask=y),v=Jt(d.call(m,g)),w=Jt(d.computeMask(m,y));if(d.activityRegularizer)throw new vt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<f.length;++x)r[f[x].id]=[v[x],w[x]]}}}const o=[],i=[],a=[];for(const l of this.outputs){ho(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(t){const e={};let r;for(const s of this.layers){r=s instanceof mi?1:0;for(let o=0;o<s.inboundNodes.length;o++){const i=mi.nodeKey(s,o);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new z("Provide either a layer name or layer index");if("number"==typeof t)return this.findLayer(t);for(const r of this.layers)if(r.name===t)return r;throw new z(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new z(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return H(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=mi.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],f=mi.nodeKey(i,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const g=[];for(let m=0;m<h.inboundLayers.length;m++){const y=h.inboundLayers[m],w=h.tensorIndices[m];let N=e[mi.nodeKey(y,h.nodeIndices[m])];null==N&&(N=0),g.push([y.name,N,w,p])}u.push(g)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=mi.nodeKey(a,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),s.push([a.name,c,this.inputLayersTensorIndices[i]])}t.inputLayers=s;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=mi.nodeKey(a,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),o.push([a.name,c,this.outputLayersTensorIndices[i]])}return t.outputLayers=o,t}static fromConfig(t,e,r={},s=!1){const o={},i={};function a(m,y){m.name in i?i[m.name].push(y):i[m.name]=[y]}function l(m,y){const v=[];let w;for(const x of y){const N=x[0],I=x[1],k=x[2];if(w=x[3]??{},!(N in o))return void a(m,y);const A=o[N];if(A.inboundNodes.length<=I)return void a(m,y);v.push(A.inboundNodes[I].outputTensors[k])}v.length>0&&m.apply(Es(v),w)}function u(m){const y=m.name,v=Na(m,null!=e.customObjects?e.customObjects:{});v.setFastWeightInitDuringBuild(s),o[y]=v,m.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${x}`);a(v,x)})}const c=e.name,d=e.layers;for(const m of d)u(m);for(;!Kse(i);)for(const m of d){const y=o[m.name];if(y.name in i){const v=i[y.name];delete i[y.name];for(const w of v)l(y,w)}}const h=[],f=[],p=e.inputLayers;for(const m of p){const y=m[0],v=m[1],w=m[2];ho(y in o),h.push(o[y].inboundNodes[v].outputTensors[w])}const g=e.outputLayers;for(const m of g){const y=m[0],v=m[1],w=m[2];ho(y in o),f.push(o[y].inboundNodes[v].outputTensors[w])}return new t({inputs:h,outputs:f,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){H(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function s4(n,t){return function r4(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const s=[];return t.forEach(o=>{s.push(o in n?n[o]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function o4(n,t,e,r){return uT.apply(this,arguments)}function uT(){return(uT=J(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=H(()=>{if(1===n.shape.length)return pa(n);if(2===n.shape.length){if(n.shape[1]>1)return ld(n,1);if(1===n.shape[1])return V(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield s.data());ut(s);const i=[];return o.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Qn(i,"float32")}return null})).apply(this,arguments)}function die(n,t){return L(n,t)}function i4(n,t){let e,r;e=t.xs,r=t.ys,_(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const o=a4("input",n.inputNames,e),i=a4("output",n.outputNames,r),a=o[0].shape[0];_(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),_(i.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<o.length;l++)_(o[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<i.length;l++)_(i[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:o,ys:i}}function a4(n,t,e){if(e instanceof on)return[e];if(Array.isArray(e))return _(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const s of t){if(null==e[s])throw new z(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function fie(n){if(3===n.length)throw new vt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function cT(){return(cT=J(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(_(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),_(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),_(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),_(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),_(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=null!=e.validationData;let o,i;if(s)if(l4(e.validationData))_(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const m=fie(e.validationData);o=m.xs,i=m.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(m=>"val_"+m)):l.slice();const c=GP(e.callbacks,e.yieldEvery),d=e.verbose??1,{callbackList:h,history:f}=qP(c,d,e.epochs,null,null,mie(t,e),null,s,u);h.setModel(n),n.history=f,yield h.onTrainBegin(),n.stopTraining_=!1;let p=e.initialEpoch??0,g=yield t.iterator();for(;p<e.epochs;){const m={};yield h.onEpochBegin(p);let y=0,v=0;for(r||(g=yield t.iterator());!r||y<e.batchesPerEpoch;){const w=yield g.next();if(r&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=w.value){const{xs:x,ys:N}=i4(n,w.value),I={};I.batch=v,I.size=x[0].shape[0],yield h.onBatchBegin(v,I);const k=[];if(null!=e.classWeight){const F=s4(e.classWeight,n.outputNames);for(let U=0;U<F.length;++U)k.push(yield o4(N[U],null,F[U]))}const A=x.concat(N).concat(k),R=a(A);ut(A);for(let F=0;F<l.length;++F){const q=R[F];I[l[F]]=q,kr(q)}yield h.onBatchEnd(v,I),jP(I),v++,y++}if(r?y>=e.batchesPerEpoch:w.done){if(s){let x;x=l4(e.validationData)?Jt(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):Jt(n.evaluate(o,i,{batchSize:e.validationBatchSize??32,verbose:0}));for(let N=0;N<n.metricsNames.length;++N)m[`val_${n.metricsNames[N]}`]=x[N]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(p,m),p++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function mie(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function l4(n){return"function"==typeof n.iterator}function gie(n){return"function"==typeof n.next}function dT(){return(dT=J(function*(n,t,e){const r=null!=(e=e||{}).batches,s=n.testFunction;let o=[];if(e.verbose>0)throw new vt("Verbose mode is not implemented yet.");_(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const i=gie(t)?t:yield t.iterator();let a=0,l=0;for(;!r||l<e.batches;){const u=yield i.next();if(o=H(()=>{if(u.value){const{xs:c,ys:d}=i4(n,u.value),h=c.concat(d),f=H(()=>s(h));if(ut(h),0===l)for(let g=0;g<f.length;++g)o.push(Ke(0));const p=h[0].shape[0];for(let g=0;g<f.length;++g){const m=f[g],y=o[g];o[g]=H(()=>ue(o[g],L(p,m))),l>0&&ut(y)}ut(f),a+=p,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=Ee(o[u],a),ut(c)}return Es(o)})).apply(this,arguments)}function hT(n){_(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Lp(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>ku(r,t,e-t)):ku(n,t,e-t)}function fT(n,t){return H(()=>null==n?null:Array.isArray(n)?n.map(e=>fT(e,t)):EP(n,"int32"===t.dtype?t:Ce(t,"int32")))}function pT(n,t){const e=[];let r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}function u4(n){const t=[];n instanceof on&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(kp(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function gi(n,t){if(null==n)return;const e=[];if(t instanceof on)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(null!=t)for(const s in t)e.push(t[s].id);const r=[];if(n instanceof on)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=n)for(const s in n){const o=n[s];-1===e.indexOf(o.id)&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function mT(n){return Array.isArray(n)}function c4(n){return!function bie(n){return n instanceof on}(n)&&!mT(n)}function d4(n,t,e,r=!0,s=""){if(null==t||0===t.length){if(null!=n){let i=!1;if(mT(n)&&n.length>0)i=!0;else if(c4(n)){for(const a in n)if(n.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new z(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(i=>null);let o;if(c4(n)){o=[];for(const i of t){if(null==n[i])throw new z(`No data provided for "${i}". Need data for each key in: ${t}`);o.push(n[i])}}else if(mT(n)){if(n.length!==t.length)throw new z(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(t.length>1)throw new z(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=u4(o),null!=e)for(let i=0;i<t.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${s}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c>=0&&u!==c)throw new z(`${s} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function h4(n,t,e,r=!0,s=""){let o;if(Array.isArray(n)){if(n.length!==t.length)throw new z(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(t.length>1)throw new z(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(null!=e)for(let i=0;i<t.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${s}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c!==u)throw new z(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let xd=(()=>{class n extends mi{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function oie(n,t,e,r=console.log){const s=function aie(n){let t=!0;const e=[],r=[];for(const s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of n.layers){let o=!1;for(const i of s.inboundNodes)if(-1!==r.indexOf(i)){if(o){t=!1;break}o=!0}if(!t)break}return t}(n),o=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c))),!s){o.push("Receives inputs"),i=[];for(const c in n.nodesByDepth)i.push(...n.nodesByDepth[c])}r("_".repeat(t)),L1(o,e,r),r("=".repeat(t));const a=n.layers;for(let c=0;c<a.length;++c)s?lie(a[c],e,r):uie(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function iie(n){let t;return t=I1(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),u=I1(n.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function sie(n){const t={Adagrad:()=>yd.adagrad(.01),Adadelta:()=>yd.adadelta(1,.95,mr()),Adam:()=>yd.adam(.001,.9,.999,mr()),Adamax:()=>yd.adamax(.002,.9,.999,mr(),0),RMSProp:()=>yd.rmsprop(.001,.9,0,mr()),SGD:()=>yd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new z(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof cl))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>sT(l))}else{const a=sT(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new z(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(sT(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Du("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const o=function xie(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const s of t){let o=e.hasOwnProperty(s)?e[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};Du("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(c=>{let h,f,p;for(const g of c){if("string"==typeof g&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(g)){const y=this.internalOutputShapes[a];let v;1===y[y.length-1]||this.lossFunctions[a]===O1?-1!==["accuracy","acc"].indexOf(g)?f=XP:-1!==["crossentropy","ce"].indexOf(g)&&(f=Koe):this.lossFunctions[a]===R1?-1!==["accuracy","acc"].indexOf(g)?f=Xoe:-1!==["crossentropy","ce"].indexOf(g)&&(f=QP):-1!==["accuracy","acc"].indexOf(g)?f=JP:-1!==["crossentropy","ce"].indexOf(g)&&(f=YP),-1!==["accuracy","acc"].indexOf(g)?v="acc":-1!==["crossentropy","ce"].indexOf(g)&&(v="ce"),p=f,h=""+v}else p=rie(g),h=""+P1(g);let m;Du(h,()=>{m=p}),i(a,h,m)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const o=s.batchSize??32;hT(o);const a=this.standardizeUserDataXY(e,r,!0,o);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),Es(this.testLoop(this.testFunction,l,o,s.verbose,s.steps))}finally{gi(a[0],e),gi(a[1],r)}}evaluateDataset(e,r){var s=this;return J(function*(){return s.makeTestFunction(),function yie(n,t,e){return dT.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,o="steps"){let i;if(null!=s){if(i=null,null!=r)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new z("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),i=this.retrieveSymbolicTensors(s?r:[r]),a=new wl;if(e instanceof on&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new z(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new z(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=Fp(i,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=Iu(null,e.length);let s=e.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){const u=a.indexOf(e[l]);if(-1!==u&&(r[l]=i[u],s--),0===s)break}if(0===s)break}if(s>0){const o=[];throw r.forEach((i,a)=>{null==i&&o.push(e[a])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(e,r=32,s=!1){return H(()=>{const o=this.checkNumSamples(e);if(s)throw new vt("Verbose predictLoop() is not implemented yet.");const i=pT(o,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)H(()=>{const h=Lp(e,i[l][0],i[l][1]),f=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)f.push({key:this.inputs[g],value:h[g]});else f.push({key:this.inputs[0],value:h});const p=new wl(f);return Fp(this.outputs,p)}).forEach((c,d)=>a[d].push(c));return Es(a.map(l=>_n(l,0)))})}predict(e,r={}){const s=u4(e);h4(s,this.inputNames,this.feedInputShapes,!1);try{const o=r.batchSize??32;return hT(o),this.predictLoop(s,o)}finally{gi(s,e)}}predictOnBatch(e){h4(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,o){if(null==this.optimizer_)throw new $o("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];i.push(this.feedLossFns[a]===R1?l.slice(0,l.length-1).concat([1]):l)}if(function vie(n,t,e){const r=yl(n.map(o=>o.shape[0]));r.sort();const s=yl(t.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(s.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!Pt(r,s))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=d4(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=d4(r,this.feedOutputNames,i,!1,"target")),function wie(n,t,e){const r=[A1,O1,Pp];for(let s=0;s<n.length;++s){const o=n[s],i=t[s],a=e[s];if(null!=i){if(i===Pp&&1===o.shape[o.shape.length-1])throw new z(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const d=l[c],h=u[c];if(null!=h&&d!==h)throw new z(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,o,i=!0,a){var l=this;return J(function*(){const[u,c]=l.standardizeUserDataXY(e,r,i,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=o){const h=s4(o,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield o4(c[f],null,h[f]))}return[u,c,d]})()}testLoop(e,r,s,o=0,i){return H(()=>{const a=this.checkNumSamples(r,s,i,"steps"),l=[];if(o>0)throw new vt("Verbose mode is not implemented yet.");if(null!=i)throw new vt("steps mode in testLoop() is not implemented yet");{const u=pT(a,s),c=Qn(hi(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],f=u[d][1],p=ku(c,h,f-h),g=fT(r,p),m=e(g);if(0===d)for(let y=0;y<m.length;++y)l.push(Ke(0));for(let y=0;y<m.length;++y)l[y]=ue(l[y],L(f-h,m[y]))}for(let d=0;d<l.length;++d)l[d]=Ee(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const o=e[s];let i=o;yP(e,o)>1&&(i+=`_${yP(e.slice(0,s),o)}`),r.push(i)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:s[m]});const f=new wl(h),p=Fp(this.outputs,f,{training:!0});let g;for(let m=0;m<this.lossFunctions.length;++m){let v=(0,this.lossFunctions[m])(o[m],p[m]);null!=i[m]&&(v=die(v,i[m]));const w=Hn(v);r.push(w),g=0===m?v:ue(g,v)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=r[m];else{const w=this.metricsTensors[m][1];y=Hn((0,this.metricsTensors[m][0])(o[w],p[w]))}kr(y),a.push(y)}return g=Hn(g),this.calculateLosses().forEach(m=>{g=ue(g,m)}),g},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>H(()=>{const r=[];let s;const o=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:o[c]});const l=new wl(a),u=Fp(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=Hn((0,this.lossFunctions[c])(i[c],u[c]));s=0===c?h:ue(s,h),r.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],f=Hn((0,this.metricsTensors[c][0])(i[h],u[h]));r.push(f)}return r})}fit(e,r,s={}){var o=this;return J(function*(){if(o.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,a,l,u,c,d,h,f,p;o.isTraining=!0;try{const g=s.batchSize??32;hT(g);const m=!1,y=yield o.standardizeUserData(e,r,s.sampleWeight,s.classWeight,m,g);i=y[0],a=y[1],p=y[2];let w,v=!1;if(null!=s.validationData&&s.validationData.length>0){if(v=!0,2!==s.validationData.length)throw 3===s.validationData.length?new vt("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);c=s.validationData[0],d=s.validationData[1];const U=!0,q=yield o.standardizeUserData(c,d,null,null,U,g);h=q[0],f=q[1],w=h.concat(f)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){v=!0;const U=Math.floor(i[0].shape[0]*(1-s.validationSplit)),q=i[0].shape[0];h=Lp(i,U,q),l=i,i=Lp(i,0,U),f=Lp(a,U,q),u=a,a=Lp(a,0,U),w=h.concat(f)}else null!=s.validationSteps&&(v=!0);const x=i.concat(a).concat(p);o.checkTrainableWeightsConsistency();const N=o.makeTrainFunction(),I=o.getDedupedMetricsNames();let k,A;v?(o.makeTestFunction(),k=o.testFunction,A=I.slice().concat(I.map(U=>"val_"+U))):(k=null,w=[],A=I.slice());const R=GP(s.callbacks,s.yieldEvery);return yield o.fitLoop(N,x,I,g,s.epochs,s.verbose,R,k,w,s.shuffle,A,s.initialEpoch,null,null)}finally{o.isTraining=!1,gi(i,e),gi(a,r),gi(l,e),gi(u,r),gi(h,c),gi(f,d),null!=p&&ut(p)}})()}fitLoop(e,r,s,o,i,a,l,u,c,d,h,f,p,g){var m=this;return J(function*(){null==o&&(o=32),null==i&&(i=1),null==d&&(d=!0),null==f&&(f=0);let y=!1;if(null!=u&&null!=c&&(y=!0),null!=g&&(y=!0,null==p))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const v=m.checkNumSamples(r,o,p,"steps_per_epoch");let w;null!=v&&(w=hi(0,v)),null==a&&(a=1);const{callbackList:x,history:N}=qP(l,a,i,f,v,p,o,y,h);x.setModel(m),m.history=N,yield x.onTrainBegin(),m.stopTraining_=!1;for(let I=f;I<i;++I){yield x.onEpochBegin(I);const k={};if(null!=p)throw new vt("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new vt("batch shuffling is not implemneted yet");d&&oO(w);const A=Qn(w),R=pT(v,o);for(let F=0;F<R.length;++F){const U={};if(yield x.onBatchBegin(F,U),H(()=>{const q=R[F][0],K=R[F][1],Y=ku(A,q,K-q);U.batch=F,U.size=K-q;const Q=fT(r,Y),se=e(Q);for(let ie=0;ie<s.length;++ie){const ae=se[ie];U[s[ie]]=ae,kr(ae)}if(F===R.length-1&&y){const ie=m.testLoop(u,c,o);for(let te=0;te<s.length;++te){const ae=s[te],pe=ie[te];kr(pe),k["val_"+ae]=pe}}}),yield x.onBatchEnd(F,U),jP(U),m.stopTraining_)break}A.dispose()}if(yield x.onEpochEnd(I,k),m.stopTraining_)break}return yield x.onTrainEnd(),yield m.history.syncData(),m.history})()}fitDataset(e,r){var s=this;return J(function*(){return function pie(n,t,e){return cT.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return J(function*(){const o=yield s.standardizeUserData(e,r),i=o[0],a=o[1],u=s.makeTrainFunction()(i.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return ut(u),gi(o[0],e),gi(o[1],r),Es(c)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<o.length;++a)s&&!o[a].trainable||r.push({name:o[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=q2().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-q2().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Sa(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Sa(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const o of r){if("string"!=typeof s[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=Sa(s[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Sa(P1(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Sa(P1(e)));{const e={};for(const r in this.metrics)e[r]=Sa(P1(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=Na(iT(e.optimizer_config));let o,i;if("string"==typeof e.loss)o=_u(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>_u(a));else if(null!=e.loss){o={};for(const a in e.loss)o[a]=_u(e.loss[a])}if(Array.isArray(e.metrics))i=e.metrics.map(a=>_u(a));else if(null!=e.metrics){i={};for(const a in e.metrics)i[a]=_u(e.metrics[a])}this.compile({loss:o,metrics:i,optimizer:s})}save(e,r){var s=this;return J(function*(){if("string"==typeof e){const d=jO(e);if(0===d.length)throw new z(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new z(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield K2(s.getNamedWeights(r)),u={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.22.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){u.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield K2(yield s.optimizer.getWeights(),d);o.specs.push(...f),o.data=zO([o.data,h])}return null!=s.userDefinedMetadata&&(t4(s.userDefinedMetadata,s.name,!0),u.userDefinedMetadata=s.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})()}setUserDefinedMetadata(e){t4(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();he(xd),he((()=>{class n extends xd{}return n.className="Functional",n})());let f4=(()=>{class n extends xd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:x1("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new z(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof xd;let s;if(r){if(s=e,1!==s.outputs.length)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function zP(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new Op({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=BP(this.outputs[0])}this.inboundNodes=[],new _1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Iu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Gt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new xd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new $o("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return J(function*(){if(!s.built)throw new $o("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var o=this;return J(function*(){if(!o.built)throw new $o("The model needs to be compiled before being used.");return o.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return J(function*(){if(!s.built)throw new $o("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return J(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},o=!1){let i,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new z("Legacy serialization format not supported yet.");i=r}else _(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof n))throw new vt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const d=Na(u,void 0,o);o&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return n.className="Sequential",n})();function vT(n){return new f4(n)}he(f4);class Jr extends od{getConfig(){return{}}}he((()=>{class n extends Jr{apply(e,r=1){return function doe(n,t=1){if(1!==t)throw new vt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return gp(n)}(e,r)}}return n.className="elu",n})()),he((()=>{class n extends Jr{apply(e){return JS(e)}}return n.className="selu",n})()),he((()=>{class n extends Jr{apply(e){return Mi(e)}}return n.className="relu",n})()),he((()=>{class n extends Jr{apply(e){return H(()=>Su(6,Mi(e)))}}return n.className="relu6",n})()),he((()=>{class n extends Jr{apply(e){return e}}return n.className="linear",n})()),he((()=>{class n extends Jr{apply(e){return ci(e)}}return n.className="sigmoid",n})()),he((()=>{class n extends Jr{apply(e){return function foe(n){return H(()=>{const t=ue(.5,L(.2,n));return Ts(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),he((()=>{class n extends Jr{apply(e){return hd(e)}}return n.className="softplus",n})()),he((()=>{class n extends Jr{apply(e){return function hoe(n){return H(()=>Ee(n,ue(fr(n),1)))}(e)}}return n.className="softsign",n})()),he((()=>{class n extends Jr{apply(e){return xu(e)}}return n.className="tanh",n})());let p4=(()=>{class n extends Jr{apply(e,r=-1){return u1(e,r)}}return n.className="softmax",n})();function Cl(n){return n.getClassName()}function wT(n,t={}){return Ep(n,Ao.getMap().classNameMap,t,"activation")}function Sl(n){if(null==n){return wT({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},wT(t)}return n instanceof Jr?n:wT(n)}he(p4),he((()=>{class n extends Jr{apply(e,r=-1){return zS(e,r)}}return n.className="logSoftmax",n})()),he((()=>{class n extends Jr{apply(e){return H(()=>H(()=>{const r=Math.sqrt(2),s=L(.5,ue(1,$S(Ee(e,r))));return L(e,s)}))}}return n.className="gelu",n})()),he((()=>{class n extends Jr{apply(e){return H(()=>L(.5,L(e,ue(1,xu(L($r(Ee(2,Math.PI)),ue(e,L(.044715,ga(e,3)))))))))}}return n.className="gelu_new",n})()),he((()=>{class n extends Jr{apply(e){return H(()=>L(e,xu(hd(e))))}}return n.className="mish",n})()),he((()=>{class n extends Jr{apply(e,r=1){return H(()=>L(ci(L(e,r)),e))}}return n.className="swish",n})());class m4 extends od{}he((()=>{class n extends m4{constructor(e){super(),function xT(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return H(()=>{let r=ar([1]);return this.hasL1&&(r=ue(r,$e(L(this.l1,fr(e))))),this.hasL2&&(r=ue(r,$e(L(this.l2,Ap(e))))),V(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const g4={l1l2:"L1L2"};function dn(n){return HN(n)}function y4(n,t={}){return Ep(n,Ao.getMap().classNameMap,t,"regularizer")}function Dn(n){return null==n?null:"string"==typeof n?y4({className:n in g4?g4[n]:n,config:{}}):n instanceof m4?n:y4(n)}function Cd(n,t,e){if("number"==typeof n)return Iu(n,t);if(n.length!==t)throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const s=n[r];if(!ooe(s))throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function yi(n,t,e,r,s=1){if(null==n)return n;let i;return i="same"===e?n:n-(t+(t-1)*(s-1))+1,Math.floor((i+r-1)/r)}function Wi(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+vl([e-t,0]);else{if("same"!==r)throw new z(`Unsupport padding mode: ${r}.`);n*=t}return n}function ST(n,t){return H(()=>(er(t),"channelsFirst"===t?$t(n,[0,2,3,1]):n))}function N4(n,t){return H(()=>(er(t),"channelsFirst"===t?$t(n,[0,2,3,4,1]):n))}function NT(n,t,e,r=[1,1],s="valid",o,i,a=null){return H(()=>{if(null==o&&(o="channelsLast"),er(o),3!==n.rank&&4!==n.rank)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=ST(n,o);if("causal"===s)throw new vt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=NM({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===o&&(l=$t(l,[0,3,1,2])),l})}he((()=>{class n extends Ot{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=st(e);let s=Mi(e);return null!=this.maxValue&&(s=Ts(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),he((()=>{class n extends Ot{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=st(e);return J0(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),he((()=>{class n extends Ot{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=En(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Dn(e.alphaRegularizer),this.alphaConstraint=br(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Gt(e)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let o=1;o<e.length;++o)s[o]=e[o];this.inputSpec=[new gr({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=st(e),o1(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ln(this.alphaInitializer),alphaRegularizer:dn(this.alphaRegularizer),alphaConstraint:yr(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),he((()=>{class n extends Ot{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new vt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=st(e);return gp(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),he((()=>{class n extends Ot{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=e.theta??this.DEFAULT_THETA}call(e,r){const s=st(e);return L(s,Ce(Ws(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),he((()=>{class n extends Ot{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new p4).apply,this.axis=e.axis??this.DEFAULT_AXIS}call(e,r){return H(()=>{let s=st(e);const o=r.mask;if(null!=o){const i=L(De(Is(s.shape),Ce(o,s.dtype)),Ke(-1e9));s=ue(s,i)}return this.axis instanceof Array?this.axis.length>1?ls(De(s,Y0(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class $1 extends Ot{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$1.verifyArgs(e),this.rank=t,Or(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new vt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Cd(e.kernelSize,t,"kernelSize"),this.strides=Cd(e.strides??1,t,"strides"),this.padding=e.padding??"valid",fo(this.padding),this.dataFormat=e.dataFormat??"channelsLast",er(this.dataFormat),this.activation=Sl(e.activation),this.useBias=e.useBias??!0,this.biasInitializer=En(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=br(e.biasConstraint),this.biasRegularizer=Dn(e.biasRegularizer),this.activityRegularizer=Dn(e.activityRegularizer),this.dilationRate=Cd(e.dilationRate??1,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(ho("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!GN(t.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Cl(this.activation),useBias:this.useBias,biasInitializer:Ln(this.biasInitializer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),biasConstraint:yr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Sd extends $1{constructor(t,e){super(t,e),this.kernel=null,Sd.verifyArgs(e),this.filters=e.filters,Or(this.filters,"filters"),this.kernelInitializer=En(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=br(e.kernelConstraint),this.kernelRegularizer=Dn(e.kernelRegularizer)}build(t){t=Gt(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new z(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return H(()=>{let r;t=st(t);const s=null==this.bias?null:this.bias.read(),o=vP(this.activation.getClassName());if(null!=o&&2===this.rank)r=NT(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function T4(n,t,e,r=1,s="valid",o,i=1){return H(()=>{if(null==o&&(o="channelsLast"),er(o),3!==n.shape.length)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===o&&(n=$t(n,[0,2,1])),"causal"===s)throw new vt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=RS(n,t,r,"same"===s?"same":"valid","NWC",i);return null!=e&&(a=pi(a,e)),a})}(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=NT(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new vt("convolutions greater than 3D are not implemented yet.");r=function I4(n,t,e,r=[1,1,1],s="valid",o,i){return H(()=>{if(null==o&&(o="channelsLast"),er(o),4!==n.rank&&5!==n.rank)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=N4(n,o);if("causal"===s)throw new vt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=jF(a,t,r,"same"===s?"same":"valid","NDHWC",i),null!=e&&(a=pi(a,e)),"channelsFirst"===o&&(a=$t(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Gt(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<r.length;++o){const i=yi(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);e.push(i)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:Ln(this.kernelInitializer),kernelRegularizer:dn(this.kernelRegularizer),kernelConstraint:yr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let TT=(()=>{class n extends Sd{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!GN(e.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();he(TT);let IT=(()=>{class n extends Sd{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();he(IT),he((()=>{class n extends TT{constructor(e){if(super(e),this.inputSpec=[new gr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Gt(e)).length)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gr({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return H(()=>{let s=st(e);if(4!==s.shape.length)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=o[l],h=this.kernelSize[1],p=this.strides[1],y=[o[0],Wi(o[a],this.strides[0],this.kernelSize[0],this.padding),Wi(c,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=$t(s,[0,2,3,1]));let v=FS(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(v=$t(v,[0,3,1,2])),null!=this.bias&&(v=pi(v,this.bias.read(),this.dataFormat)),null!=this.activation&&(v=this.activation.apply(v)),v})}computeOutputShape(e){const r=(e=Gt(e)).slice();let s,o,i;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3):(s=3,o=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[s]=this.filters,r[o]=Wi(r[o],u,a,this.padding),r[i]=Wi(r[i],c,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),he((()=>{class n extends IT{constructor(e){if(super(e),this.inputSpec=[new gr({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Gt(e)).length)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gr({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return H(()=>{let s=st(e);if(5!==s.shape.length)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l,u;"channelsFirst"===this.dataFormat?(u=2,a=3,l=4):(u=1,a=2,l=3);const d=o[a],h=o[l],p=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[1],v=this.strides[2],I=[o[0],Wi(o[u],this.strides[0],this.kernelSize[0],this.padding),Wi(d,y,p,this.padding),Wi(h,v,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=$t(s,[0,2,3,4,1]));let k=qF(s,this.kernel.read(),I,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(k=$t(k,[0,4,1,2,3])),null!==this.bias&&(k=pi(k,this.bias.read(),this.dataFormat)),null!==this.activation&&(k=this.activation.apply(k)),k})}computeOutputShape(e){const r=(e=Gt(e)).slice();let s,o,i,a;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3,a=4):(s=4,o=1,i=2,a=3);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],f=this.strides[2];return r[s]=this.filters,r[o]=Wi(r[o],d,l,this.padding),r[i]=Wi(r[i],h,u,this.padding),r[a]=Wi(r[a],f,c,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let Tie=(()=>{class n extends Sd{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier??1,this.depthwiseInitializer=En(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Dn(r.depthwiseRegularizer),this.depthwiseConstraint=br(r.depthwiseConstraint),this.pointwiseInitializer=En(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Dn(r.pointwiseRegularizer),this.pointwiseConstraint=br(r.pointwiseConstraint)}build(e){if((e=Gt(e)).length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new gr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return H(()=>{let s;if(e=st(e),1===this.rank)throw new vt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=$t(e,[0,2,3,1])),s=ZS(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=pi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=$t(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ln(this.depthwiseInitializer),e.pointwiseInitializer=Ln(this.pointwiseInitializer),e.depthwiseRegularizer=dn(this.depthwiseRegularizer),e.pointwiseRegularizer=dn(this.pointwiseRegularizer),e.depthwiseConstraint=yr(this.depthwiseConstraint),e.pointwiseConstraint=yr(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function F4(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new z("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:n,initialState:t=s(t),constants:e=s(e)}}function M4(n,t,e,r=!1,s,o,i=!1,a=!1){return H(()=>{const l=t.shape.length;if(l<3)throw new z(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(hi(2,l));if(t=$t(t,u),null!=o)throw new vt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=Ce(Ce(s,"bool"),"float32")).rank===l-1&&(s=zr(s,-1)),s=$t(s,u)),r&&(t=Mo(t,0),null!=s&&(s=Mo(s,0)));const c=[];let d,h=e;const f=t.shape[0],p=Po(t);let g,m;null!=s&&(g=Po(s));for(let y=0;y<f;++y){const v=p[y],w=H(()=>n(v,h));if(null==s)d=w[0],h=w[1];else{const x=H(()=>{const N=g[y],I=De(co(N),N);return{output:ue(L(w[0],N),L(h[0],I)),newStates:h.map((R,F)=>ue(L(w[1][F],N),L(R,I)))}});d=x.output,h=x.newStates}a&&c.push(d)}return a&&(m=_s(c,1)),[d,m,h]})}he((()=>{class n extends Tie{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),he((()=>{class n extends Sd{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!GN(e.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return H(()=>{if(e=st(e),"channelsLast"===this.dataFormat){const s=S1(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return S1(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=S1(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return S1(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size??this.DEFAULT_SIZE,this.dataFormat=e.dataFormat??"channelsLast",er(this.dataFormat),this.interpolation=e.interpolation??"nearest",function noe(n){Eu(Yse,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return H(()=>{let s=st(e);const o=s.shape;if("channelsFirst"===this.dataFormat){s=$t(s,[0,2,3,1]);const i=this.size[0]*o[2],a=this.size[1]*o[3],l="nearest"===this.interpolation?Ur.resizeNearestNeighbor(s,[i,a]):Ur.resizeBilinear(s,[i,a]);return $t(l,[0,3,1,2])}{const i=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?Ur.resizeNearestNeighbor(s,[i,a]):Ur.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),he((()=>{class n extends $1{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier??1,this.depthwiseInitializer=En(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=br(e.depthwiseConstraint),this.depthwiseRegularizer=Dn(e.depthwiseRegularizer)}build(e){if((e=Gt(e)).length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return H(()=>{let s=function Iie(n,t,e=[1,1],r="valid",s,o){return H(()=>{null==s&&(s="channelsLast"),er(s);let i=ST(n,s);if(4!==n.rank)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=mp(i,t,e,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===s&&(i=$t(i,[0,3,1,2])),i})}(e=st(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=pi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Gt(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=yi("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=yi(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,i,a]:[e[0],i,a,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ln(this.depthwiseInitializer),e.depthwiseRegularizer=dn(this.depthwiseRegularizer),e.depthwiseConstraint=yr(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let Nd=(()=>{class n extends Ot{constructor(e){let r;if(super(e),null==e.cell)throw new z("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new DT({cells:e.cell}):e.cell,null==r.stateSize)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences??!1,this.returnState=e.returnState??!1,this.goBackwards=e.goBackwards??!1,this._stateful=e.stateful??!1,this.unroll=e.unroll??!1,this.supportsMasking=!0,this.inputSpec=[new gr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return this.states_??hi(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null)}setStates(e){this.states_=e}computeOutputShape(e){ZN(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let o;if(o=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const i=[];for(const a of r)i.push([e[0],a]);return[o].concat(i)}return o}computeMask(e,r){return H(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new vt("Constants support is not implemented in RNN yet.");ZN(e)&&(e=e[0]);const s=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new gr({shape:[s,null,...o]});const i=[e[0]].concat(e.slice(2));let a;if(this.cell.build(i),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Pt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new gr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){H(()=>{if(!this.stateful)throw new $i("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>ar([s,o])):[ar([s,this.cell.stateSize])];else if(null==e)ut(this.states_),null!=this.keptStates&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ar([s,o])):this.states_[0]=ar([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let o=0;o<this.states_.length;++o){const i=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,l=[s,a];if(!Pt(i.shape,l))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>kr(o.clone()))})}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=F4(e,s,o,this.numConstants);e=i.inputs,s=i.initialState,o=i.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new gr({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof Ui){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return H(()=>{const s=null==r?null:r.mask,o=null==r?null:r.training;let i=null==r?null:r.initialState;e=st(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new z(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:o},c=M4((g,m)=>{const y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,o);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return H(()=>{let r=ar(e.shape);return r=$e(r,[1,2]),r=kp(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?XN(r,[1,s]):r):this.cell.stateSize>1?[XN(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const i=Na(r.cell,s);return new e(Object.assign(r,{cell:i}))}}return n.className="RNN",n})();he(Nd);class V1 extends Ot{}let _T=(()=>{class n extends V1{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Or(this.units,"units"),this.activation=Sl(e.activation??this.DEFAULT_ACTIVATION),this.useBias=e.useBias??!0,this.kernelInitializer=En(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=En(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=En(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Dn(e.kernelRegularizer),this.recurrentRegularizer=Dn(e.recurrentRegularizer),this.biasRegularizer=Dn(e.biasRegularizer),this.kernelConstraint=br(e.kernelConstraint),this.recurrentConstraint=br(e.recurrentConstraint),this.biasConstraint=br(e.biasConstraint),this.dropout=vd([1,vl([0,e.dropout??0])]),this.recurrentDropout=vd([1,vl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Gt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return H(()=>{if(2!==e.length)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const o=r.training??!1;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Nl({ones:()=>co(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Nl({ones:()=>co(s),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;i=Bi(null!=a?L(e,a):e,this.kernel.read()),null!=this.bias&&(i=pi(i,this.bias.read())),null!=l&&(s=L(s,l));let u=ue(i,Bi(s,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Cl(this.activation),useBias:this.useBias,kernelInitializer:Ln(this.kernelInitializer),recurrentInitializer:Ln(this.recurrentInitializer),biasInitializer:Ln(this.biasInitializer),kernelRegularizer:dn(this.kernelRegularizer),recurrentRegularizer:dn(this.recurrentRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),recurrentConstraint:yr(this.recurrentConstraint),biasConstraint:yr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();he(_T),he((()=>{class n extends Nd{constructor(e){e.cell=new _T(e),super(e)}call(e,r){return H(()=>(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let ET=(()=>{class n extends V1{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Or(this.units,"units"),this.activation=Sl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Sl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=En(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=En(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=En(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Dn(e.kernelRegularizer),this.recurrentRegularizer=Dn(e.recurrentRegularizer),this.biasRegularizer=Dn(e.biasRegularizer),this.kernelConstraint=br(e.kernelConstraint),this.recurrentConstraint=br(e.recurrentConstraint),this.biasConstraint=br(e.biasConstraint),this.dropout=vd([1,vl([0,e.dropout??0])]),this.recurrentDropout=vd([1,vl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Gt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return H(()=>{if(2!==e.length)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training??!1;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Nl({ones:()=>co(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Nl({ones:()=>co(o),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=L(e,this.dropoutMask[0]));let d=Bi(e,this.kernel.read());this.useBias&&(d=pi(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=L(o,a[0]));const h=this.recurrentKernel.read(),[f,p]=Hs(h,[2*this.units,this.units],h.rank-1),g=Bi(o,f),[m,y,v]=Hs(d,3,d.rank-1),[w,x]=Hs(g,2,g.rank-1);l=this.recurrentActivation.apply(ue(m,w)),u=this.recurrentActivation.apply(ue(y,x));const N=Bi(L(u,o),p);c=this.activation.apply(ue(v,N));const I=ue(L(l,o),L(ue(1,In(l)),c));return[I,I]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Cl(this.activation),recurrentActivation:Cl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ln(this.kernelInitializer),recurrentInitializer:Ln(this.recurrentInitializer),biasInitializer:Ln(this.biasInitializer),kernelRegularizer:dn(this.kernelRegularizer),recurrentRegularizer:dn(this.recurrentRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),recurrentConstraint:yr(this.recurrentConstraint),biasConstraint:yr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();he(ET),he((()=>{class n extends Nd{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ET(e),super(e)}call(e,r){return H(()=>(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let B1=(()=>{class n extends V1{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Or(this.units,"units"),this.activation=Sl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Sl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=En(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=En(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=En(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Dn(e.kernelRegularizer),this.recurrentRegularizer=Dn(e.recurrentRegularizer),this.biasRegularizer=Dn(e.biasRegularizer),this.kernelConstraint=br(e.kernelConstraint),this.recurrentConstraint=br(e.recurrentConstraint),this.biasConstraint=br(e.biasConstraint),this.dropout=vd([1,vl([0,e.dropout??0])]),this.recurrentDropout=vd([1,vl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let o;if(e=Gt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;o=new((r=class extends Bo{apply(u,c){const d=i.apply([a]),h=(new kP).apply([a]),f=i.apply([2*a]);return _P(_P(d,h),f)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return H(()=>{const s=r.training??!1;if(3!==e.length)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Nl({ones:()=>co(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Nl({ones:()=>co(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=L(e,this.dropoutMask[0]));let f=Bi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=L(o,l[0])),f=ue(f,Bi(o,this.recurrentKernel.read())),this.useBias&&(f=pi(f,this.bias.read()));const[p,g,m,y]=Hs(f,4,f.rank-1);u=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(g),d=ue(L(c,i),L(u,this.activation.apply(m))),h=this.recurrentActivation.apply(y);const v=L(h,this.activation.apply(d));return[v,v,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Cl(this.activation),recurrentActivation:Cl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ln(this.kernelInitializer),recurrentInitializer:Ln(this.recurrentInitializer),biasInitializer:Ln(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:dn(this.kernelRegularizer),recurrentRegularizer:dn(this.recurrentRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),recurrentConstraint:yr(this.recurrentConstraint),biasConstraint:yr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();he(B1),he((()=>{class n extends Nd{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new B1(e),super(e)}call(e,r){return H(()=>(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let DT=(()=>{class n extends V1{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return H(()=>{let s=e.slice(1);const o=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?o.push(s.splice(0,l.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=o[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=u.call(a,r),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;ZN(e)&&(e=e[0]),this.cells.forEach((s,o)=>{Du(`RNNCell_${o}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),o={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign(Object.assign({},e),o)}static fromConfig(e,r,s={}){const o=[];for(const i of r.cells)o.push(Na(i,s));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return YN(e)}setWeights(e){const r=[];for(const s of this.cells){const i=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],i[a]])}QN(r)}}return n.className="StackedRNNCells",n})();function Nl(n){const{ones:t,rate:e,training:r=!1,count:s=1,dropoutFunc:o}=n,i=()=>null!=o?o(t(),e):DP(t(),e),a=()=>Rp(i,t,r);return!s||s<=1?kr(a().clone()):Array(s).fill(void 0).map(a).map(u=>kr(u.clone()))}he(DT);let Eie=(()=>{class n extends Nd{constructor(e){if(e.unroll)throw new vt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new vt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new gr({ndim:5})]}call(e,r){return H(()=>{if(null!=this.cell.dropoutMask&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new z("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return H(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(e.shape),a=ar([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){H(()=>{if(!this.stateful)throw new $i("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(null==s[0])throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>ar(i)):[ar(i)];else if(null==e)ut(this.states_),null!=this.keptStates&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ar(i)):this.states_[0]=ar(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=i;if(!Pt(u.shape,c))throw new z(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>kr(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:o,padding:i,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===r,d=e[u?4:3],h=yi(e[u?3:2],o[0],i,a[0],l[0]),f=yi(d,o[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[s,h,f]:[h,f,s]]}}return n.className="ConvRNN2D",n})(),kT=(()=>{class n extends B1{constructor(e){const{filters:r,kernelSize:s,strides:o,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Or(this.filters,"filters"),this.kernelSize=Cd(s,2,"kernelSize"),this.kernelSize.forEach(u=>Or(u,"kernelSize")),this.strides=Cd(o||1,2,"strides"),this.strides.forEach(u=>Or(u,"strides")),this.padding=i||"valid",fo(this.padding),this.dataFormat=a||"channelsLast",er(this.dataFormat),this.dilationRate=Cd(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Or(u,"dilationRate"))}build(e){var r;e=Gt(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new z(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((r=class extends Bo{apply(f,p){return KN([c.apply([d]),Is([d]),c.apply([2*d])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return H(()=>{if(3!==e.length)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,o=e[0],i=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Nl({ones:()=>co(o),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(me,we,ye)=>we&&we[ye]?L(we[ye],me):me;let d=c(o,u,0),h=c(o,u,1),f=c(o,u,2),p=c(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Nl({ones:()=>co(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let m=c(i,g,0),y=c(i,g,1),v=c(i,g,2),w=c(i,g,3);const[N,I,k,A]=Hs(this.kernel.read(),4,3),[R,F,U,q]=this.useBias?Hs(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,N,R,this.padding),h=this.inputConv(h,I,F,this.padding),f=this.inputConv(f,k,U,this.padding),p=this.inputConv(p,A,q,this.padding);const[K,Y,Q,se]=Hs(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,K),y=this.recurrentConv(y,Y),v=this.recurrentConv(v,Q),w=this.recurrentConv(w,se);const ie=this.recurrentActivation.apply(ue(d,m)),te=this.recurrentActivation.apply(ue(h,y)),ae=ue(L(te,a),L(ie,this.activation.apply(ue(f,v)))),pe=L(this.recurrentActivation.apply(ue(p,w)),this.activation.apply(ae));return[pe,pe,ae]})}getConfig(){const s=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]])}return e}(super.getConfig(),["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),o)}inputConv(e,r,s,o){const i=fl(e,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?pi(i,s,this.dataFormat):i}recurrentConv(e,r){return fl(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();he(kT),he((()=>{class n extends Eie{constructor(e){const r=new kT(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let AT=(()=>{class n extends Ot{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(this.noiseShape[o]??r[o]);return s}call(e,r){return H(()=>{this.invokeCallHook(e,r);const s=st(e);if(0<this.rate&&this.rate<1){const o=r.training??!1,i=this.getNoiseShape(s);return Rp(()=>DP(s,this.rate,i,this.seed),()=>s,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();he(AT),he((()=>{class n extends AT{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})());let z4=(()=>{class n extends Ot{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Or(this.units,"units"),this.activation=Sl(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=En(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=En(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=br(e.kernelConstraint),this.biasConstraint=br(e.biasConstraint),this.kernelRegularizer=Dn(e.kernelRegularizer),this.biasRegularizer=Dn(e.biasRegularizer),this.activityRegularizer=Dn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Gt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Gt(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return H(()=>{this.invokeCallHook(e,r);const s=st(e),o=vP(this.activation.getClassName());let i;return null!=o?i=Bi(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=Bi(s,this.kernel.read()),null!=this.bias&&(i=pi(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Cl(this.activation),useBias:this.useBias,kernelInitializer:Ln(this.kernelInitializer),biasInitializer:Ln(this.biasInitializer),kernelRegularizer:dn(this.kernelRegularizer),biasRegularizer:dn(this.biasRegularizer),activityRegularizer:dn(this.activityRegularizer),kernelConstraint:yr(this.kernelConstraint),biasConstraint:yr(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})();he(z4);let U4=(()=>{class n extends Ot{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Gt(e);for(const r of e.slice(1))if(null==r)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],bl(e,1)]}call(e,r){return H(()=>{this.invokeCallHook(e,r);let s=st(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=$t(s,o)}return function coe(n){if(n.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],bl(n.shape,1)];return V(n,t)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})();he(U4),he((()=>{class n extends Ot{constructor(e){super(e),this.supportsMasking=!0,this.activation=Sl(e.activation)}call(e,r){return H(()=>{this.invokeCallHook(e,r);const s=st(e);return this.activation.apply(s)})}getConfig(){const e={activation:Cl(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return H(()=>function loe(n,t){return H(()=>{if(2!==n.shape.length)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return XN(kp(n,1),[1,t,1])})}(e=st(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",o=r.slice();let i=1,a=null;for(let u=0;u<o.length;++u){const c=o[u];if(this.isUnknown(c)){if(null!==a)throw new z("Can only specifiy one unknown dimension.");a=u}else i*=c}const l=bl(e);if(null!==a){if(0===i||l%i!=0)throw new z(s);o[a]=l/i}else if(l!==i)throw new z(s);return o}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return H(()=>{this.invokeCallHook(e,r);const s=st(e),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return V(s,i)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),he((()=>{class n extends Ot{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=hi(1,e.dims.length+1);if(!Pt(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new gr({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Gt(e)).slice();return this.dims.forEach((s,o)=>{r[o+1]=e[s]}),r}call(e,r){return $t(st(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),he((()=>{class n extends Ot{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?e.maskValue??0:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=st(e);return H0(fd(s,this.maskValue),-1)}call(e,r){return H(()=>{this.invokeCallHook(e,r);const s=st(e),a=H0(fd(s,this.maskValue),-1,!0);return L(s,Ce(a,s.dtype))})}}return n.className="Masking",n})()),he((()=>{class n extends Ot{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(Jt(e.inputLength))}this.inputDim=e.inputDim,Or(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Or(this.outputDim,"outputDim"),this.embeddingsInitializer=En(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Dn(e.embeddingsRegularizer),this.activityRegularizer=Dn(e.activityRegularizer),this.embeddingsConstraint=br(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return H(()=>this.maskZero?(e=st(e),fd(e,Lt(e))):null)}computeOutputShape(e){if(e=Gt(e),null==this.inputLength)return[...e,this.outputDim];const r=Jt(this.inputLength);if(r.length!==e.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let o=0;o<r.length;++o){const i=r[o],a=e[o+1];if(null!=i&&null!=a&&i!==a)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return H(()=>{this.invokeCallHook(e,r);let s=st(e);"int32"!==s.dtype&&(s=Vi(s,"int32"));const o=EP(this.embeddings.read(),V(s,[s.size]));return V(o,Gt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ln(this.embeddingsInitializer),embeddingsRegularizer:dn(this.embeddingsRegularizer),activityRegularizer:dn(this.activityRegularizer),embeddingsConstraint:yr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class Au extends Ot{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new vt}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const o=t[t.length-e.length+s],i=e[s];if(null==o||null==i||o<0||i<0)r.push(null);else if(1===o)r.push(i);else if(1===i)r.push(o);else{if(o!==i)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(o)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Gt(t)]),t.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const o of t)null!=o&&null!==o[0]&&e.push(o[0]);if(e=yl(e),e.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let o=1;o<t.length;++o){const i=null==t[o]?null:t[o].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=t.map(o=>o.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==yl(s).length}call(t,e){return H(()=>{if(this.reshapeRequired){const r=[],s=t.map(o=>o.rank);if(-1===s.indexOf(null)){const o=vl(s);for(let i of t){const a=i.rank;for(let l=0;l<o-a;++l)i=kp(i,1);r.push(i)}return this.mergeFunction(r)}{let o=!1;for(const l of t){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let f=V(l,[d].concat(bl(c.slice(1))));f=$t(f,[1,0]),f=V(f,h),r.push(f),o=!0}else if(u>1){const c=hi(1,u).concat([0]);r.push($t(l,c)),o=!0}else r.push(l)}let i=this.mergeFunction(r);const a=i.rank;if(o)if(null==a){const l=i.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));i=V($t(V(i,[-1,c]),[1,0]),d)}else if(a>1){const l=[a-1].concat(hi(0,a-1));i=$t(i,l)}return i}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const o=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let r=[];for(const s of t)null!=s&&null!==s[0]&&r.push(s[0]);return r=yl(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return H(()=>{if(null==e)return null;if(!Array.isArray(e))throw new z("`mask` should be an Array");if(!Array.isArray(t))throw new z("`inputs` should be an Array");if(e.length!==t.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:zr(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Fi(r,e[s]);return r})}}function $p(n,t){for(;n<0;)n+=t;return n}function Vp(n,t,e,r,s,o=.001){let i;if(2===n.rank)i=PF(n,t,e,r,s,o);else if(3===n.rank)i=LF(n,t,e,r,s,o);else{if(4!==n.rank)throw new vt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);i=$F(n,t,e,r,s,o)}return i}function q1(n,t,e,r,s,o){return H(()=>{let i;er(s),xP(o),fo(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),n=ST(n,s);const a="same"===r?"same":"valid";return i="max"===o?t1(n,t,e,a):j0(n,t,e,a),"channelsFirst"===s&&(i=$t(i,[0,3,1,2])),i})}function nL(n,t,e,r,s,o){return H(()=>{let i;er(s),xP(o),fo(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),n=N4(n,s);const a="same"===r?"same":"valid";return i="max"===o?lM(n,t,e,a):MF(n,t,e,a),"channelsFirst"===s&&(i=$t(i,[0,4,1,2,3])),i})}he((()=>{class n extends Au{constructor(e){super(e)}mergeFunction(e){return H(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=ue(r,e[s]);return r})}}return n.className="Add",n})()),he((()=>{class n extends Au{constructor(e){super(e)}mergeFunction(e){return H(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=L(r,e[s]);return r})}}return n.className="Multiply",n})()),he((()=>{class n extends Au{constructor(e){super(e)}mergeFunction(e){return H(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=ue(r,e[s]);return L(1/e.length,r)})}}return n.className="Average",n})()),he((()=>{class n extends Au{constructor(e){super(e)}mergeFunction(e){return H(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=ya(r,e[s]);return r})}}return n.className="Maximum",n})()),he((()=>{class n extends Au{constructor(e){super(e)}mergeFunction(e){return H(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Su(r,e[s]);return r})}}return n.className="Minimum",n})()),he((()=>{class n extends Au{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=e.axis??this.DEFAULT_AXIS,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of e)if(null!=o){r=!1;break}if(r)return;const s=[];for(let o=0;o<e.length;++o){const i=e[o].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(Pt(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return H(()=>KN(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new z("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of r.slice(1)){if(null==s[o]||null==i[o]){s[o]=null;break}s[o]+=i[o]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new z("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new z(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return H(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const o=[];for(let a=0;a<e.length;++a)o.push(null==r[a]?Ce(co(e[a]),"bool"):r[a].rank<e[a].rank?zr(r[a],-1):r[a]);const i=_n(o,this.axis);return DS(i,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),he((()=>{class n extends Au{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize??!1,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){_(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new vt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);if(r[o[0]]!==s[o[1]])throw new z(`Dimension incompatibility: ${r[o[0]]} !== ${s[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let o,r=e[0],s=e[1];return o=Array.isArray(this.axes)?this.axes.map((i,a)=>$p(i,e[a].shape.length)):[$p(this.axes,r.shape.length),$p(this.axes,s.shape.length)],this.normalize&&(r=k1(r,o[0]),s=k1(s,o[1])),function Die(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new vt("batchDot is not implemented for tensors of 4D or higher rank yet");if(_(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),_(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new vt("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=t.shape.length;null==e&&(e=[r-1,s-2]);const o=e;return H(()=>{let i,a;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);t=V(t,t.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);n=V(n,n.shape.concat(l))}else i=0;if(a=2===n.shape.length&&2===t.shape.length?o[0]===o[1]?$e(L(n,t),o[0]):$e(L($t(n,[1,0]),t),o[1]):Ft(n,t,o[0]!==n.shape.length-1,o[1]===t.shape.length-1),i>0){let l;l=r>s?r+s-3:r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=Yn(a,u)}return 1===a.shape.length&&(a=zr(a,1)),a})}(r,s,o)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[$p(this.axes,e.length),$p(this.axes,r.length)],s}computeOutputShape(e){_(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new vt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);r.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=r.concat(s);return 1===i.length&&i.push(1),i}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return H(()=>{this.invokeCallHook(e,r);const s=st(e);return Rp(()=>ue(N1(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return n.className="GaussianNoise",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return H(()=>{this.invokeCallHook(e,r);const s=st(e);return this.rate>0&&this.rate<1?Rp(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return L(s,N1(s.shape,1,i))},()=>s,r.training||!1):s})}}return n.className="GaussianDropout",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||st(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return H(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Rp(()=>{const i=st(e),u=-1.7580993408473766;let c=ml(Nu(s),this.rate);c=Vi(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,f=ue(L(i,c),L(ue(c,-1),u));return ue(L(f,d),h)},()=>st(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),he((()=>{class n extends Ot{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis??-1,this.momentum=e.momentum??.99,this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=En(e.betaInitializer||"zeros"),this.gammaInitializer=En(e.gammaInitializer||"ones"),this.movingMeanInitializer=En(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=En(e.movingVarianceInitializer||"ones"),this.betaConstraint=br(e.betaConstraint),this.gammaConstraint=br(e.gammaConstraint),this.betaRegularizer=Dn(e.betaRegularizer),this.gammaRegularizer=Dn(e.gammaRegularizer)}build(e){e=Gt(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new z(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new gr({ndim:e.length,axes:{[r]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return H(()=>{const s=r.training??!1,o=st(e),i=o.shape,a=i.length,l=hi(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=Iu(1,a);c[u]=i[u];const d=l.slice();d.sort();const h=!Pt(d,hi(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const w=V(this.movingMean.read(),c),x=V(this.movingVariance.read(),c),N=this.center?V(this.beta.read(),c):null,I=this.scale?V(this.gamma.read(),c):null;return Vp(o,w,x,N,I,this.epsilon)}return Vp(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,g,m]=function Rie(n,t,e,r,s=.001){return Pt(r.slice().sort(),hi(0,n.rank-1))?function kie(n,t,e,r,s=.001){return H(()=>{const o=n1(n,r),i=o.mean,a=o.variance;return[Vp(n,i,a,e,t,s),i,a]})}(n,t,e,r,s):function Aie(n,t,e,r,s=.001){return H(()=>{const o=n1(n,r),i=o.mean,a=o.variance,l=[];for(const p of hi(0,n.rank))-1!==r.indexOf(p)?l.push(1):l.push(n.shape[p]);const u=V(i,l),c=V(a,l),d=null==t?null:V(t,l),h=null==e?null:V(e,l);return[Vp(n,u,c,h,d,s),i,a]})}(n,t,e,r,s)}(o,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(w,x,N)=>{H(()=>{const I=1-N,k=w.read(),A=L(De(k,x),I);w.write(De(k,A))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ln(this.betaInitializer),gammaInitializer:Ln(this.gammaInitializer),movingMeanInitializer:Ln(this.movingMeanInitializer),movingVarianceInitializer:Ln(this.movingVarianceInitializer),betaRegularizer:dn(this.betaRegularizer),gammaRegularizer:dn(this.gammaRegularizer),betaConstraint:yr(this.betaConstraint),gammaConstraint:yr(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),he((()=>{class n extends Ot{constructor(e){if(null==e&&(e={}),super(e),this.axis=e.axis??-1,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=En(e.betaInitializer||"zeros"),this.gammaInitializer=En(e.gammaInitializer||"ones"),this.betaRegularizer=Dn(e.betaRegularizer),this.gammaRegularizer=Dn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Gt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(const i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==yl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=st(e),o=s.shape,i=o.length;return H(()=>{let{mean:l,variance:u}=n1(s,this.axis,!0);const c=Iu(1,i);for(const m of this.axis)c[m]=o[m];const d=m=>null!=m&&m.shape.length!==i?V(m,c):m;let h=this.scale?d(this.gamma.read()):null,f=this.center?d(this.beta.read()):null;const p=[],g=[];for(let m=0;m<i;++m)-1!==this.axis.indexOf(m)?(p.push(o[m]),g.push(1)):(p.push(1),g.push(o[m]));return l=Fo(l,p),u=Fo(u,p),null!=h&&(h=Fo(h,g)),null!=f&&(f=Fo(f,g)),Vp(s,l,u,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ln(this.betaInitializer),gammaInitializer:Ln(this.gammaInitializer),betaRegularizer:dn(this.betaRegularizer),gammaRegularizer:dn(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),he((()=>{class n extends Ot{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=e.dataFormat??"channelsLast",null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new gr({ndim:4})]}computeOutputShape(e){let r,s;return e=Gt(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return H(()=>function Oie(n,t,e){return H(()=>{if(4!==n.rank)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new z(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],gl(n,r)})}(st(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class rL extends Ot{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Or(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Or(this.strides,"strides"),this.padding=t.padding??"valid",fo(this.padding),this.inputSpec=[new gr({ndim:3})]}computeOutputShape(t){const e=yi((t=Gt(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return H(()=>{this.invokeCallHook(t,e),t=kp(st(t),2);const r=this.poolingFunction(st(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Yn(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}he((()=>{class n extends rL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return er(i),fo(o),q1(e,r,s,o,i,"max")}}return n.className="MaxPooling1D",n})()),he((()=>{class n extends rL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return er(i),fo(o),q1(e,r,s,o,i,"avg")}}return n.className="AveragePooling1D",n})());class iL extends Ot{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Or(this.poolSize,"poolSize"),Or(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",er(this.dataFormat),fo(this.padding),this.inputSpec=[new gr({ndim:4})]}computeOutputShape(t){t=Gt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=yi(e,this.poolSize[0],this.padding,this.strides[0]),r=yi(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return H(()=>(this.invokeCallHook(t,e),this.poolingFunction(st(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let aL=(()=>{class n extends iL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return er(i),fo(o),q1(e,r,s,o,i,"max")}}return n.className="MaxPooling2D",n})();he(aL),he((()=>{class n extends iL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return er(i),fo(o),q1(e,r,s,o,i,"avg")}}return n.className="AveragePooling2D",n})());class uL extends Ot{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Or(this.poolSize,"poolSize"),Or(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",er(this.dataFormat),fo(this.padding),this.inputSpec=[new gr({ndim:5})]}computeOutputShape(t){t=Gt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=yi(e,this.poolSize[0],this.padding,this.strides[0]),r=yi(r,this.poolSize[1],this.padding,this.strides[1]),s=yi(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return H(()=>(this.invokeCallHook(t,e),this.poolingFunction(st(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}he((()=>{class n extends uL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return er(i),fo(o),nL(e,r,s,o,i,"max")}}return n.className="MaxPooling3D",n})()),he((()=>{class n extends uL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return er(i),fo(o),nL(e,r,s,o,i,"avg")}}return n.className="AveragePooling3D",n})());class hL extends Ot{constructor(t){super(t),this.inputSpec=[new gr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new vt}}he((()=>{class n extends hL{constructor(e){super(e||{})}call(e,r){return H(()=>{const s=st(e);return Hn(s,1)})}}return n.className="GlobalAveragePooling1D",n})()),he((()=>{class n extends hL{constructor(e){super(e||{})}call(e,r){return H(()=>{const s=st(e);return Oo(s,1)})}}return n.className="GlobalMaxPooling1D",n})());class mL extends Ot{constructor(t){super(t),this.dataFormat=t.dataFormat??"channelsLast",er(this.dataFormat),this.inputSpec=[new gr({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new vt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}he((()=>{class n extends mL{call(e,r){return H(()=>{const s=st(e);return Hn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),he((()=>{class n extends mL{call(e,r){return H(()=>{const s=st(e);return Oo(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class bL extends Ot{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const o=Na(e.layer,r);delete e.layer;const i={layer:o};return Object.assign(i,e),new t(i)}}he((()=>{class n extends bL{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Gt(e)).length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Gt(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return H(()=>M4((a,l)=>[st(this.layer.call(a,r)),[]],e=st(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),he((()=>{class n extends bL{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=Na(s),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=e.layer.getClassName(),o.config=r,this.backwardLayer=Na(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Fie(n){Eu(toe,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new vt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,o,i,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(i=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,o=[s]):o=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Es(o)}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=F4(e,s,o,this.numConstants);if(e=i.inputs,s=i.initialState,o=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==o)return super.apply(e,r);const a=[],l=[];if(null!=s){const c=s.length;if(c%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new gr({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=o)throw new vt("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof Ui;for(const c of a)if(c instanceof Ui!==u)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return H(()=>{const s=r.initialState;let o,i,a,l;if(null==s)o=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);o=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=Mo(i,1)),"concat"===this.mergeMode?l=KN([o,i]):"sum"===this.mergeMode?l=ue(o,i):"ave"===this.mergeMode?l=L(.5,ue(o,i)):"mul"===this.mergeMode?l=L(o,i):null==this.mergeMode&&(l=[o,i]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Du(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Du(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=Na(r.layer);if(delete r.layer,null!=r.numConstants)throw new vt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=s,new e(o)}}return n.className="Bidirectional",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return H(()=>("float32"!==(e=st(e)).dtype&&(e=Vi(e,"float32")),ue(L(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:Pie,cropAndResize:Lie}=Ur;he((()=>{class n extends Ot{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,o,i,a,l,u){return H(()=>{let c,d=!1;const m=[r/a,s/l,(o+r)/a,(i+s)/l],y=[];3===e.rank?(d=!0,c=_s([e])):c=e;for(let I=0;I<c.shape[0];I++)y.push(m);const v=ko(y,[y.length,4]),w=pd(0,y.length,1,"int32"),N=Lie(c,v,w,[o,i],"nearest");return Vi(d?st(Po(N)):N,u)})}upsize(e,r,s,o){return H(()=>Vi(Pie(e,[r,s]),o))}call(e,r){return H(()=>{const s=st(e),o=s.dtype,i=s.shape,a=i[i.length-3],l=i[i.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),0===c&&(c=1)),u>=0&&c>=0?this.centerCrop(s,u,c,this.height,this.width,a,l,o):this.upsize(e,this.height,this.width,o)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=Gt(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return n.className="CenterCrop",n})()),he((()=>{class n extends Ot{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=Gt(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return H(()=>{let s;if("int32"!==(e=st(e)).dtype&&(e=Vi(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new z(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=st(r.countWeights)}const o=Oo(e),i=yp(e),a=Ws(this.numTokens,o).bufferSync().get(0),l=ml(i,0).bufferSync().get(0);if(!a||!l)throw new z(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function $ie(n,t,e,r){let s=st(n);if("int32"!==s.dtype&&(s=Vi(s,"int32")),"int"===t)return s;const o=s.shape;if(0===s.rank&&(s=zr(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=zr(s,-1)),s.rank>2)throw new z(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${o} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t);let l;if(l=LS(s,typeof r<"u"&&"count"===t?r:[],e,i),"tfIdf"!==t)return l;if(r)return L(l,r);throw new z("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return n.className="CategoryEncoding",n})());const NL=new Set(["bilinear","nearest"]);he((()=>{class n extends Ot{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!NL.has(e.interpolation))throw new z(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=Gt(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return H(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return Ur.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Ur.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...NL]} are supported`)})}}return n.className="Resizing",n})());let Bie=(()=>{class n{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return n.className="RandomSeed",n})(),zie=(()=>{class n extends Ot{constructor(e){super(e),this.randomGenerator=new Bie(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BaseRandomLayer",n})();const IL=new Set(["bilinear","nearest"]);function Bp(n){return new z4(n)}he((()=>{class n extends zie{constructor(e){super(e);const{factor:r,interpolation:s="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new z(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new z(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new z(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(s){if(!IL.has(s))throw new z(`Invalid interpolation parameter: ${s} is not implemented`);this.interpolation=s}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=Gt(e),[this.imgHeight,-1,e[2]]}call(e,r){return H(()=>{const s=st(e);this.imgHeight=s.shape[s.shape.length-3];const o=s.shape[s.shape.length-2];this.widthFactor=Nu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*o;i=Math.round(i);const a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Ur.resizeBilinear(e,a);case"nearest":return Ur.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...IL]} are supported`)}})}}return n.className="RandomWidth",n})());G().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var RL,Ds=(()=>{return(n=Ds||(Ds={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",Ds;var n})();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(RL||(RL={}));const RT={};function OL(n){return RT[n]}function S(n,t,e,r,s){const o=t.inputParams[n];if(o&&void 0!==o.inputIndexStart){const a=o.inputIndexStart,l=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?a+1:o.inputIndexEnd,u=a<0?t.inputNames.length+a:a;if("tensor"===o.type)return Wr(t.inputNames[u],e,r,s);if("tensors"===o.type){const h=t.inputs.slice(a,l);return t.inputNames.slice(a,l).filter((p,g)=>{var m;return"NoOp"!==(null===(m=h[g])||void 0===m?void 0:m.op)}).map(p=>Wr(p,e,r,s))}const c=Wr(t.inputNames[u],e,r,s),d=c.dataSync();return"number"===o.type?d[0]:Eo(c.shape,d)}const i=t.attrParams[n];return i&&i.value}function Wr(n,t,e,r){const[s,o]=js(n,e);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const i=e.currentContextIds.find(a=>!!t[X1(s,a)]);return void 0!==i?t[X1(s,i)][o]:void 0}function FL(n,t,e){return t[X1(n,e.currentContextId)]}function Ta(n,t){const[e,r,s]=js(n,t);return[X1(e,t&&t.currentContextId),r,s]}function X1(n,t){return t?`${n}-${t}`:n}function js(n,t){if(""===n)return["",0,void 0];const e=null!=t&&null!=t.parseNodeNameCache;if(e){const o=t.parseNodeNameCache.get(n);if(null!=o)return o}const r=n.split(":");let s;if(1===r.length)s=[n,0,void 0];else{const i=3===r.length?r[1]:void 0;s=[r[0],Number(r[r.length-1]),i]}return e&&t.parseNodeNameCache.set(n,s),s}function J1(n,t,e){let r=S("pad",n,t,e);if("explicit"===r){r=S("explicitPaddings",n,t,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function Ia(n){return n.kept?n:pa(n)}const Qie=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],eae=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],tae=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],nae=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],rae=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],sae=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],oae=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],iae=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],aae=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],lae=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],uae=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],cae=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],dae=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],hae=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],fae=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],pae=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],mae=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],gae=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],yae=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class ML{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[We,gt,Ae,j,ge,Se,ce,fe,Me,Le,Ht,_t,Vn,Rs,Gr,Ct,Bt,zt,le].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(t,e={}){const s=[],o=[],i=[],a=t.node.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?s.push(g[m.name]):"Const"===m.op?o.push(g[m.name]):(null==m.input||0===m.input.length)&&i.push(g[m.name]),g),{});let l=[];const u=[];let c={},d={};null!=e&&(c=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(g=>{const m=a[g];m.inputNames.forEach((y,v)=>{const[w,,x]=Ta(y),N=a[w];if(null!=N.outputs){const I=N.outputs.indexOf(x);-1!==I&&(m.inputNames[v]=`${w}:${I}`)}m.inputs.push(N),N.children.push(m)})}),0===Object.keys(d).length?h.forEach(g=>{const m=a[g];0===m.children.length&&u.push(m)}):Object.keys(d).forEach(g=>{const[m]=Ta(g),y=a[m];null!=y&&(y.signatureKey=d[g],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{const[m]=Ta(g),y=a[m];y&&(y.signatureKey=c[g],l.push(y))}):l=s;let f={};null!=t.library&&null!=t.library.function&&(f=t.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));const p={nodes:a,inputs:l,outputs:u,weights:o,placeholders:s,signature:e,functions:f};return i.length>0&&(p.initNodes=i),p}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=OL(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=OT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=OT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=zT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=zT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=MT(t.attr,o.tfName,o.defaultValue||0),void 0===a&&o.tfDeprecatedName&&(a=MT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=BT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=BT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=FT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=FT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=WT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=WT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=VT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=VT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=UT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=UT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=LT(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=LT(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=$T(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=$T(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=LL(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=LL(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(t){const e=t.nodeDef,s=[];let o={};null!=e&&(o=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const i=[],a=[];t.signature.inputArg.forEach(d=>{const[h]=Ta(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:PT(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,i.push(f),o[h]=f}),Object.keys(o).forEach(d=>{const h=o[d];h.inputNames.forEach((f,p)=>{const[g,,m]=Ta(f),y=o[g];if(null!=y.outputs){const v=y.outputs.indexOf(m);-1!==v&&(h.inputNames[p]=`${g}:${v}`)}h.inputs.push(y),y.children.push(h)})});const u=t.ret;t.signature.outputArg.forEach(d=>{const[h,f]=Ta(u[d.name]),p=o[h];null!=p&&(p.defaultOutput=f,a.push(p))});const c=this.mapArgsToSignature(t);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:[],signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function PL(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function bae(n){const t=G().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function OT(n,t,e,r=!1){const s=n[t];return null!=s?PL(s.s,r):e}function FT(n,t,e){const r=n[t];return r?r.b:e}function MT(n,t,e){const r=n[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function PT(n){switch("string"==typeof n&&(n=Ds[n]),n){case Ds.DT_FLOAT:case Ds.DT_HALF:return"float32";case Ds.DT_INT32:case Ds.DT_INT64:case Ds.DT_INT8:case Ds.DT_UINT8:return"int32";case Ds.DT_BOOL:return"bool";case Ds.DT_DOUBLE:return"float32";case Ds.DT_STRING:return"string";case Ds.DT_COMPLEX64:case Ds.DT_COMPLEX128:return"complex64";default:return null}}function LL(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function LT(n,t,e){const r=n[t];return r&&r.type?PT(r.type):e}function $T(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>PT(s)):e}function $L(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function VT(n,t,e){const r=n[t];return r&&r.shape?$L(r.shape):e}function BT(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function zT(n,t,e,r=!1){const s=n[t];return s&&s.list&&s.list.s?s.list.s.map(o=>PL(o,r)):e}function UT(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>$L(s)):e}function WT(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class vae{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(t){return Wr(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return Wr(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return MT(this.node.rawAttrs,t,e);if(null!=r.s)return OT(this.node.rawAttrs,t,e);if(null!=r.b)return FT(this.node.rawAttrs,t,e);if(null!=r.shape)return VT(this.node.rawAttrs,t,e);if(null!=r.type)return LT(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return BT(this.node.rawAttrs,t,e);if(null!=r.list.s)return zT(this.node.rawAttrs,t,e);if(null!=r.list.shape)return UT(this.node.rawAttrs,t,e);if(null!=r.list.b)return WT(this.node.rawAttrs,t,e);if(null!=r.list.type)return $T(this.node.rawAttrs,t,e)}return e}}function zo(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){_(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=t[r];_(s<0||o<0||s===o,()=>e+` Shapes ${n} and ${t} must match`)}}}function VL(n){return!("number"==typeof n||n.some(t=>t<0))}function zp(n,t,e){let r=HT(n,e);const s=!VL(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(o=>{r=HT(o.shape,r)}),!VL(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function HT(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const s=n[r],o=t[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=s>=0?s:o}return e}class Cae{constructor(t,e,r,s,o,i,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Ke(0),kr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),zo(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,kr(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(0===t.length)return ko([],[0].concat(this.elementShape));const r=this.readMany(t);return zo(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),_s(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return ko([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return zo(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),_n(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,Po(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===r?0:e.size/r,i=[];H(()=>{e=V(e,[1,r,o]);for(let l=0;l<t.length;++l)i[l]=V(rt(e,[0,0===l?0:s[l-1],0],[1,t[l],o]),this.elementShape);return i});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,i)}}class Ru{get id(){return this.idTensor.id}constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);zo(e,o.shape,"TensorList shape mismatch: "),kr(o)}),this.idTensor=Ke(0),this.maxNumElements=s,kr(this.idTensor)}copy(){return new Ru([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);zo(t,this.elementShape,"TensorList shape mismatch: ");const s=zp(this.elementShape,this.tensors,t);return H(()=>{const o=this.tensors.map(i=>V(i,s));return _s(o,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=zp(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,zo(s.shape,t,"TensorList shape mismatch: "),V(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(zo(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");kr(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Ru([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);zo(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=zp(this.elementShape,this.tensors,e);return V(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);zo(this.elementShape,e.shape,"TensorList shape mismatch: "),kr(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);zo(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=zp(this.elementShape,this.tensors,r);return 0===t.length?ko([],[0].concat(s)):H(()=>{const o=t.map(i=>V(this.tensors[i],s));return _s(o,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);zo(this.elementShape,e,"TensorList shape mismatch: ");const r=zp(this.elementShape,this.tensors,e);return 0===this.size()?ko([],[0].concat(r)):H(()=>{const s=this.tensors.map(o=>V(o,r));return _n(s,0)})}}const _ae=function(){var n=J(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const s=S("thenBranch",t,e,r),o=S("elseBranch",t,e,r),i=S("cond",t,e,r),a=S("args",t,e,r);return(yield i.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[o].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=S("body",t,e,r),o=S("cond",t,e,r),i=S("args",t,e,r),a=yield r.functionMap[o].executeFunctionAsync(i,r.tensorArrayMap,r.tensorListMap),l=i.map(d=>d.id);let u=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let c=i;for(;u[0];){const d=c;c=yield r.functionMap[s].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);const h=c.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield r.functionMap[o].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);u=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return c}case"LoopCond":return[Ia(S("pred",t,e,r))];case"Switch":{const s=S("pred",t,e,r);let o=S("data",t,e,r);return o.kept||(o=Ia(o)),(yield s.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const s=t.inputNames.find(o=>void 0!==Wr(o,e,r));return s?[Ia(Wr(s,e,r))]:void 0}case"Enter":{const s=S("frameName",t,e,r),o=S("tensor",t,e,r);return r.enterFrame(s),[Ia(o)]}case"Exit":{const s=S("tensor",t,e,r);return r.exitFrame(),[Ia(s)]}case"NextIteration":{const s=S("tensor",t,e,r);return r.nextIteration(),[Ia(s)]}case"TensorArrayV3":{const s=S("size",t,e,r),o=S("dtype",t,e,r),i=S("elementShape",t,e,r),a=S("dynamicSize",t,e,r),l=S("clearAfterRead",t,e,r),u=S("identicalElementShapes",t,e,r),c=S("name",t,e,r),d=new Cae(c,o,s,i,u,a,l);return r.addTensorArray(d),[d.idTensor,Ke(1)]}case"TensorArrayWriteV3":{const s=S("tensorArrayId",t,e,r),o=S("index",t,e,r),i=S("tensor",t,e,r),a=r.getTensorArray(s.id);return a.write(o,i),[a.idTensor]}case"TensorArrayReadV3":{const s=S("tensorArrayId",t,e,r),o=S("index",t,e,r);return[r.getTensorArray(s.id).read(o)]}case"TensorArrayGatherV3":{const s=S("tensorArrayId",t,e,r),o=S("indices",t,e,r),i=S("dtype",t,e,r);return[r.getTensorArray(s.id).gather(o,i)]}case"TensorArrayScatterV3":{const s=S("tensorArrayId",t,e,r),o=S("indices",t,e,r),i=S("tensor",t,e,r),a=r.getTensorArray(s.id);return a.scatter(o,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=S("tensorArrayId",t,e,r),o=r.getTensorArray(s.id),i=S("dtype",t,e,r);return[o.concat(i)]}case"TensorArraySplitV3":{const s=S("tensorArrayId",t,e,r),o=S("tensor",t,e,r),i=S("lengths",t,e,r),a=r.getTensorArray(s.id);return a.split(i,o),[a.idTensor]}case"TensorArraySizeV3":{const s=S("tensorArrayId",t,e,r);return[Ke(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=S("tensorArrayId",t,e,r),o=r.getTensorArray(s.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const s=S("tensorListId",t,e,r),o=S("index",t,e,r),i=S("tensor",t,e,r),a=r.getTensorList(s.id);return a.setItem(o,i),[a.idTensor]}case"TensorListGetItem":{const s=S("tensorListId",t,e,r),o=S("index",t,e,r),i=S("elementShape",t,e,r),a=S("elementDType",t,e,r);return[r.getTensorList(s.id).getItem(o,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=S("indices",t,e,r),l=function Tae(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Ru([],e,n.dtype,r),i=Po(n,0);return t.forEach((a,l)=>{o.setItem(a,i[l])}),o}(S("tensor",t,e,r),s,S("elementShape",t,e,r),S("numElements",t,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=S("elementShape",t,e,r),o=S("elementDType",t,e,r);let i;i="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=S(i,t,e,r),u=function Nae(n,t,e,r){return new Ru([],n,t,r)}(s,o,0,"TensorListReserve"===t.op?-1:a);return r.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=S("tensorListId",t,e,r),o=S("indices",t,e,r),i=S("elementShape",t,e,r),a=S("elementDType",t,e,r);return[r.getTensorList(s.id).gather(o,a,i)]}case"TensorListStack":{const s=S("tensorListId",t,e,r),o=S("elementShape",t,e,r),i=S("elementDType",t,e,r),a=S("numElements",t,e,r);return[r.getTensorList(s.id).stack(o,i,a)]}case"TensorListFromTensor":{const a=function Sae(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);zo(n.shape.slice(1),t,"TensorList shape mismatch: ");const o=Po(n);return new Ru(o,t,r)}(S("tensor",t,e,r),S("elementShape",t,e,r),S("elementDType",t,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=S("tensorListId",t,e,r),o=r.getTensorList(s.id),i=S("dtype",t,e,r),a=S("elementShape",t,e,r);return[o.concat(i,a)]}case"TensorListPushBack":{const s=S("tensorListId",t,e,r),o=S("tensor",t,e,r),i=r.getTensorList(s.id);return i.pushBack(o),[i.idTensor]}case"TensorListPopBack":{const s=S("tensorListId",t,e,r),o=S("elementShape",t,e,r),i=S("elementDType",t,e,r);return[r.getTensorList(s.id).popBack(o,i)]}case"TensorListSplit":{const s=S("tensor",t,e,r),o=S("elementShape",t,e,r),a=function Iae(n,t,e){let r=0;const s=t.map(c=>(r+=c,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const i=HT(n.shape.slice(1),e),a=0===r?0:n.size/r,l=H(()=>{const c=[];n=V(n,[1,r,a]);for(let d=0;d<t.length;++d)c[d]=V(rt(n,[0,0===d?0:s[d-1],0],[1,t[d],a]),i);return n.dispose(),c}),u=new Ru([],e,n.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}(s,S("lengths",t,e,r),o);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=S("tensorListId",t,e,r);return[Ke(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=S("tensorListId",t,e,r),o=S("size",t,e,r),a=r.getTensorList(s.id).resize(o);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s){return n.apply(this,arguments)}}();function BL(n,t,e){const[r,s]=S("fusedOps",n,t,e),o="biasadd"===r,i=!o,a="prelu"===s,l="fusedbatchnorm"===r,u=S("numArgs",n,t,e);if(o){if(a&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=S("strides",n,t,e),d=J1(n,t,e),h=S("dataFormat",n,t,e).toUpperCase(),f=S("dilations",n,t,e);let[p,g]=S("args",n,t,e);return i&&(g=p,p=void 0),{stride:c,pad:d,dataFormat:h,dilations:f,biasArg:p,preluArg:g,activationFunc:s,leakyreluAlpha:S("leakyreluAlpha",n,t,e)}}function jT(n,t,e){return{boxes:S("boxes",n,t,e),scores:S("scores",n,t,e),maxOutputSize:S("maxOutputSize",n,t,e),iouThreshold:S("iouThreshold",n,t,e),scoreThreshold:S("scoreThreshold",n,t,e),softNmsSigma:S("softNmsSigma",n,t,e)}}const kae=function(){var n=J(function*(t,e,r,s,o=re){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c,softNmsSigma:d}=jT(t,e,r),h=yield o.image.nonMaxSuppressionWithScoreAsync(i,a,l,u,c,d);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=jT(t,e,r),d=S("padToMaxOutputSize",t,e,r),h=yield o.image.nonMaxSuppressionPaddedAsync(i,a,l,u,c,d);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=jT(t,e,r);return[yield o.image.nonMaxSuppressionAsync(i,a,l,u,c)]}case"Where":{const i=o.cast(S("condition",t,e,r),"bool"),a=[yield o.whereAsync(i)];return i.dispose(),a}case"ListDiff":return o.setdiff1dAsync(S("x",t,e,r),S("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,o){return n.apply(this,arguments)}}();class Oae{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Ke(0),this.tensorMap=new Map,kr(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ke(this.size(),"int32")}import(t,e){var r=this;return J(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return r.tensorMap.forEach(o=>o.dispose()),r.tensorMap.clear(),H(()=>{const o=Po(e),i=s.length,a=o.length;_(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let l=0;l<i;l++){const u=s[l],c=o[l];kr(c),r.tensorMap.set(u,c)}return r.handle})})()}find(t,e){var r=this;return J(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return H(()=>{const o=[];for(let i=0;i<s.length;i++){const l=r.findWithDefault(s[i],e);o.push(l)}return _s(o)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const Fae=function(){var n=J(function*(t,e,r,s){switch(t.op){case"HashTable":case"HashTableV2":{const o=s.getHashTableHandleByName(t.name);if(null!=o)return[o];{const i=S("keyDType",t,e,r),a=S("valueDType",t,e,r),l=new Oae(i,a);return s.addHashTable(t.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const o=S("tableHandle",t,e,r,s),i=S("keys",t,e,r),a=S("values",t,e,r);return[yield s.getHashTableById(o.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const o=S("tableHandle",t,e,r,s),i=S("keys",t,e,r),a=S("defaultValue",t,e,r);return[yield s.getHashTableById(o.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=S("tableHandle",t,e,r,s);return[s.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,o){return n.apply(this,arguments)}}();function zL(n,t,e,r,s=H){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(S("a",n,t,e),S("b",n,t,e))];case"AddN":return[r.addN(S("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(S("a",n,t,e),S("b",n,t,e))];case"Mul":return[r.mul(S("a",n,t,e),S("b",n,t,e))];case"RealDiv":case"Div":return[r.div(S("a",n,t,e),S("b",n,t,e))];case"DivNoNan":return[r.divNoNan(S("a",n,t,e),S("b",n,t,e))];case"FloorDiv":return[r.floorDiv(S("a",n,t,e),S("b",n,t,e))];case"Sub":return[r.sub(S("a",n,t,e),S("b",n,t,e))];case"Minimum":return[r.minimum(S("a",n,t,e),S("b",n,t,e))];case"Maximum":return[r.maximum(S("a",n,t,e),S("b",n,t,e))];case"Pow":return[r.pow(S("a",n,t,e),S("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(S("a",n,t,e),S("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"basic_math":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(S("x",n,t,e))];case"Acos":return[r.acos(S("x",n,t,e))];case"Acosh":return[r.acosh(S("x",n,t,e))];case"Asin":return[r.asin(S("x",n,t,e))];case"Asinh":return[r.asinh(S("x",n,t,e))];case"Atan":return[r.atan(S("x",n,t,e))];case"Atan2":return[r.atan2(S("x",n,t,e),S("y",n,t,e))];case"Atanh":return[r.atanh(S("x",n,t,e))];case"Ceil":return[r.ceil(S("x",n,t,e))];case"Complex":return[r.complex(S("real",n,t,e),S("imag",n,t,e))];case"Cos":return[r.cos(S("x",n,t,e))];case"Cosh":return[r.cosh(S("x",n,t,e))];case"Elu":return[r.elu(S("x",n,t,e))];case"Erf":return[r.erf(S("x",n,t,e))];case"Exp":return[r.exp(S("x",n,t,e))];case"Expm1":return[r.expm1(S("x",n,t,e))];case"Floor":return[r.floor(S("x",n,t,e))];case"Log":return[r.log(S("x",n,t,e))];case"Log1p":return[r.log1p(S("x",n,t,e))];case"Imag":return[r.imag(S("x",n,t,e))];case"Neg":return[r.neg(S("x",n,t,e))];case"Reciprocal":return[r.reciprocal(S("x",n,t,e))];case"Real":return[r.real(S("x",n,t,e))];case"Relu":return[r.relu(S("x",n,t,e))];case"Round":return[r.round(S("x",n,t,e))];case"Selu":return[r.selu(S("x",n,t,e))];case"Sigmoid":return[r.sigmoid(S("x",n,t,e))];case"Sin":return[r.sin(S("x",n,t,e))];case"Sign":return[r.sign(S("x",n,t,e))];case"Sinh":return[r.sinh(S("x",n,t,e))];case"Softplus":return[r.softplus(S("x",n,t,e))];case"Sqrt":return[r.sqrt(S("x",n,t,e))];case"Square":return[r.square(S("x",n,t,e))];case"Tanh":return[r.tanh(S("x",n,t,e))];case"Tan":return[r.tan(S("x",n,t,e))];case"ClipByValue":return[r.clipByValue(S("x",n,t,e),S("clipValueMin",n,t,e),S("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(S("x",n,t,e))];case"Rsqrt":return[r.rsqrt(Wr(n.inputNames[0],t,e))];case"LeakyRelu":return[r.leakyRelu(S("x",n,t,e),S("alpha",n,t,e))];case"Prelu":return[r.prelu(S("x",n,t,e),S("alpha",n,t,e))];case"IsNan":return[r.isNaN(Wr(n.inputNames[0],t,e))];case"IsInf":return[r.isInf(Wr(n.inputNames[0],t,e))];case"IsFinite":return[r.isFinite(Wr(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"control":return _ae(i,a,l);case"convolution":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"Conv1D":{const s=S("stride",n,t,e),o=S("pad",n,t,e),i=S("dataFormat",n,t,e).toUpperCase(),a=S("dilation",n,t,e);return[r.conv1d(S("x",n,t,e),S("filter",n,t,e),s,o,i,a)]}case"Conv2D":{const s=S("strides",n,t,e),o=J1(n,t,e),i=S("dataFormat",n,t,e).toUpperCase(),a=S("dilations",n,t,e);return[r.conv2d(S("x",n,t,e),S("filter",n,t,e),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=BL(n,t,e);return[r.fused.conv2d({x:S("x",n,t,e),filter:S("filter",n,t,e),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=BL(n,t,e);return[r.fused.depthwiseConv2d({x:S("x",n,t,e),filter:S("filter",n,t,e),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=S("outputShape",n,t,e),o=S("strides",n,t,e),i=J1(n,t,e);return[r.conv2dTranspose(S("x",n,t,e),S("filter",n,t,e),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=S("strides",n,t,e),o=J1(n,t,e),i=S("dilations",n,t,e),a=S("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(S("input",n,t,e),S("filter",n,t,e),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=S("strides",n,t,e),o=S("pad",n,t,e),i=S("dataFormat",n,t,e).toUpperCase(),a=S("dilations",n,t,e);return[r.conv3d(S("x",n,t,e),S("filter",n,t,e),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=S("strides",n,t,e),o=S("pad",n,t,e),i=S("kernelSize",n,t,e);return[r.avgPool(S("x",n,t,e),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=S("strides",n,t,e),o=S("pad",n,t,e),i=S("kernelSize",n,t,e);return[r.maxPool(S("x",n,t,e),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=S("strides",n,t,e),o=S("pad",n,t,e),i=S("kernelSize",n,t,e),a=S("includeBatchInIndex",n,t,e),{result:l,indexes:u}=r.maxPoolWithArgmax(S("x",n,t,e),[i[1],i[2]],[s[1],s[2]],o,a);return[l,u]}case"AvgPool3D":{const s=S("strides",n,t,e),o=S("pad",n,t,e),i=S("kernelSize",n,t,e);return[r.avgPool3d(S("x",n,t,e),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=S("strides",n,t,e),o=S("pad",n,t,e),i=S("kernelSize",n,t,e);return[r.maxPool3d(S("x",n,t,e),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=S("strides",n,t,e),o=S("pad",n,t,e),i=S("dilations",n,t,e),a=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(S("x",n,t,e),S("filter",n,t,e),[a,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"creation":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"Fill":{const s=S("shape",n,t,e),o=S("dtype",n,t,e),i=S("value",n,t,e);return[r.fill(s,i,o)]}case"LinSpace":{const s=S("start",n,t,e),o=S("stop",n,t,e),i=S("num",n,t,e);return[r.linspace(s,o,i)]}case"Multinomial":{const s=S("logits",n,t,e),o=S("numSamples",n,t,e),i=S("seed",n,t,e);return[r.multinomial(s,o,i)]}case"OneHot":{const s=S("indices",n,t,e),o=S("depth",n,t,e),i=S("onValue",n,t,e),a=S("offValue",n,t,e),l=S("dtype",n,t,e);return[r.oneHot(s,o,i,a,l)]}case"Ones":return[r.ones(S("shape",n,t,e),S("dtype",n,t,e))];case"OnesLike":return[r.onesLike(S("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(S("shape",n,t,e),S("dtype",n,t,e),S("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(S("shape",n,t,e),S("minval",n,t,e),S("maxval",n,t,e),S("dtype",n,t,e))];case"RandomUniformInt":return[r.randomUniformInt(S("shape",n,t,e),S("minval",n,t,e),S("maxval",n,t,e),S("seed",n,t,e))];case"Range":{const s=S("start",n,t,e),o=S("stop",n,t,e),i=S("step",n,t,e);return[r.range(s,o,i,S("dtype",n,t,e))]}case"TruncatedNormal":{const s=S("shape",n,t,e),o=S("mean",n,t,e),i=S("stdDev",n,t,e),a=S("seed",n,t,e);return[r.truncatedNormal(s,o,i,S("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(S("shape",n,t,e),S("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(S("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"dynamic":return kae(i,a,l);case"evaluation":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"LowerBound":{const s=S("sortedSequence",n,t,e),o=S("values",n,t,e);return[r.lowerBound(s,o)]}case"TopKV2":{const s=S("x",n,t,e),o=S("k",n,t,e),i=S("sorted",n,t,e),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=S("sortedSequence",n,t,e),o=S("values",n,t,e);return[r.upperBound(s,o)]}case"Unique":{const s=S("x",n,t,e),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=S("x",n,t,e),o=S("axis",n,t,e),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"image":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"ResizeBilinear":{const s=S("images",n,t,e),o=S("size",n,t,e),i=S("alignCorners",n,t,e),a=S("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=S("images",n,t,e),o=S("size",n,t,e),i=S("alignCorners",n,t,e),a=S("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=S("image",n,t,e),o=S("boxes",n,t,e),i=S("boxInd",n,t,e),a=S("cropSize",n,t,e),l=S("method",n,t,e),u=S("extrapolationValue",n,t,e);return[r.image.cropAndResize(s,o,i,a,l,u)]}case"ImageProjectiveTransformV3":{const s=S("images",n,t,e),o=S("transforms",n,t,e),i=S("outputShape",n,t,e),a=S("fillValue",n,t,e),l=S("interpolation",n,t,e),u=S("fillMode",n,t,e);return[r.image.transform(s,o,l.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"graph":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const s=S("default",n,t,e);return[Wr(n.name,t,e)||s];case"Placeholder":return[Wr(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ia(S("x",n,t,e))];case"IdentityN":return S("x",n,t,e).map(c=>Ia(c));case"Shape":return[r.tensor1d(S("x",n,t,e).shape,"int32")];case"ShapeN":return S("x",n,t,e).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(S("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(S("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=S("x",n,t,e),a=S("data",n,t,e),l=S("message",n,t,e),u=S("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"logical":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"Equal":return[r.equal(S("a",n,t,e),S("b",n,t,e))];case"NotEqual":return[r.notEqual(S("a",n,t,e),S("b",n,t,e))];case"Greater":return[r.greater(S("a",n,t,e),S("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(S("a",n,t,e),S("b",n,t,e))];case"Less":return[r.less(S("a",n,t,e),S("b",n,t,e))];case"LessEqual":return[r.lessEqual(S("a",n,t,e),S("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(S("a",n,t,e),S("b",n,t,e))];case"LogicalNot":return[r.logicalNot(S("a",n,t,e))];case"LogicalOr":return[r.logicalOr(S("a",n,t,e),S("b",n,t,e))];case"Select":case"SelectV2":return[r.where(S("condition",n,t,e),S("a",n,t,e),S("b",n,t,e))];case"BitwiseAnd":return[r.bitwiseAnd(S("a",n,t,e),S("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"matrices":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(S("a",n,t,e),S("b",n,t,e),S("transposeA",n,t,e),S("transposeB",n,t,e))];case"Einsum":return[r.einsum(S("equation",n,t,e),...S("tensors",n,t,e))];case"Transpose":return[r.transpose(S("x",n,t,e),S("perm",n,t,e))];case"_FusedMatMul":const[s,o]=S("fusedOps",n,t,e),i="biasadd"===s,a="prelu"===o,l=S("numArgs",n,t,e),u=S("leakyreluAlpha",n,t,e);if(i){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=S("args",n,t,e);return[r.fused.matMul({a:S("a",n,t,e),b:S("b",n,t,e),transposeA:S("transposeA",n,t,e),transposeB:S("transposeB",n,t,e),bias:c,activation:o,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(S("a",n,t,e),S("numLower",n,t,e),S("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"normalization":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(S("x",n,t,e),S("axis",n,t,e),S("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(S("x",n,t,e),S("mean",n,t,e),S("variance",n,t,e),S("offset",n,t,e),S("scale",n,t,e),S("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(S("x",n,t,e),S("radius",n,t,e),S("bias",n,t,e),S("alpha",n,t,e),S("beta",n,t,e))];case"Softmax":return[r.softmax(S("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(S("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"ragged":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather(S("paramsNestedSplits",n,t,e),S("paramsDenseValues",n,t,e),S("indices",n,t,e),S("outputRaggedRank",n,t,e));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange(S("starts",n,t,e),S("limits",n,t,e),S("splits",n,t,e));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(S("shape",n,t,e),S("values",n,t,e),S("defaultValue",n,t,e),S("rowPartitionTensors",n,t,e),S("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"reduction":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"Max":{const a=S("axis",n,t,e),l=S("keepDims",n,t,e);return[r.max(S("x",n,t,e),a,l)]}case"Mean":{const a=S("axis",n,t,e),l=S("keepDims",n,t,e);return[r.mean(S("x",n,t,e),a,l)]}case"Min":{const a=S("axis",n,t,e),l=S("keepDims",n,t,e);return[r.min(S("x",n,t,e),a,l)]}case"Sum":{const a=S("axis",n,t,e),l=S("keepDims",n,t,e);return[r.sum(S("x",n,t,e),a,l)]}case"All":{const a=S("axis",n,t,e),l=S("keepDims",n,t,e);return[r.all(S("x",n,t,e),a,l)]}case"Any":{const a=S("axis",n,t,e),l=S("keepDims",n,t,e);return[r.any(S("x",n,t,e),a,l)]}case"ArgMax":{const a=S("axis",n,t,e);return[r.argMax(S("x",n,t,e),a)]}case"ArgMin":{const a=S("axis",n,t,e);return[r.argMin(S("x",n,t,e),a)]}case"Prod":{const a=S("axis",n,t,e),l=S("keepDims",n,t,e);return[r.prod(S("x",n,t,e),a,l)]}case"Cumprod":{const a=S("axis",n,t,e),l=S("exclusive",n,t,e),u=S("reverse",n,t,e);return[r.cumprod(S("x",n,t,e),a,l,u)]}case"Cumsum":{const a=S("axis",n,t,e),l=S("exclusive",n,t,e),u=S("reverse",n,t,e);return[r.cumsum(S("x",n,t,e),a,l,u)]}case"Bincount":const s=S("x",n,t,e),o=S("weights",n,t,e),i=S("size",n,t,e);return[r.bincount(s,o,i)];case"DenseBincount":{const a=S("x",n,t,e),l=S("weights",n,t,e),u=S("size",n,t,e),c=S("binaryOutput",n,t,e);return[r.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"slice_join":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=S("n",n,t,e),o=S("axis",n,t,e);let i=S("tensors",n,t,e);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=S("x",n,t,e),o=S("indices",n,t,e);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=S("axis",n,t,e),o=S("batchDims",n,t,e),i=S("x",n,t,e),a=S("indices",n,t,e);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=S("dims",n,t,e),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=S("x",n,t,e);return[r.reverse(i,o)]}case"ReverseV2":{const s=S("axis",n,t,e),o=S("x",n,t,e);return[r.reverse(o,s)]}case"Slice":{const s=S("begin",n,t,e),o=S("size",n,t,e);return[r.slice(S("x",n,t,e),s,o)]}case"StridedSlice":{const s=S("begin",n,t,e),o=S("end",n,t,e),i=S("strides",n,t,e),a=S("beginMask",n,t,e),l=S("endMask",n,t,e),u=S("ellipsisMask",n,t,e),c=S("newAxisMask",n,t,e),d=S("shrinkAxisMask",n,t,e),h=S("x",n,t,e);return[r.stridedSlice(h,s,o,i,a,l,u,c,d)]}case"Pack":return H(()=>{const s=S("axis",n,t,e),o=S("tensors",n,t,e),i=o[0].shape,a=r.squeeze(o[0]).shape,l=o.map(u=>{const c=Pt(u.shape,i);if(!c&&!Pt(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{const s=S("axis",n,t,e),o=S("tensor",n,t,e);return r.unstack(o,s)}case"Tile":{const s=S("reps",n,t,e);return[r.tile(S("x",n,t,e),s)]}case"Split":case"SplitV":{const s=S("axis",n,t,e),o=S("numOrSizeSplits",n,t,e),i=S("x",n,t,e);return r.split(i,o,s)}case"ScatterNd":{const s=S("indices",n,t,e),o=S("values",n,t,e),i=S("shape",n,t,e);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=S("x",n,t,e),o=S("indices",n,t,e);return[r.gatherND(s,o)]}case"SparseToDense":{const s=S("sparseIndices",n,t,e),o=S("outputShape",n,t,e),i=S("sparseValues",n,t,e),a=S("defaultValue",n,t,e);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{const s=S("indices",n,t,e),o=S("values",n,t,e),i=S("tensor",n,t,e);return[r.tensorScatterUpdate(i,s,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"sparse":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(S("indices",n,t,e),S("values",n,t,e),S("denseShape",n,t,e),S("defaultValue",n,t,e));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(S("inputIndices",n,t,e),S("inputShape",n,t,e),S("newShape",n,t,e));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(S("data",n,t,e),S("indices",n,t,e),S("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(S("data",n,t,e),S("indices",n,t,e),S("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"spectral":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"FFT":return[r.fft(S("x",n,t,e))];case"IFFT":return[r.ifft(S("x",n,t,e))];case"RFFT":return[r.rfft(S("x",n,t,e))];case"IRFFT":return[r.irfft(S("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"string":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(S("input",n,t,e),S("pattern",n,t,e),S("rewrite",n,t,e),S("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(S("data",n,t,e),S("dataSplits",n,t,e),S("separator",n,t,e),S("nGramWidths",n,t,e),S("leftPad",n,t,e),S("rightPad",n,t,e),S("padWidth",n,t,e),S("preserveShortSequences",n,t,e));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(S("input",n,t,e),S("delimiter",n,t,e),S("skipEmpty",n,t,e));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(S("input",n,t,e),S("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"transformation":return s(()=>((n,t,e,r=re)=>{switch(n.op){case"Cast":return[r.cast(S("x",n,t,e),S("dtype",n,t,e))];case"ExpandDims":{const s=S("axis",n,t,e);return[r.expandDims(S("x",n,t,e),s)]}case"Squeeze":{const s=S("axis",n,t,e);return[r.squeeze(S("x",n,t,e),s)]}case"Reshape":return[r.reshape(S("x",n,t,e),S("shape",n,t,e))];case"EnsureShape":return[r.ensureShape(S("x",n,t,e),S("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(S("x",n,t,e),S("padding",n,t,e),S("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(S("x",n,t,e),S("padding",n,t,e),S("constantValue",n,t,e))];case"SpaceToBatchND":{const s=S("blockShape",n,t,e),o=S("paddings",n,t,e);return[r.spaceToBatchND(S("x",n,t,e),s,o)]}case"BatchToSpaceND":{const s=S("blockShape",n,t,e),o=S("crops",n,t,e);return[r.batchToSpaceND(S("x",n,t,e),s,o)]}case"DepthToSpace":{const s=S("blockSize",n,t,e),o=S("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(S("x",n,t,e),s,o)]}case"BroadcastTo":return[r.broadcastTo(S("x",n,t,e),S("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(S("s0",n,t,e),S("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"hash_table":return Fae(i,a,l,r);case"custom":const u=OL(i.op);if(u&&u.customExecutor)return u.customExecutor(new vae(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return du(o)?o.then(i=>[].concat(i)):[].concat(o)}class UL{constructor(t={},e={},r={},s={},o){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function WL(n,t,e,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,u=new Set(Object.keys(n).map(h=>js(h)[0]));r=r||[];const c=new Set(r.map(h=>js(h.name)[0])),d=[...t];for(;d.length>0;){const h=d.pop();if((Ou(h)||Qae(h)||ele(h))&&null==i&&(i=h,a=i.children.map(f=>f.name).filter(f=>s.has(f))),s.add(h.name),null==e[h.name]&&!u.has(h.name)&&!c.has(h.name)){if(0===h.inputs.length){o.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:n,outputs:t,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}class Z1 extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const Jae=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Zae=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Yae=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Ou(n){return Jae.has(n.op)}function Qae(n){return Zae.has(n.op)}function ele(n){return Yae.has(n.op)}class Y1{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new Y1(t.functions[r],this)})}getCompilationKey(t,e){const r=t.map(o=>o.name).sort(),s=e.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(t,e){const r=WL(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const u=e.map(d=>d.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}const a=function Gae(n,t){const{usedNodes:e,inputs:r}=t,i=m=>e.has("string"==typeof m?m:m.name);function a(m){return[...new Map(m.map(y=>[y.name,y])).values()]}const l=a([...Object.keys(r).map(m=>js(m)[0]).map(m=>n.nodes[m]),...n.weights,...n.initNodes||[]]).filter(i),u=a([...l,...Object.values(n.nodes)]).filter(i),c=new Map(u.map(m=>[m.name,m])),d={};for(const m of u){d[m.name]=d[m.name]||0;for(const y of m.children)i(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}const h=Object.entries(d).filter(([,m])=>0===m).map(([m])=>m),f=[...h];for(;h.length>0;){const m=h.pop(),y=c.get(m);for(const v of y.children.filter(i))0==--d[v.name]&&(f.push(v.name),h.push(v.name))}const g=function qae(n,t){const e=new Map(n.map(i=>[i.name,i])),r=t.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),a=e.get(i);for(const l of a.children)!e.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return n.filter(i=>s.has(i.name))}(f.map(m=>c.get(m)),l);return function Kae(n,t){const e=new Map(n.map((a,l)=>[a.name,l])),r=new Set(t.map(a=>a.name)),s=a=>r.has("string"==typeof a?a:a.name),o=new Set(n.map(a=>a.name)),i=a=>o.has("string"==typeof a?a:a.name);for(const a of n){for(const l of a.children.filter(i)){if(!e.has(l.name))throw new Z1(`Child ${l.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(l.name))throw new Z1(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!e.has(l.name))throw new Z1(`Input ${l.name} of node ${a.name} is unreachable.`);if(e.get(l.name)>e.get(a.name))throw new Z1(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}(g,l),g}(this.graph,r),l=function Xae(n){const t=new Map(n.map((a,l)=>[a.name,l])),e=Number.MAX_SAFE_INTEGER,r=n.map((a,l)=>Ou(a)?e:l),s=a=>r[t.get(a.name)]??-1,o=n.map((a,l)=>a.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let a=0;a<n.length;++a){const l=o[a];if(l===e)continue;const u=n[a],c=n[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return kr(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(h=>this.graph.nodes[js(h)[0]]),o=e.map(h=>js(h)[0]),i=new Set(o);let a=o.map(h=>this.graph.nodes[h]);0===a.length&&(a=this._outputs);const l=this.getCompilationKey(s,a);let u=this.compiledMap.get(l);null==u&&(u=this.compile(t,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const c={},d={};return H(()=>{const h=new UL(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{const[v,w]=js(y,h),x=[];x[w]=t[y],f[v]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(x))});const p=this.getFrozenTensorIds(f),{orderedNodes:g,nodeLiveUntilMap:m}=u;for(const y of g){if(f[y.name])continue;const v=zL(y,f,h,this._resourceManager);if(du(v))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);f[y.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,f,h,p,i,m.get(y.name))}return null==this.parent&&h.dispose(p),e.map(y=>Wr(y,f,h))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,o,i,a){if(!Ou(e)&&!i.has(t)){for(const l of r[t])null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length);for(const l of e.inputs){if(Ou(l))continue;const u=FL(l.name,r,s);if(null!=u)for(const c of u){if(!c||c.kept||o.has(c.id))continue;const d=a[c.id];1===d?(c.dispose(),delete a[c.id]):null!=d&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,r,s,o,i){function a(l){return Ou(l)||o.has(l.name)}if(!Ou(t)&&null!=i)for(const l of i){if(a(l))continue;const u=FL(l.name,e,r);for(const c of u)!c||c.kept||s.has(c.id)||c.dispose()}}executeAsync(t,e){var r=this;return J(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,s={},o={}){var i=this;return J(function*(){i.disposeIntermediateTensors(),r||(t=i.mapInputs(t),i.checkInputs(t),i.checkInputShapeAndType(t),e=i.mapOutputs(e),i.checkOutputs(e));try{i.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){i.keepIntermediateTensors=!1,console.warn(f.message)}const a=new UL(i.weightMap,s,o,i.functionExecutorMap,i.parseNodeNameCache);i.keepIntermediateTensors&&(i.clonedTensorsMap=i.cloneTensorMap(i.weightMap));const l=yield i.executeWithControlFlow(t,a,e,r),u=e.map(f=>Wr(f,l,a)),c=u.map(f=>f.id),d=Object.keys(t).map(f=>t[f].id),h=new Set([...c,...d,...i.weightIds]);return Object.values(l).forEach(f=>{f.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),null==i.parent&&a.dispose(h),u})()}executeFunctionAsync(t,e,r){var s=this;return J(function*(){const o=t.reduce((i,a,l)=>(i[s.inputs[l].name]=a,i),{});return s._executeAsync(o,s.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,s){var o=this;return J(function*(){const i=Object.keys(t),a=i.map(N=>o.graph.nodes[js(N)[0]]),l=r.map(N=>js(N)[0]),u=new Set(l);let c=l.map(N=>o.graph.nodes[N]);0===c.length&&(c=o._outputs);const{usedNodes:d,missingInputs:h,dynamicNode:f,syncInputs:p}=WL(t,c,o.weightMap,o._initNodes),g=[...a,...o.graph.weights,...o._initNodes||[]].map(N=>({node:N,contexts:e.currentContext})),m=Object.assign({},o.weightMap);Object.keys(t).forEach(N=>{const[I,k]=js(N),A=[];A[k]=t[N],m[I]=A});const y={},v=o.getFrozenTensorIds(m),w={};for(;g.length>0;){const N=o.processStack(a,g,e,m,w,v,u,y,d);yield Promise.all(N)}null==f&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=c.filter(N=>!Ou(N)&&!Wr(N.name,m,e)).map(N=>N.name);if(x.length>0){let N="";throw null!=f&&(N=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${N}`)}return m})()}processStack(t,e,r,s,o,i,a,l,u){const c=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&S("isConstant",d.node,s,r)&&([h]=Ta(d.node.name,r)),null==s[d.node.name]){const f=zL(d.node,s,r,this._resourceManager);h||([h]=Ta(d.node.name,r));const p=r.currentContext;du(f)?c.push(f.then(g=>(s[h]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(g)),r.currentContext=p,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u),g))):(s[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u))}else this.processChildNodes(d.node,e,r,s,o,u)}return c}processChildNodes(t,e,r,s,o,i){t.children.forEach(a=>{const[l]=Ta(a.name,r);o[l]||!i.has(a.name)||("Merge"===a.op?a.inputNames.some(u=>!!Wr(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!Wr(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[s]=js(e),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value;_(i.length===r.shape.length&&r.shape.every((l,u)=>-1===i[u]||i[u]===l),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&_(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const s={};for(const o in t){const i=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[o];null!=i?s[i.name]=t[o]:s[o]=t[o]}return s}checkInputs(t){const e=Object.keys(t).filter(r=>{const[s]=js(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,s;const o=null===(s=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===s?void 0:s[e];return null!=o?o.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=js(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class tle{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class HL{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},r=Ye){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new tle}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return du(t)?t.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}loadStreaming(t){var e=this;return J(function*(){if(null==t.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const r=yield VO(t.getWeightStream(),t.weightSpecs);return e.loadWithWeightMap(t,r)})()}loadWithWeightMap(t,e){this.artifacts=t;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const o=this.artifacts.userDefinedMetadata;null!=o.signature&&(s=o.signature),null!=o.structuredOutputKeys&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Y1(ML.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const o=ML.Instance.transformGraph(t.modelInitializer);this.initializer=new Y1(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return J(function*(){if("string"==typeof t){const s=r.io.getSaveHandlers(t);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof on?[t]:t).forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return J(function*(){const s=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(s)})()}normalizeInputs(t){var e;if(!(t instanceof on||Array.isArray(t))){const o=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=o)for(const i in o){const a=o[i];null!=a.resourceId&&(t[i]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,i)=>{var a,l,u;const c=null===(u=null===(l=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===l?void 0:l[i])||void 0===u?void 0:u.resourceId;return o[i]=null!=c?this.resourceIdToCapturedInput[c]:t[s++],o},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return J(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let s=0;s<r.length;s++)this.resourceIdToCapturedInput[e[r[s]].resourceId]=t[s]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return J(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ut(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function GT(n){return qT.apply(this,arguments)}function qT(){return(qT=J(function*(n,t={},e=Ye){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=sle(n));const r=new HL(n,t,e);return yield r.load(),r})).apply(this,arguments)}function sle(n){return n.endsWith("/")||(n+="/"),`${n}model.json?tfjs-format=file`}function Ve(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&_("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const Rle=aN;let Ole=(()=>{class n extends CC{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new sO(this,Us())}write(e,r,s){this.firstUse&&(this.firstUse=!1,G().get("IS_NODE")&&lo("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&cf(s[0])){const i=s.map(a=>rl(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return J(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?xa(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):function MK(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>sl(o));return Tt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Tt(e.shape,e.dtype,r)}makeOutput(e,r,s){return Us().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return J(function*(){const r=Ss();return e(),{kernelMs:Ss()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ve([e],"where");const r=this.readSync(e.dataId);return Rle(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function Hi(n){return(t,e,r)=>{const s=Xn(e,t.length);for(let o=0;o<t.length;++o)s[o]=n(t[o],r);return s}}function Yt(n,t,e){return Tl(n,Hi(t),e)}function Tl(n,t,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;Ve(i,n);const a=o,l=a.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Ca(l)}else u=l;const c=e||i.dtype,d=t(u,c,s);return a.makeTensorInfo(i.shape,c,d)}}FO("cpu",()=>new Ole,1);const t$=Yt(Nf,n=>n>=0?n:Math.exp(n)-1),Mle={kernelName:Nf,backendName:"cpu",kernelFunc:t$};function ji(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Ple={kernelName:Af,backendName:"cpu",kernelFunc:ji};function n$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r;Ve([s],"leakyRelu");const i=Z(s.shape),a=e.data.get(s.dataId).values,l=Lr("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(s.shape,"float32",l)}const Lle={kernelName:Hy,backendName:"cpu",kernelFunc:n$};function tr(n){return(t,e,r,s,o)=>{const i=mt(t,e),a=i.length,l=Ge(i),c=Lr(o,Z(i)),d=t.length,h=e.length,f=Ge(t),p=Ge(e),g=ad(t,i),m=ad(e,i);if(g.length+m.length===0)for(let y=0;y<c.length;++y)c[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const v=Jc(y,a,l),w=v.slice(-d);g.forEach(k=>w[k]=0);const x=Ri(w,d,f),N=v.slice(-h);m.forEach(k=>N[k]=0);const I=Ri(N,h,p);c[y]=n(r[x],s[I])}return[c,i]}}const $le=tr((n,t)=>n<0?t*n:n);function r$(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;Ve([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,l]=$le(r.shape,s.shape,o,i,"float32");return e.makeTensorInfo(l,"float32",a)}const Vle={kernelName:c0,backendName:"cpu",kernelFunc:r$},s$=Yt(Wf,n=>Math.max(0,n)),Ble={kernelName:Wf,backendName:"cpu",kernelFunc:s$},o$=Yt(Hf,n=>Math.min(Math.max(0,n),6)),zle={kernelName:Hf,backendName:"cpu",kernelFunc:o$},Ule=Hi(n=>1/(1+Math.exp(-n))),i$=Yt(Zf,n=>1/(1+Math.exp(-n))),Wle={kernelName:Zf,backendName:"cpu",kernelFunc:i$};function nb(n,t,e,r,s){if("linear"===e)return ji({inputs:{x:t},backend:n});if("relu"===e)return s$({inputs:{x:t},backend:n});if("elu"===e)return t$({inputs:{x:t},backend:n});if("relu6"===e)return o$({inputs:{x:t},backend:n});if("prelu"===e)return r$({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return n$({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return i$({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Gs(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const Hle={kernelName:LC,backendName:"cpu",kernelFunc:Gs};function rb(n,t,e="float32"){if("complex64"===e)return Gs({inputs:{real:rb(n,t,"float32"),imag:rb(n,t,"float32")},backend:n});const r=Kr(Z(t),e);return n.makeTensorInfo(t,e,r)}function Fu(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const jle={kernelName:b2,backendName:"cpu",kernelFunc:Fu};function a$(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=pu([0],e),[o,i]=tr((a,l)=>a!==l?1:0)(t,[],n,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Il(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return ji({inputs:{x:s},backend:e});const c=rb(e,s.shape,s.dtype),d=Il({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),h=Gs({inputs:{real:d,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const c=Fu({inputs:{input:s},backend:e}),d=Il({inputs:{x:c},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(c),d}if(!lO(s.dtype,o)){const c=ji({inputs:{x:s},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=e.data.get(s.dataId).values,[a,l,u]=a$(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}const Gle={kernelName:bf,backendName:"cpu",kernelFunc:Il};function vr(n,t,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;Ve([i,a],n);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d="string"===i.dtype?Ca(u):u,h="string"===i.dtype?Ca(c):c,f=r||i.dtype,[p,g]=t(i.shape,a.shape,d,h,f);return l.makeTensorInfo(g,f,p)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const u=Il({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,f=l.data.get(c.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,g=Il({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),v=m.complexTensorInfos.imag,w=l.data.get(m.complexTensorInfos.real.dataId).values,x=l.data.get(v.dataId).values,[N,I,k]=e(i.shape,a.shape,f,p,w,x),A=l.makeTensorInfo(k,"float32",N),R=l.makeTensorInfo(k,"float32",I),F=Gs({inputs:{real:A,imag:R},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(R),F}{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,f]=t(i.shape,a.shape,u,c,d);return l.makeTensorInfo(f,d,h)}}}function eI(n){return(t,e,r,s,o,i)=>{const a=mt(t,e),l=Z(a),u=a.length,c=Ge(a),d=Lr("float32",l),h=Lr("float32",l),f=ad(t,a),p=ad(e,a),g=xa(r,s),m=xa(o,i),y=t.length,v=Ge(t),w=e.length,x=Ge(e);if(f.length+p.length===0)for(let N=0;N<d.length;N++){const I=N%g.length,k=N%m.length,A=n(g[2*I],g[2*I+1],m[2*k],m[2*k+1]);d[N]=A.real,h[N]=A.imag}else for(let N=0;N<d.length;N++){const I=Jc(N,u,c),k=I.slice(-y);f.forEach(q=>k[q]=0);const A=Ri(k,y,v),R=I.slice(-w);p.forEach(q=>R[q]=0);const F=Ri(R,w,x),U=n(g[2*A],g[2*A+1],m[2*F],m[2*F+1]);d[N]=U.real,h[N]=U.imag}return[d,h,a]}}const l$=tr((n,t)=>n+t),qle=eI((n,t,e,r)=>({real:n+e,imag:t+r})),Td=vr(Zc,l$,qle),Kle={kernelName:Zc,backendName:"cpu",kernelFunc:Td};function gn(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,i=Z(s.shape),a=aO(o,i),l=Z(a);_(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const u=e.data.get(s.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Xle={kernelName:h0,backendName:"cpu",kernelFunc:gn};function u$(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;Ve([s,o],"matMul");const l=s.shape.length,u=o.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[u-1]:o.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],f=a?o.shape[u-2]:o.shape[u-1],p=s.shape.slice(0,-2),g=o.shape.slice(0,-2),m=Z(p),y=Z(g),w=mt(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,f]);_(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const N=a?[y,f,d]:[y,d,f],I=gn({inputs:{x:s},backend:e,attrs:{shape:i?[m,c,h]:[m,h,c]}}),k=gn({inputs:{x:o},backend:e,attrs:{shape:N}}),A=i?I.shape[1]:I.shape[2],R=i?I.shape[2]:I.shape[1],F=a?k.shape[1]:k.shape[2],U=Math.max(m,y),q=e.data.get(I.dataId).values,K=e.data.get(k.dataId).values,Y=Ge(I.shape),Q=Ge(k.shape),[se,ie,te]=i?[Y[0],1,Y[1]]:[Y[0],Y[1],1],[ae,pe,me]=a?[1,Q[1],Q[0]]:[Q[1],1,Q[0]],we=R*F,ye=Tt([U,R,F],I.dtype),ke=ye.values,xe=e.blockSize;for(let Fe=0;Fe<U;Fe++){const qe=Fe%m,ot=Fe%y;for(let et=0;et<R;et+=xe){const It=Math.min(et+xe,R);for(let kt=0;kt<F;kt+=xe){const Qt=Math.min(kt+xe,F);for(let yn=0;yn<A;yn+=xe){const jn=Math.min(yn+xe,A);for(let bn=et;bn<It;bn++)for(let ln=kt;ln<Qt;ln++){let $n=0;for(let kn=yn;kn<jn;kn++)$n+=q[qe*se+bn*ie+kn*te]*K[kn*ae+ln*pe+ot*me];ke[Fe*we+(bn*F+ln)]+=$n}}}}}return e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(k),e.makeTensorInfo(w,ye.dtype,ye.values)}const Jle={kernelName:Ey,backendName:"cpu",kernelFunc:u$},Yle={kernelName:I0,backendName:"cpu",kernelFunc:function Zle(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,f,p;const g=[];h=u$({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(f=Td({inputs:{a:h,b:i},backend:e}),g.push(h),h=f),c&&(p=nb(e,h,c,a,d),g.push(h),h=p);for(const y of g)e.disposeIntermediateTensorInfo(y);return h}};function c$(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Qle={kernelName:Cy,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Ve(t,"abs");let r=new Float32Array(Z(t.shape));return r=c$(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},eue=Yt(df,n=>Math.acos(n)),tue={kernelName:df,backendName:"cpu",kernelFunc:eue},nue=Yt(hf,n=>Math.acosh(n)),rue={kernelName:hf,backendName:"cpu",kernelFunc:nue},oue={kernelName:Sy,backendName:"cpu",kernelFunc:function sue(n){const{inputs:t,backend:e}=n,r=t;Ve(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=Tt(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function tI(n,t,e,r,s){const o=t.length,i=Z(t),a=Ge(t),l=Ge(s),u=Lr(e,Z(s));for(let c=0;c<i;++c){const d=Jc(c,o,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];u[Ri(h,o,l)]=n[c]}return u}function ks(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:o}=e;Ve(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const u=tI(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const iue={kernelName:Yc,backendName:"cpu",kernelFunc:ks},lue={kernelName:"All",backendName:"cpu",kernelFunc:function aue(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Ve(s,"all");const a=Rt(o,s.shape);let l=a;const u=Pn(l,s.shape.length);let c=s;null!=u&&(c=ks({inputs:{x:s},backend:e,attrs:{perm:u}}),l=Zn(l.length,s.shape.length)),Br("all",l,c.shape.length);const[d,h]=Rr(c.shape,l),f=Z(h),p=Kr(Z(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const v=y*f;let w=g[v];for(let x=0;x<f;++x){const N=g[v+x];w=w&&N}p[y]=w}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,p);if(i){const v=gn({inputs:{x:m},backend:e,attrs:{shape:Jn(d,a)}});return e.disposeIntermediateTensorInfo(m),v}return m}},cue={kernelName:"Any",backendName:"cpu",kernelFunc:function uue(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Ve(s,"any");const a=Rt(o,s.shape);let l=a;const u=Pn(l,s.shape.length);let c=s;null!=u&&(c=ks({inputs:{x:s},backend:e,attrs:{perm:u}}),l=Zn(l.length,s.shape.length)),Br("any",l,c.shape.length);const[d,h]=Rr(c.shape,l),f=Z(h),p=Kr(Z(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const v=y*f;let w=g[v];for(let x=0;x<f;++x){const N=g[v+x];w=w||N}p[y]=w}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,p);if(i){const v=gn({inputs:{x:m},backend:e,attrs:{shape:Jn(d,a)}});return e.disposeIntermediateTensorInfo(m),v}return m}},hue={kernelName:Ny,backendName:"cpu",kernelFunc:function due(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;Ve(s,"argMax");let i=Rt(o,s.shape);const a=Pn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=ks({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=Zn(i.length,l.shape.length)),i=[i[0]],Br("argMax",i,l.shape.length);const[c,d]=Rr(l.shape,i),f=Kr(Z(c),"int32"),p=Z(d),g=e.data.get(l.dataId).values;for(let m=0;m<f.length;++m){const y=m*p;let v=g[y],w=0;for(let x=0;x<p;++x){const N=g[y+x];N>v&&(v=N,w=x)}f[m]=w}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",f)}},pue={kernelName:Ty,backendName:"cpu",kernelFunc:function fue(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;Ve(s,"argMin");let i=Rt(o,s.shape);const a=Pn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=ks({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=Zn(i.length,l.shape.length)),i=[i[0]],Br("argMin",i,l.shape.length);const[c,d]=Rr(l.shape,i),f=Kr(Z(c),"int32"),p=Z(d),g=e.data.get(l.dataId).values;for(let m=0;m<f.length;++m){const y=m*p;let v=g[y],w=0;for(let x=0;x<p;++x){const N=g[y+x];N<v&&(v=N,w=x)}f[m]=w}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",f)}},mue=Yt(ff,n=>Math.asin(n)),gue={kernelName:ff,backendName:"cpu",kernelFunc:mue},yue=Yt(pf,n=>Math.asinh(n)),bue={kernelName:pf,backendName:"cpu",kernelFunc:yue},vue=Yt(mf,n=>Math.atan(n)),wue={kernelName:mf,backendName:"cpu",kernelFunc:vue},xue=tr((n,t)=>Math.atan2(n,t)),Cue=vr(yf,xue),Sue={kernelName:yf,backendName:"cpu",kernelFunc:Cue},Nue=Yt(gf,n=>Math.atanh(n)),Tue={kernelName:gf,backendName:"cpu",kernelFunc:Nue};function nI(n,t,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Tt(s.outShape,e),m=g.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],v=s.outShape[2]*s.outShape[3],w=s.outShape[3];for(let x=0;x<s.batchSize;++x){const N=x*y,I=x*r[0];for(let k=0;k<s.inChannels;++k)for(let A=0;A<s.outHeight;++A){const R=A*i-h,F=Math.max(0,R),U=Math.min(s.inHeight,c+R),q=N+A*v;for(let K=0;K<s.outWidth;++K){const Y=K*a-f,Q=Math.max(0,Y),se=Math.min(s.inWidth,d+Y);let ie=p,te=0,ae=0;for(let me=F;me<U;me+=l){const we=I+me*r[1];for(let ye=Q;ye<se;ye+=u){const xe=n[we+ye*r[2]+k];"max"===o&&xe>ie?ie=xe:"avg"===o&&(te+=xe,ae++)}if(isNaN(ie))break}m[q+K*w+k]="avg"===o?te/ae:ie}}}return g}function d$(n,t,e,r,s=!1,o=!1){const i=Tt(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,g=Tt(t,e,n);for(let m=0;m<r.batchSize;++m)for(let y=0;y<r.inChannels;++y)for(let v=0;v<r.outHeight;++v){const w=v*a-f;let x=w;for(;x<0;)x+=u;const N=Math.min(r.inHeight,d+w);for(let I=0;I<r.outWidth;++I){const k=I*l-p;let A=k;for(;A<0;)A+=c;const R=Math.min(r.inWidth,h+k);let F=Number.NEGATIVE_INFINITY,U=-1;for(let q=x;q<N;q+=u){const K=q-w;for(let Y=A;Y<R;Y+=c){const Q=Y-k,se=g.get(m,q,Y,y);se>F&&(F=se,U=s?o?((m*r.inHeight+q)*r.inWidth+Y)*r.inChannels+y:(q*r.inWidth+Y)*r.inChannels+y:K*h+Q)}}i.set(U,m,v,I,y)}}return i}function h$(n,t,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,g=s.padInfo.front,m=s.padInfo.top,y=s.padInfo.left,v="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Tt(s.outShape,e),x=w.values,N=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let R=0;R<s.batchSize;++R){const F=R*N,U=R*r[0];for(let q=0;q<s.inChannels;++q)for(let K=0;K<s.outDepth;++K){const Y=K*i-g;let Q=Y;for(;Q<0;)Q+=u;const se=Math.min(s.inDepth,h+Y),ie=F+K*I;for(let te=0;te<s.outHeight;++te){const ae=te*a-m;let pe=ae;for(;pe<0;)pe+=c;const me=Math.min(s.inHeight,f+ae),we=ie+te*k;for(let ye=0;ye<s.outWidth;++ye){const ke=ye*l-y;let xe=ke;for(;xe<0;)xe+=d;const Fe=Math.min(s.inWidth,p+ke),qe=we+ye*A;let ot=v,et=0,It=0;for(let Qt=Q;Qt<se;Qt+=u){const yn=U+Qt*r[1];for(let jn=pe;jn<me;jn+=c){const bn=yn+jn*r[2];for(let ln=xe;ln<Fe;ln+=d){const kn=n[bn+ln*r[3]+q];if("max"===o&&kn>ot?ot=kn:"avg"===o&&(et+=kn,It++),isNaN(ot))break}if(isNaN(ot))break}if(isNaN(ot))break}x[qe+q]="avg"===o?et/Math.max(It,1):ot}}}}return w}const Eue={kernelName:Iy,backendName:"cpu",kernelFunc:function _ue(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Ve(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(Vr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Pt(c.inShape,c.outShape))d=ji({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Ge(s.shape),p=nI(h,0,s.dtype,f,c,"avg");d=e.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},kue={kernelName:_y,backendName:"cpu",kernelFunc:function Due(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ve(s,"avgPool3d");const c=ba(s.shape,o,i,1,a,l,u),h=h$(e.data.get(s.dataId).values,0,s.dtype,Ge(s.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},Rue={kernelName:FC,backendName:"cpu",kernelFunc:function Aue(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ve([s,o],"avgPool3DGrad");const c=ba(o.shape,i,a,1,l,u),d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,p=c.filterDepth,g=c.filterHeight,m=c.filterWidth,y=c.dilationDepth,v=c.dilationHeight,w=c.dilationWidth,x=c.effectiveFilterDepth,N=c.effectiveFilterHeight,I=c.effectiveFilterWidth,k=x-1-c.padInfo.front,A=I-1-c.padInfo.left,R=N-1-c.padInfo.top,F=Tt(o.shape,"float32"),U=1/(p*g*m),q=e.bufferSync(s);for(let K=0;K<c.batchSize;++K)for(let Y=0;Y<c.inChannels;++Y)for(let Q=0;Q<c.inDepth;++Q)for(let se=0;se<c.inHeight;++se)for(let ie=0;ie<c.inWidth;++ie){const te=Q-k,ae=se-R,pe=ie-A;let me=0;for(let we=0;we<x;we+=y){const ye=(te+we)/d;if(!(ye<0||ye>=c.outDepth||Math.floor(ye)!==ye))for(let ke=0;ke<N;ke+=v){const xe=(ae+ke)/h;if(!(xe<0||xe>=c.outHeight||Math.floor(xe)!==xe))for(let Fe=0;Fe<I;Fe+=w){const qe=(pe+Fe)/f;qe<0||qe>=c.outWidth||Math.floor(qe)!==qe||(me+=q.get(K,ye,xe,qe,Y))}}}F.set(me*U,K,Q,se,ie,Y)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}},Fue={kernelName:OC,backendName:"cpu",kernelFunc:function Oue(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o;Ve([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Ro(i.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,f=c.filterHeight,p=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=v-1-c.padInfo.left,x=y-1-c.padInfo.top,N=Tt(i.shape,"float32"),I=1/(f*p),k=e.data.get(s.dataId).values,A=Tt(s.shape,"float32",k);for(let R=0;R<c.batchSize;++R)for(let F=0;F<c.inChannels;++F)for(let U=0;U<c.inHeight;++U)for(let q=0;q<c.inWidth;++q){const K=U-x,Y=q-w;let Q=0;for(let se=0;se<y;se+=g){const ie=(K+se)/d;if(!(ie<0||ie>=c.outHeight||Math.floor(ie)!==ie))for(let te=0;te<v;te+=m){const ae=(Y+te)/h;ae<0||ae>=c.outWidth||Math.floor(ae)!==ae||(Q+=A.get(R,ie,ae,F))}}N.set(Q*I,R,U,q,F)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},Pue={kernelName:zy,backendName:"cpu",kernelFunc:function Mue(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:o,offset:i,mean:a,variance:l}=t;_(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ve([s,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=o?e.data.get(o.dataId).values:new Float32Array([1]),p=i?e.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=p.length,y=f.length,v=h.length,w=d.length;let x=0,N=0,I=0,k=0;for(let A=0;A<c.length;++A)g[A]=p[x++]+(c[A]-d[N++])*f[I++]/Math.sqrt(h[k++]+u),x>=m&&(x=0),N>=w&&(N=0),I>=y&&(I=0),k>=v&&(k=0);return e.makeTensorInfo(s.shape,s.dtype,g)}};function f$(n,t,e,r,s){const o=IS(r,t,e),i=Z(e),a=Ge(r);if(o){const d=_S(t,a);return"string"===s?n.slice(d,d+i):n.subarray(d,d+i)}const u=Tt(r,s,"string"===s?Ca(n):n),c=Tt(e,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),f=h.map((p,g)=>p+t[g]);c.set(u.get(...f),...h)}return"string"===s?iP(c.values):c.values}function Mu(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:i}=r;Ve(s,"slice");const[a,l]=W0(s,o,i);NS(s,a,l);const c=f$(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,c)}const Lue={kernelName:y0,backendName:"cpu",kernelFunc:Mu},Vue={kernelName:Dy,backendName:"cpu",kernelFunc:function $ue(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:i}=r;Ve([s],"batchToSpaceND");const a=o.reduce((y,v)=>y*v),l=Tp(s.shape,o,a),u=Ip(l.length,o.length),c=_p(s.shape,o,a),d=NN(i,o.length),h=TN(c,i,o.length),f=gn({inputs:{x:s},backend:e,attrs:{shape:l}}),p=ks({inputs:{x:f},backend:e,attrs:{perm:u}}),g=gn({inputs:{x:p},backend:e,attrs:{shape:c}}),m=Mu({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),m}};function rI(n,t,e,r,s){const o=Z(r),i=Kr(s,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?t[a]:1)}return i}function p$(n,t,e,r=!1){const s=n.shape[0],o=n.shape[1],i=Tt([s,e],t.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||i.set(r?1:t.size>0?i.get(a,u)+t.get(a,l):i.get(a,u)+1,a,u)}return i}const zue={kernelName:MC,backendName:"cpu",kernelFunc:function Bue(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i}=r,u=rI(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},m$=tr((n,t)=>n&t),Uue=vr(ky,m$),Wue={kernelName:ky,backendName:"cpu",kernelFunc:Uue},jue={kernelName:PC,backendName:"cpu",kernelFunc:function Hue(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=mt(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},g$=Hi(n=>Math.ceil(n)),Gue=Tl(vf,g$),que={kernelName:vf,backendName:"cpu",kernelFunc:Gue},Kue=Yt(wf,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),Xue={kernelName:wf,backendName:"cpu",kernelFunc:Kue},Jue={kernelName:Ay,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(Z(t.shape)),s=e.data.get(t.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],l[u]);return e.makeOutput(r,t.shape,"float32")}};function y$(n,t,e,r){const s=Xn(e,Z(t));if(r&&"string"!==e){let o=0;n.forEach(i=>{const a=Z(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a="string"===e?Ca(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*t[1]+o;for(let d=0;d<i.shape[1];++d)s[c+d]=a[l++]}o+=i.shape[1]})}return s}function Id(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const Zue={kernelName:s2,backendName:"cpu",kernelFunc:Id};function _d(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=Rt(s,t[0].shape)[0];xN(t.map(g=>g.shape),o);let a=Li(t.map(g=>g.shape),o);if(0===Z(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(g=>Z(g.shape)>0);if(1===l.length)return ji({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const g=l.map(x=>Fu({inputs:{input:x},backend:e})),m=l.map(x=>Id({inputs:{input:x},backend:e})),y=_d({inputs:g,backend:e,attrs:{axis:o}}),v=_d({inputs:m,backend:e,attrs:{axis:o}}),w=Gs({inputs:{real:y,imag:v},backend:e});return g.forEach(x=>e.disposeIntermediateTensorInfo(x)),m.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(v),w}const u=l.map(g=>{const m=Z(g.shape.slice(o));return gn({inputs:{x:g},backend:e,attrs:{shape:[-1,m]}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=Li(u.map(g=>g.shape),1);const h=y$(c,a,t[0].dtype,1===u[0].shape[0]),f=Li(l.map(g=>g.shape),o),p=e.makeTensorInfo(f,t[0].dtype,h);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}const Yue={kernelName:Ry,backendName:"cpu",kernelFunc:_d};function b$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Ve([s,o],"conv2d");const d=va(l),h=Ar(s.shape,o.shape,i,u,a,c,!1,d),f=h.filterHeight,p=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,y=h.padInfo.left,v=h.padInfo.top,w="channelsLast"===h.dataFormat,x=new hr(h.outShape,s.dtype),N=Ge(s.shape),I=Ge(o.shape),k=N[0],A=w?N[1]:N[2],R=w?N[2]:1,F=w?1:N[1],U=x.strides[0],q=w?x.strides[1]:x.strides[2],K=w?x.strides[2]:1,Y=w?1:x.strides[1],Q=e.data.get(s.dataId).values,se=e.data.get(o.dataId).values,ie=x.values;for(let te=0;te<h.batchSize;++te){const ae=te*k,pe=te*U;for(let me=0;me<h.outHeight;++me){const we=pe+me*q,ye=me*h.strideHeight-v;for(let ke=0;ke<f;++ke){const xe=ye+ke*g;if(xe<0||xe>=h.inHeight)continue;const Fe=ke*I[0],qe=ae+xe*A;for(let ot=0;ot<h.outWidth;++ot){const et=we+ot*K,It=ot*h.strideWidth-y;for(let kt=0;kt<p;++kt){const Qt=It+kt*m;if(Qt<0||Qt>=h.inWidth)continue;const jn=qe+Qt*R;let bn=Fe+kt*I[1];for(let ln=0;ln<h.inChannels;++ln){const $n=Q[jn+ln*F];for(let kn=0;kn<h.outChannels;++kn)ie[et+kn*Y]+=$n*se[bn+kn];bn+=h.outChannels}}}}}}return e.makeTensorInfo(x.shape,x.dtype,ie)}const Que={kernelName:Oy,backendName:"cpu",kernelFunc:b$},tce={kernelName:$C,backendName:"cpu",kernelFunc:function ece(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Ve([s,o],"conv2dBackpropFilter");const d=va(l),h=Ar(s.shape,c,i,1,a,u,!1,d),{strideHeight:f,strideWidth:p,filterHeight:g,filterWidth:m}=h,y="channelsLast"===h.dataFormat,v=new hr(h.filterShape,"float32"),w=h.padInfo.left,x=h.padInfo.top,N=e.data.get(s.dataId).values,I=e.data.get(o.dataId).values,k=new hr(s.shape,s.dtype,N),A=new hr(o.shape,o.dtype,I);for(let R=0;R<g;++R){const F=Math.max(0,Math.ceil((x-R)/f)),U=Math.min(h.outHeight,(h.inHeight+x-R)/f);for(let q=0;q<m;++q){const K=Math.max(0,Math.ceil((w-q)/p)),Y=Math.min(h.outWidth,(h.inWidth+w-q)/p);for(let Q=0;Q<h.inChannels;++Q)for(let se=0;se<h.outChannels;++se){let ie=0;for(let te=0;te<h.batchSize;++te)for(let ae=F;ae<U;++ae){const pe=R+ae*f-x;for(let me=K;me<Y;++me){const we=q+me*p-w;ie+=y?k.get(te,pe,we,Q)*A.get(te,ae,me,se):k.get(te,Q,pe,we)*A.get(te,se,ae,me)}}v.set(ie,R,q,Q,se)}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},rce={kernelName:Fy,backendName:"cpu",kernelFunc:function nce(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Ve([s,o],"conv2dBackpropInput");const d=Ge(o.shape),h=Ge(s.shape);let f=va(u);const p=Ar(i,o.shape,a,1,l,c,!1,f),g=new hr(p.inShape,"float32"),m=g.values,y=e.data.get(s.dataId).values,v=e.data.get(o.dataId).values,[w,x,N]=d,{batchSize:I,filterHeight:k,filterWidth:A,inChannels:R,inHeight:F,inWidth:U,outChannels:q,outHeight:K,outWidth:Y,strideHeight:Q,strideWidth:se}=p;f=p.dataFormat;const ie=k-1-p.padInfo.top,te=A-1-p.padInfo.left,ae="channelsLast"===f,pe=g.strides[0],me=ae?g.strides[1]:g.strides[2],we=ae?g.strides[2]:1,ye=ae?1:g.strides[1],ke=h[0],xe=ae?h[1]:h[2],Fe=ae?h[2]:1,qe=ae?1:h[1];for(let ot=0;ot<I;++ot)for(let et=0;et<R;++et)for(let It=0;It<F;++It){const kt=It-ie,Qt=Math.max(0,Math.ceil(kt/Q)),yn=Math.min(K,(k+kt)/Q);for(let jn=0;jn<U;++jn){const bn=jn-te,ln=Math.max(0,Math.ceil(bn/se)),$n=Math.min(Y,(A+bn)/se);let kn=0;for(let jr=Qt;jr<yn;++jr){const Pl=jr*Q-kt;for(let go=ln;go<$n;++go){const wi=ke*ot+xe*jr+Fe*go,Oa=w*(k-1-Pl)+x*(A-1-(go*se-bn))+N*et;for(let Ll=0;Ll<q;++Ll)kn+=y[wi+qe*Ll]*v[Oa+Ll]}}m[pe*ot+me*It+we*jn+ye*et]=kn}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},oce={kernelName:My,backendName:"cpu",kernelFunc:function sce(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r;Ve([s,o],"conv3d");const u=dl(s.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:g,padInfo:m}=u,y=m.front,v=m.left,w=m.top,x=new hr(u.outShape,s.dtype),N=e.data.get(s.dataId).values,I=e.data.get(o.dataId).values,k=x.values,A=Ge(s.shape),R=Ge(o.shape);for(let F=0;F<u.batchSize;++F){const U=F*A[0],q=F*x.strides[0];for(let K=0;K<u.outDepth;++K){const Y=q+K*x.strides[1],Q=K*u.strideDepth-y;for(let se=0;se<c;++se){const ie=Q+se*f;if(ie<0||ie>=u.inDepth)continue;const te=se*R[0],ae=U+ie*A[1];for(let pe=0;pe<u.outHeight;++pe){const me=Y+pe*x.strides[2],we=pe*u.strideHeight-w;for(let ye=0;ye<d;++ye){const ke=we+ye*p;if(ke<0||ke>=u.inHeight)continue;const xe=te+ye*R[1],Fe=ae+ke*A[2];for(let qe=0;qe<u.outWidth;++qe){const ot=me+qe*u.outChannels,et=qe*u.strideWidth-v;for(let It=0;It<h;++It){const kt=et+It*g;if(kt<0||kt>=u.inWidth)continue;const yn=Fe+kt*u.inChannels;let jn=xe+It*R[2];for(let bn=0;bn<u.inChannels;++bn){const ln=N[yn+bn];for(let $n=0;$n<u.outChannels;++$n)k[ot+$n]+=ln*I[jn+$n];jn+=u.outChannels}}}}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},ace={kernelName:VC,backendName:"cpu",kernelFunc:function ice(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:l}=r;Ve([s,o],"conv3dBackpropFilterV2");const u=Ge(s.shape),c=Ge(o.shape),d=dl(s.shape,l,i,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,g=d.filterDepth,m=d.filterHeight,y=d.filterWidth,v=new hr(d.filterShape,"float32"),w=v.values,[x,N,I,k]=v.strides,A=e.data.get(o.dataId).values,[R,F,U,q]=c,K=e.data.get(s.dataId).values,[Y,Q,se,ie]=u,te=d.padInfo.front,ae=d.padInfo.left,pe=d.padInfo.top;for(let me=0;me<g;++me){const we=Math.max(0,Math.ceil((te-me)/h)),ye=Math.min(d.outDepth,(d.inDepth+te-me)/h),ke=me*x;for(let xe=0;xe<m;++xe){const Fe=Math.max(0,Math.ceil((pe-xe)/f)),qe=Math.min(d.outHeight,(d.inHeight+pe-xe)/f),ot=xe*N+ke;for(let et=0;et<y;++et){const It=Math.max(0,Math.ceil((ae-et)/p)),kt=Math.min(d.outWidth,(d.inWidth+ae-et)/p),Qt=et*I+ot;for(let yn=0;yn<d.inChannels;++yn){const jn=yn*k+Qt;for(let bn=0;bn<d.outChannels;++bn){let ln=0;for(let $n=0;$n<d.batchSize;++$n){const kn=$n*Y,Ra=$n*R;for(let jr=we;jr<ye;++jr){const go=(me+jr*h-te)*Q+kn,Gu=jr*F+Ra;for(let wi=Fe;wi<qe;++wi){const Ll=(xe+wi*f-pe)*se+go,$l=wi*U+Gu;for(let Vl=It;Vl<kt;++Vl)ln+=K[(et+Vl*p-ae)*ie+Ll+yn]*A[Vl*q+$l+bn]}}}w[jn+bn]=ln}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},uce={kernelName:BC,backendName:"cpu",kernelFunc:function lce(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:l}=r;Ve([s],"conv3dBackpropInputV2");const u=Ge(s.shape),c=Ge(o.shape),d=dl(l,o.shape,a,1,i),h=new hr(d.inShape,"float32"),f=h.values,[p,g,m,y]=h.strides,v=e.data.get(s.dataId).values,[w,x,N,I]=u,k=e.data.get(o.dataId).values,[A,R,F,U]=c,{batchSize:q,filterDepth:K,filterHeight:Y,filterWidth:Q,inChannels:se,inDepth:ie,inHeight:te,inWidth:ae,outChannels:pe,outDepth:me,outHeight:we,outWidth:ye,strideDepth:ke,strideHeight:xe,strideWidth:Fe}=d,qe=K-1-d.padInfo.front,ot=Y-1-d.padInfo.top,et=Q-1-d.padInfo.left;for(let It=0;It<q;++It)for(let kt=0;kt<se;++kt)for(let Qt=0;Qt<ie;++Qt){const yn=Qt-qe,jn=Math.max(0,Math.ceil(yn/ke)),bn=Math.min(me,(K+yn)/ke);for(let ln=0;ln<te;++ln){const $n=ln-ot,kn=Math.max(0,Math.ceil($n/xe)),Ra=Math.min(we,(Y+$n)/xe);for(let jr=0;jr<ae;++jr){const Pl=jr-et,go=Math.max(0,Math.ceil(Pl/Fe)),Gu=Math.min(ye,(Q+Pl)/Fe);let wi=0;for(let Oa=jn;Oa<bn;++Oa){const Ll=Oa*ke-yn;for(let $l=kn;$l<Ra;++$l){const Vl=$l*xe-$n;for(let gm=go;gm<Gu;++gm){const C_=w*It+x*Oa+N*$l+I*gm,tIe=A*(K-1-Ll)+R*(Y-1-Vl)+F*(Q-1-(gm*Fe-Pl))+U*kt;for(let av=0;av<pe;++av)wi+=v[C_+av]*k[tIe+av]}}}f[p*It+g*Qt+m*ln+y*jr+kt]=wi}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},cce=Yt(xf,n=>Math.cos(n)),dce={kernelName:xf,backendName:"cpu",kernelFunc:cce},hce=Yt(Cf,n=>Math.cosh(n)),fce={kernelName:Cf,backendName:"cpu",kernelFunc:hce},mce={kernelName:UC,backendName:"cpu",kernelFunc:function pce(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,h,f]=s.shape,p=o.shape[0],[g,m]=a,y=Tt([p,g,m,f],"float32"),v=e.data.get(o.dataId).values,w=e.data.get(i.dataId).values,x=e.data.get(s.dataId).values,N=Ge(s.shape),I=Ge(y.shape);for(let k=0;k<p;k++){const A=4*k,R=v[A],F=v[A+1],U=v[A+2],q=v[A+3],K=w[k];if(K>=c)continue;const Y=g>1?(U-R)*(d-1)/(g-1):0,Q=m>1?(q-F)*(h-1)/(m-1):0;for(let se=0;se<g;se++){const ie=g>1?R*(d-1)+se*Y:.5*(R+U)*(d-1);if(ie<0||ie>d-1)for(let te=0;te<m;te++)for(let ae=0;ae<f;ae++)y.values[ae+te*I[2]+se*I[1]+k*I[0]]=u;else if("bilinear"===l){const te=Math.floor(ie),ae=Math.ceil(ie),pe=ie-te;for(let me=0;me<m;me++){const we=m>1?F*(h-1)+me*Q:.5*(F+q)*(h-1);if(we<0||we>h-1){for(let Fe=0;Fe<f;Fe++)y.values[Fe+me*I[2]+se*I[1]+k*I[0]]=u;continue}const ye=Math.floor(we),ke=Math.ceil(we),xe=we-ye;for(let Fe=0;Fe<f;Fe++){let qe=Fe+ye*N[2]+te*N[1]+K*N[0];const ot=x[qe];qe=Fe+ke*N[2]+te*N[1]+K*N[0];const et=x[qe];qe=Fe+ye*N[2]+ae*N[1]+K*N[0];const It=x[qe];qe=Fe+ke*N[2]+ae*N[1]+K*N[0];const kt=x[qe],Qt=ot+(et-ot)*xe;qe=Fe+me*I[2]+se*I[1]+k*I[0],y.values[qe]=Qt+(It+(kt-It)*xe-Qt)*pe}}}else for(let te=0;te<m;++te){const ae=m>1?F*(h-1)+te*Q:.5*(F+q)*(h-1);if(ae<0||ae>h-1){for(let we=0;we<f;we++)y.values[we+te*I[2]+se*I[1]+k*I[0]]=u;continue}const pe=Math.round(ae),me=Math.round(ie);for(let we=0;we<f;we++)y.values[we+te*I[2]+se*I[1]+k*I[0]]=x[we+pe*N[2]+me*N[1]+K*N[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},yce={kernelName:zC,backendName:"cpu",kernelFunc:function gce(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;Ve(s,"cumprod");const l=Pn([o],s.shape.length);let u=s;null!=l&&(u=ks({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=Zn(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=zs(u.dtype,"int32"),h=EC(Z(u.shape),d),f=e.data.get(u.dataId).values,p=u.shape[u.shape.length-1],g=a?(y,v)=>y+p-v-1:(y,v)=>y+v;for(let y=0;y<f.length;y+=p)for(let v=0;v<p;v++){const w=g(y,v);if(0===v)h[w]=i?1:f[w];else{const x=g(y,v-1);h[w]=i?f[x]*h[x]:f[w]*h[x]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const v=ks({inputs:{x:m},backend:e,attrs:{perm:pl(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),v}return m}},vce={kernelName:Py,backendName:"cpu",kernelFunc:function bce(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;Ve(s,"cumsum");const l=Pn([o],s.shape.length);let u=s;null!=l&&(u=ks({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=Zn(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=zs(u.dtype,"int32"),h=Kr(Z(u.shape),d),f=e.data.get(u.dataId).values,p=u.shape[u.shape.length-1],g=a?(y,v)=>y+p-v-1:(y,v)=>y+v;for(let y=0;y<f.length;y+=p)for(let v=0;v<p;v++){const w=g(y,v);if(0===v)h[w]=i?0:f[w];else{const x=g(y,v-1);h[w]=i?f[x]+h[x]:f[w]+h[x]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const v=ks({inputs:{x:m},backend:e,attrs:{perm:pl(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),v}return m}},xce={kernelName:WC,backendName:"cpu",kernelFunc:function wce(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const c=rI(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const c=p$(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Sce={kernelName:HC,backendName:"cpu",kernelFunc:function Cce(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:i}=r;_("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*o,h=u*o,f=c/(o*o),p=e.data.get(s.dataId).values,g=new Float32Array(a*d*h*f);let m=0;for(let y=0;y<a;++y)for(let v=0;v<d;++v){const w=Math.floor(v/o),x=v%o;for(let N=0;N<h;++N){const I=Math.floor(N/o),A=(x*o+N%o)*f;for(let R=0;R<f;++R)g[m++]=p[R+A+c*(I+u*(w+l*y))]}}return e.makeTensorInfo([a,d,h,f],s.dtype,g)}};function v$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Ve([s,o],"depthwiseConv2DNative");const c=Ge(s.shape),d=Ge(o.shape);let h=l;null==h&&(h=[1,1]),_(Vr(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const f=Ar(s.shape,o.shape,i,h,a,u,!0),{filterHeight:p,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:v}=f,w=v.left,x=v.top,N=f.outChannels/f.inChannels,I=new hr(f.outShape,s.dtype),k=e.data.get(s.dataId).values,A=e.data.get(o.dataId).values,R=I.values;for(let F=0;F<f.batchSize;++F){const U=F*c[0],q=F*I.strides[0];for(let K=0;K<f.outHeight;++K){const Y=q+K*I.strides[1],Q=K*f.strideHeight-x;for(let se=0;se<p;++se){const ie=Q+se*m;if(ie<0||ie>=f.inHeight)continue;const te=se*d[0],ae=U+ie*c[1];for(let pe=0;pe<f.outWidth;++pe){const me=Y+pe*I.strides[2],we=pe*f.strideWidth-w;for(let ye=0;ye<g;++ye){const ke=we+ye*y;if(ke<0||ke>=f.inWidth)continue;const Fe=ae+ke*f.inChannels;let qe=me,ot=te+ye*d[1];for(let et=0;et<f.inChannels;++et){const It=k[Fe+et];for(let kt=0;kt<N;++kt)R[qe+kt]+=It*A[ot+kt];qe+=N,ot+=N}}}}}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}const Nce={kernelName:Ly,backendName:"cpu",kernelFunc:v$},Ice={kernelName:jC,backendName:"cpu",kernelFunc:function Tce(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Ve([s,o],"depthwiseConv2dNativeBackpropFilter");const d=Ar(s.shape,c,i,a,l,u,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:g}=d,m=new hr(d.filterShape,"float32"),y=d.padInfo.left,v=d.padInfo.top,w=d.outChannels/d.inChannels,x=e.data.get(s.dataId).values,N=new hr(s.shape,s.dtype,x),I=e.data.get(o.dataId).values,k=new hr(o.shape,o.dtype,I);for(let A=0;A<p;++A){const R=Math.max(0,Math.ceil((v-A)/h)),F=Math.min(d.outHeight,(d.inHeight+v-A)/h);for(let U=0;U<g;++U){const q=Math.max(0,Math.ceil((y-U)/f)),K=Math.min(d.outWidth,(d.inWidth+y-U)/f);for(let Y=0;Y<d.outChannels;++Y){const Q=Math.trunc(Y/w),se=Y%w;let ie=0;for(let te=0;te<d.batchSize;++te)for(let ae=R;ae<F;++ae){const pe=A+ae*h-v;for(let me=q;me<K;++me)ie+=N.get(te,pe,U+me*f-y,Q)*k.get(te,ae,me,Y)}m.set(ie,A,U,Q,se)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},Ece={kernelName:GC,backendName:"cpu",kernelFunc:function _ce(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Ve([s,o],"depthwiseConv2DNativeBackpropInput");const d=Ge(s.shape),h=Ge(o.shape),f=Ar(c,o.shape,i,a,l,u,!0),p=new hr(f.inShape,"float32"),g=p.values,[m,y,v]=p.strides,w=e.data.get(s.dataId).values,[x,N,I]=d,k=e.data.get(o.dataId).values,[A,R,F]=h,{batchSize:U,filterHeight:q,filterWidth:K,inChannels:Y,inHeight:Q,inWidth:se,outChannels:ie,outHeight:te,outWidth:ae,strideHeight:pe,strideWidth:me}=f,we=q-1-f.padInfo.top,ye=K-1-f.padInfo.left,ke=ie/Y;for(let xe=0;xe<U;++xe)for(let Fe=0;Fe<Y;++Fe)for(let qe=0;qe<Q;++qe){const ot=qe-we,et=Math.max(0,Math.ceil(ot/pe)),It=Math.min(te,(q+ot)/pe);for(let kt=0;kt<se;++kt){const Qt=kt-ye,yn=Math.max(0,Math.ceil(Qt/me)),jn=Math.min(ae,(K+Qt)/me);let bn=0;for(let ln=et;ln<It;++ln){const $n=ln*pe-ot;for(let kn=yn;kn<jn;++kn){const jr=x*xe+N*ln+I*kn,Pl=A*(q-1-$n)+R*(K-1-(kn*me-Qt))+F*Fe;for(let go=0;go<ke;++go)bn+=w[jr+(Fe*ke+go)]*k[Pl+go]}}g[m*xe+y*qe+v*kt+Fe]=bn}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},kce={kernelName:qC,backendName:"cpu",kernelFunc:function Dce(n){const{inputs:t,backend:e}=n,{x:r}=t,s=Z(r.shape),o=e.data.get(r.dataId).values,i=Tt([s,s],r.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*s+u]=o[u];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}},Ace={kernelName:$y,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:o,pad:i,dilations:a}=e,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:g,inChannels:m,outHeight:y,outWidth:v,padInfo:w,strideHeight:x,strideWidth:N,filterHeight:I,filterWidth:k,dilationHeight:A,dilationWidth:R,outShape:F}=dp(r.shape,s.shape,o,i,"NHWC",a),U=Z(F),q=F.length,K=Xn(r.dtype,U);for(let Q=0;Q<f;++Q)for(let se=0;se<y;++se){const ie=se*x-w.top;for(let te=0;te<v;++te){const ae=te*N-w.left;for(let pe=0;pe<m;++pe){let me=Number.MIN_SAFE_INTEGER;for(let ye=0;ye<I;++ye){const ke=ie+ye*A;if(ke>=0&&ke<p)for(let xe=0;xe<k;++xe){const Fe=ae+xe*R;if(Fe>=0&&Fe<g){const qe=Ri([Q,ke,Fe,pe],c,Ge(r.shape)),ot=Ri([ye,xe,pe],h,Ge(s.shape)),et=u[qe]+d[ot];et>me&&(me=et)}}}K[Ri([Q,se,te,pe],q,Ge(F))]=me}}}return{dataId:l.write(pu(K,r.dtype),F,r.dtype),shape:F,dtype:r.dtype}}},Rce={kernelName:XC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:i,pad:a,dilations:l}=e,u=t,c=Eo(r.shape,u.data.get(r.dataId).values),d=Eo(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:g,outHeight:m,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:N,filterWidth:I,dilationHeight:k,dilationWidth:A,outShape:R}=dp(r.shape,s.shape,i,a,"NHWC",l);_(o.rank===R.length,()=>`Error in ${XC}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const F=Eo(R,u.data.get(o.dataId).values),U=cO(s.shape,s.dtype);for(let K=0;K<h;++K)for(let Y=0;Y<m;++Y){const Q=Y*w-v.top;for(let se=0;se<y;++se){const ie=se*x-v.left;for(let te=0;te<g;++te){let ae=Number.MIN_SAFE_INTEGER,pe=0,me=0;for(let we=0;we<N;++we){const ye=Q+we*k;if(ye>=0&&ye<f)for(let ke=0;ke<I;++ke){const xe=ie+ke*A;if(xe>=0&&xe<p){const Fe=c[K][ye][xe][te]+d[we][ke][te];Fe>ae&&(ae=Fe,pe=we,me=ke)}}}U[pe][me][te]+=F[K][Y][se][te]}}}return{dataId:u.write(pu(U,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Oce={kernelName:KC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:i,pad:a,dilations:l}=e,u=t,c=Eo(r.shape,u.data.get(r.dataId).values),d=Eo(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:g,outHeight:m,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:N,filterWidth:I,dilationHeight:k,dilationWidth:A,outShape:R}=dp(r.shape,s.shape,i,a,"NHWC",l);_(o.rank===R.length,()=>`Error in ${KC}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const F=Eo(R,u.data.get(o.dataId).values),U=cO(r.shape,r.dtype);for(let K=0;K<h;++K)for(let Y=0;Y<m;++Y){const Q=Y*w-v.top;for(let se=0;se<y;++se){const ie=se*x-v.left;for(let te=0;te<g;++te){let ae=Number.MIN_SAFE_INTEGER,pe=Q<0?0:Q,me=ie<0?0:ie;for(let we=0;we<N;++we){const ye=Q+we*k;if(ye>=0&&ye<f)for(let ke=0;ke<I;++ke){const xe=ie+ke*A;if(xe>=0&&xe<p){const Fe=c[K][ye][xe][te]+d[we][ke][te];Fe>ae&&(ae=Fe,pe=ye,me=xe)}}}U[K][pe][me][te]+=F[K][Y][se][te]}}}return{dataId:u.write(pu(U,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Mce={kernelName:JC,backendName:"cpu",kernelFunc:function Fce(n){const{inputs:t,backend:e,attrs:r}=n,{image:s}=t,{canvas:o,options:i}=r,{contextOptions:a,imageOptions:l}=i||{},u=l?.alpha||1,c=a?.contextType||"2d";if("2d"!==c)throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const d=o.getContext(c,a?.contextAttributes||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,f]=s.shape.slice(0,2),p=2===s.shape.length?1:s.shape[2],g=e.data.get(s.dataId).values,m="float32"===s.dtype?255:1,y=new Uint8ClampedArray(f*h*4);for(let w=0;w<h*f;++w){const x=[0,0,0,255*u];for(let I=0;I<p;I++){const k=g[w*p+I];if("float32"===s.dtype){if(k<0||k>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)}else if("int32"===s.dtype&&(k<0||k>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);1===p?(x[0]=k*m,x[1]=k*m,x[2]=k*m):x[I]=k*m}const N=4*w;y[N+0]=Math.round(x[0]),y[N+1]=Math.round(x[1]),y[N+2]=Math.round(x[2]),y[N+3]=Math.round(x[3])}o.width=f,o.height=h;const v=new ImageData(y,f,h);return d.putImageData(v,0,0),s}},sI=tr((n,t)=>n*t),Pce=eI((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),sb=vr(Bf,sI,Pce),Lce={kernelName:Bf,backendName:"cpu",kernelFunc:sb};function Hp(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;let a;Ve(s,"sum"),a="bool"===s.dtype?Il({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):ji({inputs:{x:s},backend:e});const l=a.shape.length,u=Rt(o,a.shape),c=Pn(u,l);let d=u,h=a;null!=c&&(h=ks({inputs:{x:a},backend:e,attrs:{perm:c}}),d=Zn(d.length,l)),Br("sum",d,h.shape.length);const[f,p]=Rr(h.shape,d);let m=rb(e,f,zs(h.dtype,"int32"));const y=Z(p),v=e.data.get(m.dataId).values,w=e.data.get(h.dataId).values;for(let x=0;x<v.length;++x){const N=x*y;let I=0;for(let k=0;k<y;++k)I+=w[N+k];v[x]=I}if(i){const N=m;m=gn({inputs:{x:m},backend:e,attrs:{shape:Jn(m.shape,u)}}),e.disposeIntermediateTensorInfo(N)}return e.disposeIntermediateTensorInfo(a),null!=c&&e.disposeIntermediateTensorInfo(h),m}const $ce={kernelName:b0,backendName:"cpu",kernelFunc:Hp},Bce={kernelName:ZC,backendName:"cpu",kernelFunc:function Vce(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:l}=MN(s,o.length);LN(i.length,l,o);const{path:u,steps:c}=$N(a,l),d=c.length;let h=null,f=i.length;const p=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:v}=PN(f,l[m]);let w;VN(y)?w=o[m]:(w=ks({inputs:{x:o[m]},backend:e,attrs:{perm:y}}),p.push(w));const x=w.shape.slice();for(let N=0;N<v.length;++N)x.splice(v[N],0,1);Pt(w.shape,x)||(w=gn({inputs:{x:w},backend:e,attrs:{shape:x}}),p.push(w)),null===h?h=w:(h=sb({inputs:{a:w,b:h},backend:e}),p.push(h))}g<d-1&&(u[g]>=0&&(h=Hp({inputs:{x:h},backend:e,attrs:{axis:u[g]-(i.length-f),keepDims:!1}}),p.push(h)),f--)}for(const g of p)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},Uce={kernelName:YC,backendName:"cpu",kernelFunc:function zce(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;Ve([r,s],"eluGrad");const o=new Float32Array(Z(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];o[l]=u>=0?a[l]:a[l]*(u+1)}return e.makeTensorInfo(s.shape,"float32",o)}},w$=tr((n,t)=>n===t?1:0),x$=vr(Vy,w$,null,"bool"),Wce={kernelName:Vy,backendName:"cpu",kernelFunc:x$},Hce=_N,jce=EN,Gce=DN,qce=kN,Kce=AN,Xce=RN,Jce=Yt(Tf,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+Hce*e);return t*(1-((((Xce*r+Kce)*r+qce)*r+Gce)*r+jce)*r*Math.exp(-e*e))}),Zce={kernelName:Tf,backendName:"cpu",kernelFunc:Jce},C$=Hi(n=>Math.exp(n)),S$=Tl(If,C$,"float32"),Yce={kernelName:If,backendName:"cpu",kernelFunc:S$};function ob(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(_(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),gn({inputs:{x:s},backend:e,attrs:{shape:a}})}const Qce={kernelName:By,backendName:"cpu",kernelFunc:ob},N$=Hi(n=>Math.expm1(n)),ede=Tl(_f,N$),tde={kernelName:_f,backendName:"cpu",kernelFunc:ede},nde=tr((n,t)=>n/t),oI=vr(Sf,nde),iI={kernelName:Sf,backendName:"cpu",kernelFunc:oI},T$=tr((n,t)=>n-t),rde=eI((n,t,e,r)=>({real:n-e,imag:t-r})),aI=vr(tp,T$,rde),sde={kernelName:tp,backendName:"cpu",kernelFunc:aI};function I$(n,t,e){const r=n.shape,s=r[0],o=r[1],i=e.data.get(n.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,o],c=Z(u),d=Lr("float32",c),h=Lr("float32",c);for(let m=0;m<s;m++){const y=Mu({inputs:{x:a},backend:e,attrs:{begin:[m,0],size:[1,o]}}),v=Mu({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,o]}}),w=Gs({inputs:{real:y,imag:v},backend:e}),{real:x,imag:N}=ode(w,t,e),I=xa(x,N);for(let k=0;k<o;k++){const A=ON(I,k);d[m*o+k]=A.real,h[m*o+k]=A.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w)}const f=e.makeTensorInfo(u,"float32",d),p=e.makeTensorInfo(u,"float32",h),g=Gs({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),g}function ode(n,t,e){const r=Z(n.shape),s=e.data.get(n.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function ide(n){return 0==(n&n-1)}(r)){const a=lI(o,i,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",nl(r,"float32")),h=ji({inputs:{x:d},backend:e}),f=iI.kernelFunc({inputs:{a:u,b:d},backend:e}),p=iI.kernelFunc({inputs:{a:c,b:h},backend:e}),g=e.data.get(f.dataId).values,m=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:g,imag:m}}return a}{const l=function ade(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let o=0,i=0;for(let a=0;a<t;a++){const l=HM(s*a,t,e),u=ON(n,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(o/=t,i/=t),UM(r,o,i,s)}return r}(xa(o,i),r,t);return VM(l)}}function lI(n,t,e,r,s){if(1===e)return{real:n,imag:t};const o=xa(n,t),i=e/2,a=BM(o),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),f=Gs({inputs:{real:d,imag:h},backend:s}),p=zM(o),g=p.real,m=p.imag,y=[g.length],v=s.makeTensorInfo(y,"float32",g),w=s.makeTensorInfo(y,"float32",m),x=Gs({inputs:{real:v,imag:w},backend:s}),N=lI(l,u,i,r,s),I=N.real,k=N.imag,A=[I.length],R=s.makeTensorInfo(A,"float32",I),F=s.makeTensorInfo(A,"float32",k),U=Gs({inputs:{real:R,imag:F},backend:s}),q=lI(g,m,i,r,s),K=q.real,Y=q.imag,Q=[K.length],se=s.makeTensorInfo(Q,"float32",K),ie=s.makeTensorInfo(Q,"float32",Y),te=Gs({inputs:{real:se,imag:ie},backend:s}),ae=WM(e,r),pe=[ae.real.length],me=s.makeTensorInfo(pe,"float32",ae.real),we=s.makeTensorInfo(pe,"float32",ae.imag),ye=Gs({inputs:{real:me,imag:we},backend:s}),ke=sb({inputs:{a:ye,b:te},backend:s}),xe=Td({inputs:{a:U,b:ke},backend:s}),Fe=aI({inputs:{a:U,b:ke},backend:s}),qe=Fu({inputs:{input:xe},backend:s}),ot=Fu({inputs:{input:Fe},backend:s}),et=Id({inputs:{input:xe},backend:s}),It=Id({inputs:{input:Fe},backend:s}),kt=_d({inputs:[qe,ot],backend:s,attrs:{axis:0}}),Qt=_d({inputs:[et,It],backend:s,attrs:{axis:0}}),yn=s.data.get(kt.dataId).values,jn=s.data.get(Qt.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(se),s.disposeIntermediateTensorInfo(ie),s.disposeIntermediateTensorInfo(te),s.disposeIntermediateTensorInfo(me),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(xe),s.disposeIntermediateTensorInfo(Fe),s.disposeIntermediateTensorInfo(qe),s.disposeIntermediateTensorInfo(et),s.disposeIntermediateTensorInfo(ot),s.disposeIntermediateTensorInfo(It),s.disposeIntermediateTensorInfo(kt),s.disposeIntermediateTensorInfo(Qt),{real:yn,imag:jn}}const ude={kernelName:"FFT",backendName:"cpu",kernelFunc:function lde(n){const{inputs:t,backend:e}=n,{input:r}=t,s=Z(r.shape),o=r.shape[r.shape.length-1],a=gn({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=I$(a,!1,e),u=gn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}};function uI(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:o}=e,i=o||Xc(s),a=Xn(i,Z(r));return function dde(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,i,a)}const cde={kernelName:e2,backendName:"cpu",kernelFunc:uI},hde={kernelName:t2,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,o=Lr(r.dtype,Z(r.shape)),[i,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const f=h*l*a*u;for(let p=0;p<a;p++){const g=p*(l*u);for(let m=0;m<l;m++){const y=m*u;for(let v=0;v<u;v++){const w=Math.round(l-m-1),x=f+g+y+v;let N=c[x];w>=0&&w<l&&(N=c[f+g+w*u+v]),o[x]=N}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},_$=Hi(n=>Math.floor(n)),fde=Tl(Ef,_$),pde={kernelName:Ef,backendName:"cpu",kernelFunc:fde},E$=tr((n,t)=>Math.floor(n/t)),mde=vr(Df,E$,null,"int32"),gde={kernelName:Df,backendName:"cpu",kernelFunc:mde},bde={kernelName:_0,backendName:"cpu",kernelFunc:function yde(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let g=b$({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const m=g;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const y=gn({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});g=Td({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=Td({inputs:{a:g,b:i},backend:e});e.disposeIntermediateTensorInfo(m)}if(f){const m=g;if("NCHW"===c&&"prelu"===f&&1===a.shape.length&&1!==a.shape[0]){const y=gn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=nb(e,g,f,y,p),e.disposeIntermediateTensorInfo(y)}else g=nb(e,g,f,a,p);e.disposeIntermediateTensorInfo(m)}return g}},wde={kernelName:E0,backendName:"cpu",kernelFunc:function vde(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let g=v$({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const m=g;g=Td({inputs:{a:g,b:i},backend:e}),e.disposeIntermediateTensorInfo(m)}if(f){const m=g;g=nb(e,g,f,a,p),e.disposeIntermediateTensorInfo(m)}return g}};function D$(n,t,e,r,s,o,i,a,l){const u=Tt([r,o],e);for(let c=0;c<r;c++){const d=[];let h=0;for(let f=0;f<s;f++){const p=n[c*s+f];h+=p*i[f],d.push(p)}if(h<0||h>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let f=0;f<o;f++)u.values[c*o+f]=t.get(...t.indexToLoc(h*o+f))}return u}const Cde={kernelName:n2,backendName:"cpu",kernelFunc:function xde(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=Z(r.shape),i=s.shape,a=i[i.length-1],[l,u,c,d]=IN(r,s);if(0===u)return e.makeTensorInfo(l,r.dtype,[]);const p=D$(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,u,a,c,d,r.shape,o);return e.makeTensorInfo(l,r.dtype,p.values)}};function k$(n,t,e){const r=Tt(e,n.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),u=t.locToIndex([i[0],i[2]]);i[2]=t.values[u];const c=n.locToIndex(i);0<=c&&c<n.values.length&&(r.values[s]=n.values[c])}return r}const Nde={kernelName:Uy,backendName:"cpu",kernelFunc:function Sde(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:i,batchDims:a}=r;Ve([s,o],"gatherV2");const l=Rt(i,s.shape)[0],u=e.data.get(o.dataId).values,c=s.shape[l];for(let x=0;x<u.length;++x){const N=u[x];_(N<=c-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${c-1}]`)}let d=a;null==a&&(d=0);const h=Z(o.shape),f=UN(s,o,l,d),p=gn({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=gn({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,h/f.batchSize]}}),m=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],y=e.bufferSync(g),w=k$(e.bufferSync(p),y,m);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(f.outputShape,w.dtype,w.values)}},A$=tr((n,t)=>n>t?1:0),Tde=vr(Wy,A$,null,"bool"),Ide={kernelName:Wy,backendName:"cpu",kernelFunc:Tde},R$=tr((n,t)=>n>=t?1:0),_de=vr(kf,R$,null,"bool"),Ede={kernelName:kf,backendName:"cpu",kernelFunc:_de},kde={kernelName:r2,backendName:"cpu",kernelFunc:function Dde(n){const{inputs:t,backend:e}=n,{input:r}=t,s=Z(r.shape),o=r.shape[r.shape.length-1],a=gn({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=I$(a,!0,e),u=gn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}},Ade=Yt(Rf,n=>Number.isFinite(n)?1:0,"bool"),Rde={kernelName:Rf,backendName:"cpu",kernelFunc:Ade},Ode=Yt(Of,n=>Math.abs(n)===1/0?1:0,"bool"),Fde={kernelName:Of,backendName:"cpu",kernelFunc:Ode},Mde=Yt(Ff,n=>Number.isNaN(n)?1:0,"bool"),Pde={kernelName:Ff,backendName:"cpu",kernelFunc:Mde},O$=tr((n,t)=>n<t?1:0),Lde=vr(jy,O$,null,"bool"),$de={kernelName:jy,backendName:"cpu",kernelFunc:Lde},F$=tr((n,t)=>n<=t?1:0),Vde=vr(Gy,F$,null,"bool"),Bde={kernelName:Gy,backendName:"cpu",kernelFunc:Vde};function M$(n,t,e){const r=(t-n)/(e-1),s=Kr(e,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const Ude={kernelName:o2,backendName:"cpu",kernelFunc:function zde(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,i=M$(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},P$=Hi(n=>Math.log(n)),Wde=Tl(Mf,P$),Hde={kernelName:Mf,backendName:"cpu",kernelFunc:Wde},jde=Yt(Pf,n=>Math.log1p(n)),Gde={kernelName:Pf,backendName:"cpu",kernelFunc:jde},qde=tr((n,t)=>n&&t),Kde=vr(qy,qde,null,"bool"),Xde={kernelName:qy,backendName:"cpu",kernelFunc:Kde},Jde=Yt(Ky,n=>n?0:1,"bool"),Zde={kernelName:Ky,backendName:"cpu",kernelFunc:Jde},Yde=tr((n,t)=>n||t),Qde=vr(Xy,Yde,null,"bool"),ehe={kernelName:Xy,backendName:"cpu",kernelFunc:Qde},nhe={kernelName:Jy,backendName:"cpu",kernelFunc:function the(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:l}=r;Ve(s,"LRN");const u=s.shape[3],c=u-1,d=e.data.get(s.dataId).values,h=Z(s.shape),f=new Float32Array(h);function p(g){const m=g%u;let y=g-m+Math.max(0,m-o);const v=g-m+Math.min(m+o,c);let w=0;for(;y<=v;y++){const x=d[y];w+=x*x}return w}for(let g=0;g<h;g++){const m=p(g),y=d[g]*Math.pow(i+a*m,-l);f[g]=y}return e.makeTensorInfo(s.shape,s.dtype,f)}},she={kernelName:i2,backendName:"cpu",kernelFunc:function rhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Ve(i,"LRNGrad");const d=Z(i.shape),h=i.shape[3],f=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,g=e.data.get(o.dataId).values,m=new Float32Array(d),y=d;for(let v=0;v<y;v++){const w=v%h,x=v-w+Math.max(0,w-a),N=v-w+Math.min(h,w+a+1);let I=0;for(let k=x;k<N;k++)I+=Math.pow(p[k],2);I=u*I+l;for(let k=x;k<N;k++){let A=-2*u*c*p[k]*g[v]/I;v===k&&(A+=Math.pow(I,-c)),A*=f[v],m[k]+=A}}return e.makeTensorInfo(i.shape,s.dtype,m)}};function L$(n,t,e,r){const s=Lr(r,Z(e));for(let o=0;o<s.length;++o){const i=o*t;let a=n[i];for(let l=0;l<t;++l){const u=n[i+l];(Number.isNaN(u)||u>a)&&(a=u)}s[o]=a}return s}function $$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=e;let l=s.shape;const u=l.length,c=Rt(o,l);let d=c;const h=Pn(d,u);let f=a.data.get(s.dataId).values;if(null!=h){const x=new Array(u);for(let N=0;N<x.length;N++)x[N]=l[h[N]];f=tI(f,l,s.dtype,h,x),d=Zn(d.length,u),l=x}Ve(s,"max"),Br("max",d,u);const[p,g]=Rr(l,d),y=L$(f,Z(g),p,s.dtype),v=a.write(y,p,s.dtype);let w=p;return i&&(w=Jn(p,c)),{dataId:v,shape:w,dtype:s.dtype}}const ohe={kernelName:Zy,backendName:"cpu",kernelFunc:$$},V$=tr((n,t)=>Math.max(n,t)),ihe=vr(Lf,V$),ahe={kernelName:Lf,backendName:"cpu",kernelFunc:ihe},uhe={kernelName:Yy,backendName:"cpu",kernelFunc:function lhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Ve(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(Vr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Pt(c.inShape,c.outShape))d=ji({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Ge(s.shape),p=nI(h,0,s.dtype,f,c,"max");d=e.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},dhe={kernelName:Qy,backendName:"cpu",kernelFunc:function che(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ve(s,"maxPool3d");const c=ba(s.shape,o,i,1,a,l,u),h=h$(e.data.get(s.dataId).values,0,s.dtype,Ge(s.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},fhe={kernelName:l2,backendName:"cpu",kernelFunc:function hhe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ve([s,o],"maxPool3DGrad");const c=ba(o.shape,i,a,1,l,u),h=function Iue(n,t){const e=Tt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let y=0;y<t.outDepth;++y){const v=y*r-h;let w=v;for(;w<0;)w+=i;const x=Math.min(t.inDepth,u+v);for(let N=0;N<t.outHeight;++N){const I=N*s-f;let k=I;for(;k<0;)k+=a;const A=Math.min(t.inHeight,c+I);for(let R=0;R<t.outWidth;++R){const F=R*o-p;let U=F;for(;U<0;)U+=l;const q=Math.min(t.inWidth,d+F);let K=Number.NEGATIVE_INFINITY,Y=-1;for(let Q=w;Q<x;Q+=i){const se=Q-v;for(let ie=k;ie<A;ie+=a){const te=ie-I;for(let ae=U;ae<q;ae+=l){const pe=ae-F,me=n.get(g,Q,ie,ae,m);me>=K&&(K=me,Y=se*c*d+te*c+pe)}}}e.set(Y,g,y,N,R,m)}}}return e}(e.bufferSync(o),c),f=c.strideDepth,p=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,N=c.effectiveFilterWidth,I=w-1-c.padInfo.front,k=N-1-c.padInfo.left,A=x-1-c.padInfo.top,R=Tt(o.shape,"float32"),F=e.bufferSync(s);for(let U=0;U<c.batchSize;++U)for(let q=0;q<c.inChannels;++q)for(let K=0;K<c.inDepth;++K)for(let Y=0;Y<c.inHeight;++Y)for(let Q=0;Q<c.inWidth;++Q){const se=K-I,ie=Y-A,te=Q-k;let ae=0;for(let pe=0;pe<w;pe+=m){const me=(se+pe)/f;if(!(me<0||me>=c.outDepth||Math.floor(me)!==me))for(let we=0;we<x;we+=y){const ye=(ie+we)/p;if(!(ye<0||ye>=c.outHeight||Math.floor(ye)!==ye))for(let ke=0;ke<N;ke+=v){const xe=(te+ke)/g;if(xe<0||xe>=c.outWidth||Math.floor(xe)!==xe)continue;const ot=w*x*N-1-h.get(U,me,ye,xe,q)===pe*x*N+we*N+ke?1:0;0!==ot&&(ae+=F.get(U,me,ye,xe,q)*ot)}}}R.set(ae,U,K,Y,Q,q)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}},mhe={kernelName:a2,backendName:"cpu",kernelFunc:function phe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:i}=t,a=o;Ve([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Ro(a.shape,l,u,1,c,d),f=e.data.get(a.dataId).values,p=Tt(h.outShape,a.dtype,d$(f,a.shape,a.dtype,h).values),g=h.strideHeight,m=h.strideWidth,y=h.dilationHeight,v=h.dilationWidth,w=h.effectiveFilterHeight,x=h.effectiveFilterWidth,N=x-1-h.padInfo.left,I=w-1-h.padInfo.top,k=Tt(a.shape,"float32"),A=e.data.get(s.dataId).values,R=Tt(s.shape,"float32",A);for(let F=0;F<h.batchSize;++F)for(let U=0;U<h.inChannels;++U)for(let q=0;q<h.inHeight;++q)for(let K=0;K<h.inWidth;++K){const Y=q-I,Q=K-N;let se=0;for(let ie=0;ie<w;ie+=y){const te=(Y+ie)/g;if(!(te<0||te>=h.outHeight||Math.floor(te)!==te))for(let ae=0;ae<x;ae+=v){const pe=(Q+ae)/m;if(pe<0||pe>=h.outWidth||Math.floor(pe)!==pe)continue;const ye=w*x-1-p.get(F,te,pe,U)===ie*x+ae?1:0;0!==ye&&(se+=R.get(F,te,pe,U)*ye)}}k.set(se,F,q,K,U)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}},yhe={kernelName:u2,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,l=e;Ve(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=Ro(r.shape,s,o,[1,1],i),[d,h]=function ghe(n,t,e,r,s){const i=nI(n,0,e,Ge(t),s,"max"),a=d$(n,t,e,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,a,c),f=l.write(d,c.outShape,r.dtype),p=l.write(h,c.outShape,r.dtype);return[{dataId:f,shape:c.outShape,dtype:r.dtype},{dataId:p,shape:c.outShape,dtype:"int32"}]}},vhe={kernelName:e0,backendName:"cpu",kernelFunc:function bhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=Rt(o,s.shape),c=Z(Rr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const f=Il({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=oI({inputs:{a:f,b:h},backend:e});d.push(p);const g=Hp({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:i}});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}},xhe={kernelName:t0,backendName:"cpu",kernelFunc:function whe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Ve(s,"min");const a=Rt(o,s.shape);let l=a;const u=Pn(l,s.shape.length);let c=s;null!=u&&(c=ks({inputs:{x:s},backend:e,attrs:{perm:u}}),l=Zn(l.length,s.shape.length)),Br("min",l,c.shape.length);const[d,h]=Rr(c.shape,l),f=Z(h),p=Kr(Z(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const v=y*f;let w=g[v];for(let x=0;x<f;++x){const N=g[v+x];(Number.isNaN(N)||N<w)&&(w=N)}p[y]=w}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,p);if(i){const v=gn({inputs:{x:m},backend:e,attrs:{shape:Jn(d,a)}});return e.disposeIntermediateTensorInfo(m),v}return m}},B$=tr((n,t)=>Math.min(n,t)),Che=vr($f,B$),She={kernelName:$f,backendName:"cpu",kernelFunc:Che},The={kernelName:n0,backendName:"cpu",kernelFunc:function Nhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,mode:i}=r;Ve(s,"mirrorPad");const a=o.map((w,x)=>w[0]+s.shape[x]+w[1]),l=o.map(w=>w[0]),u=o.map((w,x)=>w[0]+s.shape[x]),c="reflect"===i?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,f=Ge(s.shape),p=Z(a),g=a.length,m=Ge(a),y=Lr(s.dtype,p);for(let w=0;w<p;w++){let x=Jc(w,g,m);for(let I=0;I<g;I++)x[I]<l[I]?x[I]=2*l[I]-x[I]-c:x[I]>=u[I]&&(x[I]=2*(u[I]-1)-x[I]+c);x=x.map((I,k)=>I-l[k]);const N=Ri(x,h,f);y[w]=d[N]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},Ihe=tr((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),_he=vr(Vf,Ihe),Ehe={kernelName:Vf,backendName:"cpu",kernelFunc:_he};function z$(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=Rt([a],s.shape),u=$$({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=Jn(u.shape,l),d=gn({inputs:{x:u},backend:e,attrs:{shape:c}}),h=aI({inputs:{a:s,b:d},backend:e}),f=S$({inputs:{x:h},backend:e}),p=Hp({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),g=gn({inputs:{x:p},backend:e,attrs:{shape:c}}),m=oI({inputs:{a:f,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),m}const Dhe={kernelName:x0,backendName:"cpu",kernelFunc:z$},Ahe={kernelName:c2,backendName:"cpu",kernelFunc:function khe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r;Ve(s,"multinomial");const l=a?s:z$({inputs:{logits:s},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,o],f=Kr(Z(h),"int32");for(let p=0;p<u;++p){const g=p*c,m=new Float32Array(c-1);m[0]=d[g];for(let w=1;w<m.length;++w)m[w]=m[w-1]+d[g+w];const y=i1.alea(i.toString()),v=p*o;for(let w=0;w<o;++w){const x=y();f[v+w]=m.length;for(let N=0;N<m.length;N++)if(x<m[N]){f[v+w]=N;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function U$(n,t,e){const r=nl(-1,e);return sI([],t,r,n,e)}const Ohe={kernelName:r0,backendName:"cpu",kernelFunc:function Rhe(n){const{inputs:t,backend:e}=n,{x:r}=t;Ve(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=U$(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},Fhe=pN,Phe={kernelName:d2,backendName:"cpu",kernelFunc:function Mhe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Ve(s,"NonMaxSuppression");const u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:d}=Fhe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Lhe=mN,Vhe={kernelName:h2,backendName:"cpu",kernelFunc:function $he(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Ve(s,"NonMaxSuppressionPadded");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:h,validOutputs:f}=Lhe(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},Bhe=gN,Uhe={kernelName:f2,backendName:"cpu",kernelFunc:function zhe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Ve(s,"NonMaxSuppressionWithScore");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,h=i,f=a,p=l,g=u,{selectedIndices:m,selectedScores:y}=Bhe(c,d,h,f,p,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},W$=tr((n,t)=>n!==t?1:0),Whe=vr(s0,W$,null,"bool"),Hhe={kernelName:s0,backendName:"cpu",kernelFunc:Whe},Ghe={kernelName:a0,backendName:"cpu",kernelFunc:function jhe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:i,onValue:a,offValue:l}=r;Ve(s,"oneHot");const u=Z(s.shape),c=new Float32Array(u*i);c.fill(l);const d=e.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=a);return e.makeTensorInfo([...s.shape,i],o,c)}};function ib(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Fu({inputs:{input:r},backend:e}),o=ib({inputs:{x:s},backend:e}),i=Id({inputs:{input:r},backend:e}),a=ib({inputs:{x:i},backend:e}),l=Gs({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return uI({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const qhe={kernelName:T0,backendName:"cpu",kernelFunc:ib},Khe={kernelName:o0,backendName:"cpu",kernelFunc:function H$(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Fu({inputs:{input:r},backend:e}),o=H$({inputs:{x:s},backend:e}),i=Id({inputs:{input:r},backend:e}),a=ib({inputs:{x:i},backend:e}),l=Gs({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return uI({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function j$(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return ob({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(c=>{Bs(o,c.shape,"All tensors passed to stack must have matching shapes"),_(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=_d({inputs:t.map(c=>{const d=ob({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const Xhe={kernelName:l0,backendName:"cpu",kernelFunc:j$},G$={kernelName:u0,backendName:"cpu",kernelFunc:function Jhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:i}=r;Ve(s,"pad");const a=o.map((v,w)=>v[0]+s.shape[w]+v[1]),l=o.map(v=>v[0]),u=e.data.get(s.dataId).values,c=Z(s.shape),d=s.shape.length,h=Ge(s.shape),f=Z(a),p=a.length,g=Ge(a),m=Lr(s.dtype,f);0!==i&&m.fill(i);for(let v=0;v<c;v++)m[Ri(Jc(v,d,h).map((I,k)=>I+l[k]),p,g)]=u[v];return{dataId:e.write(m,a,s.dtype),shape:a,dtype:s.dtype}}},Zhe=tr((n,t)=>Math.pow(n,t)),Yhe=vr(zf,Zhe),Qhe={kernelName:zf,backendName:"cpu",kernelFunc:Yhe};function q$(n,t,e,r){const[s,o]=Rr(n,r),i=zs(t,"int32"),a=Kr(Z(s),i),l=Z(o);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];a[u]=d}return{outVals:a,outShape:s,outDtype:i}}const tfe={kernelName:d0,backendName:"cpu",kernelFunc:function efe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Ve(s,"prod");const a=s.shape.length,l=Rt(o,s.shape),u=Pn(l,a);let c=l,d=s;const h=[];null!=u&&(d=ks({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),c=Zn(c.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:g,outDtype:m}=q$(d.shape,d.dtype,f,c);let y=g;return i&&(y=Jn(g,l)),h.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.makeTensorInfo(y,m,p)}};function K$(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function X$(n,t,e,r,s,o,i,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function nfe(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const o=Jc(s,t.length,Ge(t)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:h}=function sfe(n,t,e,r){const s=[];let o=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function rfe(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let d=1;d<l+1;++d)a[u].push(d*c)}for(let u=0;u<n.length;++u){let c=n[u],d=n[u]+1;for(let h=0;h<e.length;++h){const f=e[h],p=h+t.length-1;if(p>=0){const g=a[p],m=g[g.length-1]-f[c];for(let y=c;y<d;++y)a[p].push(f[y+1]+m)}c=f[c],d=f[d]}d!==c&&(s.push([c,d]),o+=d-c)}return{outSplits:a,valueSlices:s,numValues:o}}(o,i,n,u),f=function ofe(n){const t=[];for(let e=0;e<n.length;++e){const s=Xn("int32",n[e].length);t.push(s),n[e].forEach((o,i)=>s[i]=o)}return t}(c),p=function afe(n,t,e,r,s){const o=t.slice();o[0]=s;const i=Xn(e,Z(o)),a=n.length;return function ife(n,t,e,r,s,o){const i=K$(t,2)[1],a=K$(o,2)[1];let l=0;for(const u of e)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*a+d]=n[c*i+d];++l}}(n,t,r,0===a?0:a/t[0],i,o),[i,o]}(e,r,s,d,h);return[f,p[0],p[1]]}const ufe={kernelName:p2,backendName:"cpu",kernelFunc:function lfe(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=t,l=s.map(y=>e.data.get(y.dataId).values),u=s.map(y=>y.shape),c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,[h,f,p]=X$(l,u,c,o.shape,o.dtype,d,i.shape),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(p,o.dtype,f);return g.concat([m])}},J$=2147483647;function Z$(n,t,e,r,s,o,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===s.length,u=0===i.length,c=[];a||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=Xn("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const y=a?n[0]:n[m],v=l?r[0]:r[m],w=u?o[0]:o[m];if(0===w)throw new Error("Requires delta != 0");let x;if(w>0&&v<y||w<0&&v>y)x=0;else if(x=Math.ceil(Math.abs((v-y)/w)),x>J$)throw new Error(`Requires ((limit - start) / delta) <= ${J$}`);h[m+1]=h[m]+x}const p=Xn(e,h[d]);let g=0;for(let m=0;m<d;++m){const y=h[m+1]-h[m];let v=a?n[0]:n[m];const w=u?o[0]:o[m];for(let x=0;x<y;++x)p[g++]=v,v+=w}return[h,p]}const dfe={kernelName:m2,backendName:"cpu",kernelFunc:function cfe(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=Z$(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}};var Uo=Lo;class ab{constructor(t,e,r,s,o,i,a,l,u,c){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=PM(c),this.raggedRank=LM(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Uo.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Uo.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Uo.VALUE_ROWIDS:return ab.getMaxWidthValueRowID(e);case Uo.ROW_SPLITS:return ab.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Uo[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const o=t[s+1]-t[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],o=0;for(let i=1;i<e;++i){const a=t[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(e-r,o)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Q$(t,r)}calculateOutputSize(t){const e=this.valuesShape;$M(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=MM(this.raggedRank,s,e);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),o=[];let i=0;for(let a=0;a<s;++a,i+=e)o.push(i);for(let a=s;a<t;++a)o.push(-1);return _(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,e,r,s){const o=t.length,i=[];for(let a=0;a<o-1;++a){const l=t[a+1]-t[a];let u=Math.min(s,l),c=e[a];-1===c&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(o>0&&i.length!==t[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,r,s){const o=t.length,i=[];if(0===o)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];i.push(u);for(let c=1;c<o;++c){const d=t[c];if(d===l)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);u=e[d]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,r,s){const o=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Uo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,s);case Uo.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,s);default:throw new Error(`Unsupported partition type: ${Uo[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Uo.FIRST_DIM_SIZE:return t[0];case Uo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Uo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Uo[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=Q$(r,!1),i=Xn(this.valuesDType,Z(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(t,e,r,s){if(0===r.length)return;const o=this.values,i=r;let a=s.slice();a=a.slice(t+1);const l=Z(a),u=e.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const p=this.defaultValueShape;H(()=>{const g=V(c,p);c=cd(g,a).dataSync()})}let d=0,h=0,f=0;for(let p=0;p<=u;++p){let g=p<u?e[p]:-1;if(g!==f){if(h<f){const m=o.subarray(d*l);Y$(i.subarray(h*l),m,(f-h)*l)}if(p>=u&&(g=Math.floor(r.length/l)),g>f)if(1===this.defaultValue.length)i.subarray(f*l,g*l).fill(this.defaultValue[0]),f=g;else for(;g>f;)Y$(i.slice(f*l),c,l),++f;g<0?(d=p+1,h=f):(d=p,h=f,f=h+1)}else++f}}}function Y$(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function Q$(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function eV(n,t,e,r,s,o,i,a,l,u){return new ab(n,t,e,r,s,o,i,a,l,u).compute()}const ffe={kernelName:g2,backendName:"cpu",kernelFunc:function hfe(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,h=a.map(m=>e.data.get(m.dataId).values),f=a.map(m=>m.shape),[p,g]=eV(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,f,l);return e.makeTensorInfo(p,o.dtype,g)}};function tV(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return Kr(0,r);const l=Kr(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const mfe={kernelName:y2,backendName:"cpu",kernelFunc:function pfe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:o,step:i}=e,a=tV(r,s,i,o);return t.makeTensorInfo([a.length],o,a)}},gfe=Yt(Uf,n=>1/n),yfe={kernelName:Uf,backendName:"cpu",kernelFunc:gfe},vfe={kernelName:p0,backendName:"cpu",kernelFunc:function bfe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ve(s,"resizeBilinear");const l=Ge(s.shape),[u,c]=a,[d,h,f,p]=s.shape,g=e.data.get(s.dataId).values,m=new Float32Array(Z([d,u,c,p])),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],v=[o&&u>1?u-1:u,o&&c>1?c-1:c];let w=0;const x=y[0]/v[0],N=y[1]/v[1];for(let I=0;I<d;I++)for(let k=0;k<u;k++){let A;A=i?x*(k+.5)-.5:x*k;const R=Math.max(0,Math.floor(A)),F=A-R,U=Math.min(h-1,Math.ceil(A)),q=I*l[0]+R*l[1],K=I*l[0]+U*l[1];for(let Y=0;Y<c;Y++){let Q;Q=i?N*(Y+.5)-.5:N*Y;const se=Math.max(0,Math.floor(Q)),ie=Q-se,te=Math.min(f-1,Math.ceil(Q)),ae=q+se*l[2],pe=K+se*l[2],me=q+te*l[2],we=K+te*l[2];for(let ye=0;ye<p;ye++){const ke=g[ae+ye],xe=g[pe+ye],ot=ke+(g[me+ye]-ke)*ie;m[w++]=ot+(xe+(g[we+ye]-xe)*ie-ot)*F}}}return e.makeTensorInfo([d,u,c,p],"float32",m)}},xfe={kernelName:w2,backendName:"cpu",kernelFunc:function wfe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r;Ve([o,s],"resizeBilinearGrad");const a=Ge(s.shape),[l,u,c,d]=s.shape,[,h,f]=o.shape,p=new Float32Array(l*u*c*d),g=[i&&h>1?u-1:u,i&&f>1?c-1:c],m=[i&&h>1?h-1:h,i&&f>1?f-1:f],y=g[0]/m[0],v=g[1]/m[1],w=e.data.get(o.dataId).values;let x=0;for(let N=0;N<l;N++){const I=N*a[0];for(let k=0;k<h;k++){const A=k*y,R=Math.floor(A),F=Math.min(Math.ceil(A),u-1),U=I+R*a[1],q=I+F*a[1],K=A-R,Y=1-K;for(let Q=0;Q<f;Q++){const se=Q*v,ie=Math.floor(se),te=Math.min(Math.ceil(se),c-1),ae=se-ie,pe=1-ae,me=U+ie*a[2],we=U+te*a[2],ye=q+ie*a[2],ke=q+te*a[2],xe=Y*pe,Fe=Y*ae,qe=K*pe,ot=K*ae;for(let et=0;et<d;et++){const It=w[x++];p[me+et]+=It*xe,p[we+et]+=It*Fe,p[ye+et]+=It*qe,p[ke+et]+=It*ot}}}}return e.makeTensorInfo([l,c,u,d],"float32",p)}},Sfe={kernelName:f0,backendName:"cpu",kernelFunc:function Cfe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ve(s,"resizeNearestNeighbor");const l=Ge(s.shape),[u,c]=a,[d,h,f,p]=s.shape,g=e.data.get(s.dataId).values,m=new Float32Array(d*u*c*p),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],v=[o&&u>1?u-1:u,o&&c>1?c-1:c],w=y[0]/v[0],x=y[1]/v[1];let N=0;for(let I=0;I<d;I++){const k=I*l[0];for(let A=0;A<u;A++){const R=i?w*(A+.5):w*A;let F=Math.min(h-1,o?Math.round(R):Math.floor(R));i&&(F=Math.max(0,F));const U=k+F*l[1];for(let q=0;q<c;q++){const K=i?x*(q+.5):x*q;let Y=Math.min(f-1,o?Math.round(K):Math.floor(K));i&&(Y=Math.max(0,Y));const Q=U+Y*l[2];for(let se=0;se<p;se++)m[N++]=g[Q+se]}}}return e.makeTensorInfo([d,u,c,p],s.dtype,m)}},Tfe={kernelName:v2,backendName:"cpu",kernelFunc:function Nfe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r;Ve([o,s],"resizeNearestNeighborGrad");const a=Ge(s.shape),l=Ge(o.shape),[u,c,d,h]=s.shape,[,f,p]=o.shape,g=new Float32Array(u*c*d*h),m=e.data.get(o.dataId).values,y=[i&&f>1?c-1:c,i&&p>1?d-1:d],v=[i&&f>1?f-1:f,i&&p>1?p-1:p],w=y[0]/v[0],x=y[1]/v[1],N=1/w,I=1/x,k=2*Math.ceil(N)+2,A=2*Math.ceil(I)+2;for(let R=0;R<u;R++){const F=R*a[0];for(let U=0;U<c;U++){const q=F+U*a[1],K=Math.floor(U*N),Y=Math.floor(K-k/2);for(let Q=0;Q<d;Q++){const se=q+Q*a[2],ie=Math.floor(Q*I),te=Math.floor(ie-A/2);for(let ae=0;ae<h;ae++){let pe=0;for(let me=0;me<k;me++){const we=me+Y;if(we<0||we>=f)continue;const ye=F+we*l[1],ke=we*w;if(U===Math.min(c-1,i?Math.round(ke):Math.floor(ke)))for(let Fe=0;Fe<A;Fe++){const qe=Fe+te;if(qe<0||qe>=p)continue;const ot=ye+qe*l[2],et=qe*x;Q===Math.min(d-1,i?Math.round(et):Math.floor(et))&&(pe+=m[ot+ae])}}g[se+ae]=pe}}}}return e.makeTensorInfo(s.shape,s.dtype,g)}},_fe={kernelName:m0,backendName:"cpu",kernelFunc:function Ife(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r;Ve(s,"reverse");const i=s.shape.length,a=Rt(o,s.shape);if(0===i)return ji({inputs:{x:s},backend:e});const l=new hr(s.shape,s.dtype),u=e.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},Efe={kernelName:$2,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=t,a=e,l=Lr(r.dtype,Z(r.shape)),[u,c,d,h]=r.shape,[f,p]=SN(i,c,d),m=Math.sin(s),y=Math.cos(s),v=a.data.get(r.dataId).values;for(let x=0;x<u;x++){const N=x*d*c*h;for(let I=0;I<c;I++){const k=I*(d*h);for(let A=0;A<d;A++){const R=A*h;for(let F=0;F<h;F++){const U=[u,I,A,F],q=U[2],K=U[1];let Y=(q-f)*y-(K-p)*m,Q=(q-f)*m+(K-p)*y;Y=Math.round(Y+f),Q=Math.round(Q+p);let se=o;"number"!=typeof o&&(se=3===F?255:o[F]),Y>=0&&Y<d&&Q>=0&&Q<c&&(se=v[N+Q*(d*h)+Y*h+F]),l[N+k+R+F]=se}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Dfe=Yt(jf,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),kfe={kernelName:jf,backendName:"cpu",kernelFunc:Dfe},nV=Hi(n=>1/Math.sqrt(n)),Afe=Tl(Gf,nV),Rfe={kernelName:Gf,backendName:"cpu",kernelFunc:Afe};function Pu(n,t,e,r,s,o,i,a,l,u){const c=[r/s,s],d=n.values,h=t.values;if(0===r)return Tt(e,t.dtype);const f=l instanceof hr?l:Tt(c,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let p=0;p<o;p++){const g=[];let m=0;for(let y=0;y<i;y++){const v=d[p*i+y];g.push(v),m+=v*a[y]}if(m<0||m>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<s;y++)u?f.values[m*s+y]+=h[p*s+y]:f.values[m*s+y]=0===t.rank?h[0]:h[p*s+y]}return f}const Ffe={kernelName:x2,backendName:"cpu",kernelFunc:function Ofe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Tu(0,s,i),g=Pu(e.bufferSync(s),e.bufferSync(o),i,d,u,l,a,c,0,!0);return e.makeTensorInfo(i,g.dtype,g.values)}};function Mfe(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function Pfe(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const Vfe={kernelName:S2,backendName:"cpu",kernelFunc:function $fe(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:i}=r,u=function Lfe(n,t,e,r,s,o){const i=Xn("int32",e*s);for(let a=0;a<e;++a){const l=n.slice(a*r,(a+1)*r),u=a*s;for(let c=0;c<s;++c)i[u+c]="left"===o?Mfe(l,t[c+u]):Pfe(l,t[c+u])}return i}(e.data.get(s.dataId).values,e.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],i);return e.makeTensorInfo(o.shape,"int32",u)}},zfe={kernelName:g0,backendName:"cpu",kernelFunc:function Bfe(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t;Ve([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=zs(s.dtype,o.dtype),d=Kr(Z(s.shape),c);let h=0;const f=0===i||i>1||1===s.shape.length?1:Z(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let g=0;g<f;g++)d[h++]=1===a[p]?l[p]:u[p];return e.makeTensorInfo(s.shape,c,d)}},Ufe=y1,Wfe=b1,Hfe=Yt(qf,n=>n>=0?Wfe*n:Ufe*(Math.exp(n)-1)),jfe={kernelName:qf,backendName:"cpu",kernelFunc:Hfe},Gfe=Yt(Jf,n=>n<0?-1:n>0?1:0),qfe={kernelName:Jf,backendName:"cpu",kernelFunc:Gfe},Kfe=Yt(Kf,n=>Math.sin(n)),Xfe={kernelName:Kf,backendName:"cpu",kernelFunc:Kfe},Jfe=Yt(Xf,n=>Math.sinh(n)),Zfe={kernelName:Xf,backendName:"cpu",kernelFunc:Jfe},rV=Math.log(1.1920928955078125e-7)+2,Yfe=Yt(Yf,n=>{const t=n>-rV,e=n<rV,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),Qfe={kernelName:Yf,backendName:"cpu",kernelFunc:Yfe},tpe={kernelName:v0,backendName:"cpu",kernelFunc:function epe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:i}=r;Ve([s],"spaceToBatchND");const a=Z(o),l=[[0,0]];l.push(...i);for(let I=1+o.length;I<s.shape.length;++I)l.push([0,0]);const u=G$.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),c=Tp(u.shape,o,a,!1),d=Ip(c.length,o.length,!1),h=_p(u.shape,o,a,!1),g=gn({inputs:{x:u},backend:e,attrs:{shape:c}}),v=ks({inputs:{x:g},backend:e,attrs:{perm:d}}),N=gn({inputs:{x:v},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),N}};function sV(n,t,e,r,s,o,i){const a=t[0],l=o[0],u=new Array(l),c=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(qM(a));return[Xn(e,0),[0,d],Xn(s,0),u,c]}let h=!0,f=0;const p=new Array(l).fill(0);for(let m=0;m<a;++m){const y=n[m*d];if(y<0)throw new Error(KM(m,y));if(y>=l)throw new Error(XM(m,y,l));++p[y],h=h&&y>=f,f=y}let g=!0;for(let m=0;m<l;++m){const y=0===p[m];u[m]=y,g=g&&!y,p[m]=Math.max(p[m],1),m>0&&(p[m]+=p[m-1])}if(g&&h){const m=n,y=r;for(let v=0;v<a;++v)c[v]=v;return[m,[a,d],y,u,c]}{const m=p[l-1],y=Xn(e,m*d),v=Xn(s,m),w=new Array(l).fill(0);for(let x=0;x<a;++x){const N=n[x*d],k=(0===N?0:p[N-1])+w[N];w[N]++;for(let A=0;A<d;++A)y[k*d+A]=n[x*d+A];v[k]=r[x],c[x]=k}for(let x=0;x<l;++x)if(0===w[x]){const I=0===x?0:p[x-1];y[I*d+0]=x;for(let k=1;k<d;++k)y[I*d+k]=0;v[I]=i}return[y,[m,d],v,u,c]}}const rpe={kernelName:N2,backendName:"cpu",kernelFunc:function npe(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values[0],[d,h,f,p,g]=sV(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};function oV(n,t,e,r,s){const o=Z(r),i=t[0],a=s.length,l=[];let u=1,c=-1;for(let m=0;m<a;++m){const y=s[m];if(-1===y){if(-1!==c)throw new Error(JM(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(ZM(m,y));u*=y,l.push(y)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const m=Math.trunc(o/u);if(u*m!==o)throw new Error(QM(r,l));l[c]=m}if(Z(l)!==o)throw new Error(eP(r,l));const h=r.length,f=[];if(h>0){f[h-1]=1;for(let m=h-2;m>=0;--m)f[m]=f[m+1]*r[m+1]}const p=[];if(a>0){p[a-1]=1;for(let m=a-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}const g=Xn(e,i*a);for(let m=0;m<i;++m){let y=0;for(let v=0;v<h;++v)y+=n[m*h+v]*f[v];for(let v=0;v<a;++v)g[m*a+v]=Math.trunc(y/p[v]),y%=p[v]}return[g,[i,a],l]}const ope={kernelName:T2,backendName:"cpu",kernelFunc:function spe(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(o.dataId).values),[u,c,d]=oV(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function cI(n,t,e,r,s,o=!1,i=0){const a=r.length,l=[t[0],n.length/t[0]],u=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const p=Xn(e,h.reduce((w,x)=>w*x,1));if(0===a)return d>0&&p.fill(i),[p,h];if(d<=0)throw new Error("segment ids must be >= 0");let g=0,m=1,y=0,v=s[g];for(;;){let w=0;if(m<a){if(w=s[m],v===w){++m;continue}if(v>=w)throw new Error("segment ids are not increasing")}if(v<0||v>=d)throw new Error(nP(v,d));v>y&&p.fill(i,y*u,v*u);for(let x=g;x<m;++x){const N=r[x];if(N<0||N>=l[0])throw new Error(rP(x,r[x],l[0]));for(let I=0;I<u;I++)p[v*u+I]+=n[N*u+I]}if(o)for(let x=0;x<u;x++)p[v*u+x]/=m-g;if(g=m,++m,y=v+1,v=w,m>a)break}return y<d&&p.fill(i,y*u,d*u),[p,h]}const ape={kernelName:I2,backendName:"cpu",kernelFunc:function ipe(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=cI(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},upe={kernelName:_2,backendName:"cpu",kernelFunc:function lpe(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=cI(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},dpe={kernelName:E2,backendName:"cpu",kernelFunc:function cpe(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Tu(0,s,a),f=!1,p=e.bufferSync(s);let g;switch(o.dtype){case"bool":g=Pu(p,e.bufferSync(o),a,h,c,u,l,d,Boolean(e.data.get(i.dataId).values[0]),f);break;case"float32":case"int32":g=Pu(p,e.bufferSync(o),a,h,c,u,l,d,e.data.get(i.dataId).values[0],f);break;case"string":g=Pu(p,e.bufferSync(o),a,h,c,u,l,d,sl(e.data.get(i.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}},fpe={kernelName:w0,backendName:"cpu",kernelFunc:function hpe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=Rt(i,s.shape)[0],l=BN(s,o,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const f=Mu({inputs:{x:s},backend:e,attrs:{begin:u,size:h}});return u[a]+=d,f})}},ppe=Hi(n=>Math.sqrt(n)),mpe=Yt(Qf,n=>Math.sqrt(n)),gpe={kernelName:Qf,backendName:"cpu",kernelFunc:mpe},ype={kernelName:D2,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Ve(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},iV=tr((n,t)=>{const e=n-t;return e*e}),bpe=vr(ep,iV),vpe={kernelName:ep,backendName:"cpu",kernelFunc:bpe},aV=Hi((n,t)=>{const{pattern:e,replaceGlobal:r,rewrite:s}=t;return n.replace(new RegExp(e,r?"g":""),s)}),wpe=Tl(C0,aV),xpe={kernelName:C0,backendName:"cpu",kernelFunc:wpe},Cpe=Yt(op,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Spe={kernelName:op,backendName:"cpu",kernelFunc:Cpe};function lV(n,t,e,r){const s=Tt(n,t.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];s.set(t.get(...a),...i)}return s}const Tpe={kernelName:k2,backendName:"cpu",kernelFunc:function Npe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;Ve(s,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:v,end:w,strides:x}=ES(s.shape,o,i,a,l,u,c,d,h);let N;if(g)N=gn({inputs:{x:s},backend:e,attrs:{shape:p}});else if(m||y){_(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=TS(v,w,x),k=Mu({inputs:{x:s},backend:e,attrs:{begin:v,size:I}});N=gn({inputs:{x:k},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(k)}else{const k=lV(f,e.bufferSync(s),x,v);N=e.makeTensorInfo(p,k.dtype,k.values)}return N}};class Ipe{constructor(t,e,r,s,o,i){this.separator=rl(t),this.nGramWidths=e,this.leftPad=rl(r),this.rightPad=rl(s),this.padWidth=o,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(o-(a+1))),d=i-(u+c),h=e+(u>0?0:a-l);let f=0;f+=u*this.leftPad.length;for(let v=0;v<d;++v)f+=t[h+v].length;f+=c*this.rightPad.length,f+=(u+c+d-1)*this.separator.length,r[s+a]=new Uint8Array(f);const g=r[s+a];let m=0;const y=v=>v.forEach(w=>g[m++]=w);for(let v=0;v<u;++v)y(this.leftPad),y(this.separator);for(let v=0;v<d-1;++v)y(t[h+v]),y(this.separator);if(d>0){y(t[h+d-1]);for(let v=0;v<c;++v)y(this.separator),y(this.rightPad)}else{for(let v=0;v<c-1;++v)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=e[u]>=l;if(c=c&&e[u]<=r,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${r}]`);l=e[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=Xn("int32",s);if(0===r||0===s){const l=new Array(r);for(let u=0;u<=o;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const u=e[l]-e[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&0===c&&(c=1),i[l]=i[l-1]+c}const a=new Array(i[o]);for(let l=0;l<o;++l){const u=e[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const f=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,u,a,c,f,d),c+=f}),this.preserveShort&&c===i[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,u,a,c,1,d+2*this.padWidth)}}return[a,i]}}function uV(n,t,e,r,s,o,i,a){return new Ipe(e,r,s,o,i,a).compute(n,t)}const Epe={kernelName:A2,backendName:"cpu",kernelFunc:function _pe(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=e.data.get(c.dataId).values,f=e.data.get(d.dataId).values,[p,g]=uV(h,f,s,o,i,a,l,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",g)]}};function Dpe(n,t,e,r){if(!n.length)return;if(0===t.length){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(1===t.length){const o=t[0];let i=n.indexOf(o);for(;-1!==i;){const a=n.subarray(0,i);(!e||0!==a.length)&&r.push(a),i=(n=n.subarray(i+1)).indexOf(o)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||-1!==t.indexOf(n[o])){const i=n.subarray(s,o);(!e||0!==i.length)&&r.push(i),s=o+1}}function cV(n,t,e){const r=n.length,s=[];let o=0,i=0;const a=new Array(r);for(let h=0;h<r;++h){const f=s.length;Dpe(n[h],t,e,s);const p=s.length-f;a[h]=p,o+=p,i=Math.max(i,p)}const l=Xn("int32",2*o),u=new Array(o),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let f=0;f<a[h];++f)l[2*d]=h,l[2*d+1]=f,u[d]=s[d],++d;return[l,u,c]}const Ape={kernelName:R2,backendName:"cpu",kernelFunc:function kpe(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.data.get(o.dataId).values,l=e.data.get(i.dataId).values[0],[u,c,d]=cV(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function dV(n,t){const e=Xn("int32",n.length);for(let r=0;r<n.length;++r)e[r]=ZK(n[r]).modulo(t).getLowBitsUnsigned();return e}const Ope={kernelName:O2,backendName:"cpu",kernelFunc:function Rpe(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=dV(e.data.get(o.dataId).values,s);return e.makeTensorInfo(o.shape,"int32",a)}},Fpe=Yt(np,n=>Math.tan(n)),Mpe={kernelName:np,backendName:"cpu",kernelFunc:Fpe},Ppe=Yt(rp,n=>Math.tanh(n));function hV(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=Tt(e,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(n.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%n.shape[l];const a=n.locToIndex(i);r.values[s]=n.values[a]}return r}const jp=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function fV(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=t-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2);fV(n,t,Math.max(e,Math.floor(t-l*c/a+d)),Math.min(r,Math.floor(t+(a-l)*c/a+d)))}const s=n[t];let o=e,i=r;for(Qa(n,e,t),jp(n[r],s)>0&&Qa(n,e,r);o<i;){for(Qa(n,o,i),o++,i--;jp(n[o],s)<0;)o+=1;for(;jp(n[i],s)>0;)i-=1}0===jp(n[e],s)?Qa(n,e,i):(i+=1,Qa(n,i,r)),i<=t&&(e=i+1),t<=i&&(r=i-1)}}function pV(n,t,e,r,s){const o=t[t.length-1],[i,a]=[n.length/o,o],l=Lr(e,i*r),u=Lr("int32",i*r);for(let d=0;d<i;d++){const h=d*a,f=n.subarray(h,h+a);let p=new Array(f.length);f.forEach((v,w)=>p[w]={value:v,index:w}),r<p.length&&(fV(p,r),p=p.slice(0,r)),s&&p.sort(jp);const g=d*r,m=l.subarray(g,g+r),y=u.subarray(g,g+r);for(let v=0;v<r;v++)m[v]=p[v].value,y[v]=p[v].index}const c=t.slice();return c[c.length-1]=r,[Tt(c,e,l),Tt(c,"int32",u)]}function mV(n,t,e){switch(e){case"reflect":return function Gpe(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return cu(0,e,t-1)}(n,t);case"wrap":return function qpe(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),cu(0,e,t-1)}(n,t);case"nearest":return function Xpe(n,t){return cu(0,n,t-1)}(n,t);default:return function Kpe(n,t){return n}(n)}}function Gp(n,t,e,r,s,o,i,a,l,u,c){return 0<=a&&a<t&&0<=l&&l<e?n[i*r+a*s+l*o+u]:c}function Jpe(n,t,e,r,s,o,i,a,l,u,c){return Gp(n,t,e,r,s,o,i,Math.round(a),Math.round(l),u,c)}function Zpe(n,t,e,r,s,o,i,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*Gp(n,t,e,r,s,o,i,d,h,u,c)+(l-h)*Gp(n,t,e,r,s,o,i,d,p,u,c))+(a-d)*((p-l)*Gp(n,t,e,r,s,o,i,f,h,u,c)+(l-h)*Gp(n,t,e,r,s,o,i,f,p,u,c))}function gV(n,t,e,r){const s=Rt(t,e)[0],o=[1,e[0],1];for(let p=0;p<s;p++)o[0]*=e[p];o[1]=e[s];for(let p=s+1;p<e.length;p++)o[2]*=e[p];const i=new Map,a=new Int32Array(e[s]),l=new hr(o,r,n),u=[],c=1===o[0]&&1===o[2];for(let p=0;p<e[s];p++){let g;if(c)g=n[p].toString();else{const y=[];for(let v=0;v<o[0];v++)for(let w=0;w<o[2];w++)y.push(l.get(v,p,w));g=y.join(",")}const m=i.get(g);if(null!=m)a[p]=m;else{const y=i.size;i.set(g,y),a[p]=y,u.push(p)}}const d=o.slice();d[1]=i.size;const h=new hr(d,r);u.forEach((p,g)=>{for(let m=0;m<o[0];m++)for(let y=0;y<o[2];y++)h.set(l.get(m,p,y),m,g,y)});const f=e.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const sme=[Yle,Qle,tue,rue,Kle,oue,lue,cue,hue,pue,gue,bue,wue,Sue,Tue,Eue,kue,Rue,Fue,Jle,Pue,Vue,zue,Wue,jue,Gle,que,Xue,Hle,Jue,Yue,Que,tce,rce,oce,ace,uce,dce,fce,mce,yce,vce,xce,Sce,Nce,Ice,Ece,kce,Ace,Rce,Oce,Mce,Bce,Mle,Uce,Wce,Zce,Yce,Qce,tde,ude,cde,hde,pde,gde,bde,wde,Cde,Nde,Ide,Ede,Ple,kde,Zue,Rde,Fde,Pde,Lle,$de,Bde,Ude,Hde,Gde,Xde,Zde,ehe,nhe,she,ohe,ahe,uhe,dhe,fhe,mhe,yhe,vhe,xhe,She,The,Ehe,Ahe,Lce,Ohe,Phe,Vhe,Uhe,Hhe,Ghe,Khe,Xhe,G$,Qhe,Vle,tfe,ufe,dfe,ffe,mfe,jle,iI,yfe,Ble,zle,Xle,vfe,xfe,Sfe,Tfe,_fe,Efe,kfe,Rfe,Ffe,Vfe,zfe,jfe,Wle,qfe,Xfe,Zfe,Lue,Dhe,Qfe,tpe,rpe,ope,ape,upe,dpe,fpe,gpe,ype,vpe,xpe,Spe,Tpe,Epe,Ape,Ope,sde,$ce,Mpe,{kernelName:rp,backendName:"cpu",kernelFunc:Ppe},{kernelName:C2,backendName:"cpu",kernelFunc:function $pe(n){const{inputs:t,backend:e}=n,{tensor:r,indices:s,updates:o}=t,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=Tu(0,s,r.shape),h=e.bufferSync(s),f=e.bufferSync(o),p=e.bufferSync(r),g=Pu(h,f,r.shape,c,l,a,i,u,p,!1);return e.makeTensorInfo(r.shape,g.dtype,g.values)}},{kernelName:sp,backendName:"cpu",kernelFunc:function Bpe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;Ve(s,"tile");const i=hV(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:F2,backendName:"cpu",kernelFunc:function Upe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:i}=r;Ve(s,"topk");const a=e.data.get(s.dataId).values,[l,u]=pV(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:M2,backendName:"cpu",kernelFunc:function Hpe(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,d,h,f]=s.shape,[p,g]=u??[d,h],m=[c,p,g,f],y=Ge(s.shape),v=y[0],w=y[1],x=y[2],N=Ge(m),I=N[0],k=N[1],A=N[2],R=Lr(s.dtype,Z(m));R.fill(l);const F=r.data.get(s.dataId).values,U=r.data.get(o.dataId).values;for(let K=0;K<c;++K){const Y=1===o.shape[0]?U:U.subarray(8*K,8*K+8);for(let Q=0;Q<p;++Q)for(let se=0;se<g;++se)for(let ie=0;ie<f;++ie){let te;const ae=Y[6]*se+Y[7]*Q+1;if(0===ae)continue;const me=(Y[3]*se+Y[4]*Q+Y[5])/ae,we=mV((Y[0]*se+Y[1]*Q+Y[2])/ae,h,a),ye=mV(me,d,a);switch(i){case"nearest":te=Jpe(F,d,h,v,w,x,K,ye,we,ie,l);break;case"bilinear":te=Zpe(F,d,h,v,w,x,K,ye,we,ie,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}R[K*I+Q*k+se*A+ie]=te}return r.makeTensorInfo(m,s.dtype,R)}return{dataId:r.write(R,m,s.dtype),shape:s.shape,dtype:s.dtype}}},iue,{kernelName:P2,backendName:"cpu",kernelFunc:function Ype(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;Ve(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=gV(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:S0,backendName:"cpu",kernelFunc:function eme(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let u=0;for(let f=0;f<i;f++)f!==o&&(l[u++]=s.shape[f]);const c=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const h=new Array(a);for(let f=0;f<h.length;f++){c[o]=f;const p=Mu({inputs:{x:s},backend:e,attrs:{begin:c,size:d}});h[f]=gn({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:N0,backendName:"cpu",kernelFunc:function nme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:i}=r;Ve(s,"unsortedSegmentSum");const u=[],c=[],d=s.shape.length-o.shape.length;let h=o;for(let p=0;p<d;++p){const g=ob({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=g,c.push(g)}for(let p=0;p<i;++p){const g=nl(p,"int32"),m=e.makeTensorInfo([],"int32",g),y=x$({inputs:{a:m,b:h},backend:e}),v=Il({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),w=sb({inputs:{a:v,b:s},backend:e}),x=Hp({inputs:{x:w},backend:e,attrs:{axis:0,keepDims:!1}});u.push(x),c.push(m),c.push(y),c.push(v),c.push(w),c.push(x)}const f=j$({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},qhe];for(const n of sme)B2(n);const _l={},lb={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function bi(n,t){if(!(n in _l)||null!=t){const r=function ame(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function ime(n){if(!G().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete _l[n]},!1),G().getBool("SOFTWARE_WEBGL_ENABLED")&&(lb.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",lb)||e.getContext("experimental-webgl",lb):e.getContext("webgl2",lb)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;_l[n]=r}const e=_l[n];return null==e||e.isContextLost()?(delete _l[n],bi(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),_l[n])}var Ed=(()=>{return(n=Ed||(Ed={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",Ed;var n})(),qs=(()=>{return(n=qs||(qs={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",qs;var n})(),Fr=(()=>{return(n=Fr||(Fr={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Fr;var n})();function qp(n,t){return[t,n]}function ub(n){const t=Z(n);return NC(Math.ceil(t/4))}function Dd(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function dI(n,t){const e=n;let r,s,o,i,a,l,u,c,d,h;return 2===G().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=n.RGBA,s=n.RGBA,o=n.RGBA,i=e.RGBA,a=n.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function _e(n,t){const e=t();return G().getBool("DEBUG")&&function cme(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function pme(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function fme(n){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function cb(n,t){return _a(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const yme=/ERROR: [0-9]+:([0-9]+):/g;function yV(n,t){const e=yme.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),o=s.length.toString().length+2,i=s.map((d,h)=>Kc((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Kc(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function hI(n,t){if(_e(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function bV(n,t,e,r,s,o,i){const a=n.getAttribLocation(t,e);return-1!==a&&(_e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),_e(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,o,i)),_e(n,()=>n.enableVertexAttribArray(a)),!0)}function Eme(n,t,e,r){_e(n,()=>function Tme(n,t,e){(function wV(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),_e(n,()=>n.activeTexture(n.TEXTURE0+e)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),_e(n,()=>n.uniform1i(e,r))}function fI(n,t,e){_e(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),_e(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function vV(n,t){_e(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),_e(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function db(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function Dme(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function _a(n,t,e){const r=_e(n,()=>t());if(null==r)throw new Error(e);return r}function kd(n,t=2){return Z(n.slice(0,n.length-t))}function Ad(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function hb(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[kd(n),...Ad(n)]),t}function fb(n){return n%2==0}function pb(n,t){if(Pt(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],r=t[t.length-1];if(e===r||fb(e)&&fb(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&fb(n[0])&&fb(t[0])}let mb,gb;function Wo(n,t){return null!=n.getExtension(t)}function xV(n){try{if(null!=bi(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function pI(n){const t=dI(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(o),i}function Kp(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&_("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Ue=G();function cs(){let n,t,e,r,s,o,i,a,l,u;return 2===G().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=G().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function Lu(n,t,e="index"){const r=Ge(t);return r.map((s,o)=>`int ${n[o]} = ${e} / ${s}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`};`).join("")}function yb(n,t,e="index"){const r=Ge(t);return r.map((s,o)=>`int ${n[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`};`).join("")}function mI(n){const t=Ge(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Ue.registerFlag("HAS_WEBGL",()=>Ue.getNumber("WEBGL_VERSION")>0),Ue.registerFlag("WEBGL_VERSION",()=>xV(2)?2:xV(1)?1:0),Ue.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Ue.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Ue.get("WEBGL_VERSION")),Ue.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Ue.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Ue.registerFlag("WEBGL_PACK",()=>Ue.getBool("HAS_WEBGL")),Ue.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_CLIP",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_REDUCE",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_CONV_IM2COL",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ue.getBool("WEBGL_PACK")),Ue.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function Ame(n){if(null==mb){const t=bi(n);mb=t.getParameter(t.MAX_TEXTURE_SIZE)}return mb}(Ue.getNumber("WEBGL_VERSION"))),Ue.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function Rme(n){if(null==gb){const t=bi(n);gb=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,gb)}(Ue.getNumber("WEBGL_VERSION"))),Ue.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Ue.getNumber("WEBGL_VERSION");return 0===n?0:function Ome(n){if(0===n)return 0;let t;const e=bi(n);return t=Wo(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Wo(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Ue.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ue.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!DO()),Ue.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function Fme(n){if(0===n)return!1;const t=bi(n);if(1===n){if(!Wo(t,"OES_texture_float"))return!1}else if(!Wo(t,"EXT_color_buffer_float"))return!1;return pI(t)}(Ue.getNumber("WEBGL_VERSION"))),Ue.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Ue.getBool("WEBGL_FORCE_F16_TEXTURES")&&Ue.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Ue.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Mme(n){if(0===n)return!1;const t=bi(n);if(1!==n){if(Wo(t,"EXT_color_buffer_float"))return pI(t);const r="EXT_color_buffer_half_float";if(Wo(t,r)){const s=t.getExtension(r);return function Pme(n,t){const e=dI(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}(t,s)}return!1}return!(!Wo(t,"OES_texture_float")||!Wo(t,"WEBGL_color_buffer_float"))&&pI(t)}(Ue.getNumber("WEBGL_VERSION"))),Ue.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Lme(n){return 2===n&&null!=bi(n).fenceSync}(Ue.getNumber("WEBGL_VERSION"))),Ue.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ue.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Ue.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if("number"!=typeof n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Ue.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>DO()?1:-1,n=>{if("number"!=typeof n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Ue.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Ue.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Ue.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Ue.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Ue.registerFlag("WEBGL_EXP_CONV",()=>!1),Ue.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ue.getBool("IS_TEST")),Ue.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Ue.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Ue.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Ue.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const CV="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:SV}=Xe;function Bme(n,t,e){const r=[];if(n.forEach(f=>{const p=Z(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){const{uniformShape:g}=yI(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`)}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const s=r.join("\n"),o=n.map(f=>function zme(n,t,e=!1,r){let s="";return s+=e?NV(n,r):Rd(n,r),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function wge(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=SV(n.shapeInfo.logicalShape,t.logicalShape),l=an(i),u=i-o;let c;const d=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(v=>`coords.${d[v+u]} = 0;`).join("\n");let h="";h=i<2&&o>0?"coords":n.shapeInfo.logicalShape.map((v,w)=>`coords.${d[w+u]}`).join(", ");let f="return outputValue;";const g=1===Z(n.shapeInfo.logicalShape),y=1===Z(t.logicalShape);if(1!==o||g||y){if(g&&!y)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const v=o-2,w=o-1;a.indexOf(v)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(v)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(n,t):function xge(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&Pt(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=an(l),c=SV(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(g=>`coords.${f[g+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((g,m)=>`coords.${f[m+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(n,t)),s}(f,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),i=t.texShape,a=cs(),l=function Hme(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let u,c,d=function qme(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Kme}\n    ${Xme}\n    ${Jme}\n  `}(a);return t.isPacked?(u=function Ume(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Yme(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function ige(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Pt(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function ege(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),o=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function nge(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),o=s*Math.ceil(n[n.length-2]/2);let i=o,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)i*=n[n.length-u-1],a=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+a,l=`b${u}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,i,e.enableShapeUniforms),c=function Gme(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(u=function Wme(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Qme(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function age(n,t,e){return Pt(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function tge(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${yb(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Lu(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function rge(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${yb(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Lu(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function sge(n,t){const e=Lu(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function oge(n,t){const e=Lu(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,e.enableShapeUniforms),c=function jme(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=Zme),[d,l,c,s,u,o,e.userCode].join("\n")}function Rd(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function uge(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,o]=n.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=$u(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function dge(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Od(n)}\n      }\n    `;const s=n.shapeInfo.texShape,o=s[0],i=s[1];if(1===i&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=$u(e);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function fge(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(null!=o&&Pt(e,o))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=el(e);if(i.length<e.length){const f=["row","col"];return`\n      ${Rd(Fd(n,i),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Md(f,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Od(n)}\n      }\n    `;const u=o[0],c=o[1],d=$u(r);return 1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function mge(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=el(e);if(a.length<e.length){const m=["row","col","depth"];return`\n        ${Rd(Fd(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Md(m,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1)));\n        ${Od(n)}\n      }\n    `;const c=n.shapeInfo.texShape,d=c[0],h=c[1],f=n.shapeInfo.flatOffset;if(h===o&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const p=$u(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${i} + depth + ${p};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function yge(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:u}=el(e);if(l.length<e.length){const w=["row","col","depth","depth2"];return`\n      ${Rd(Fd(n,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Md(w,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1)));\n        ${Od(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1],p=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=$u(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${g}\n      ${m}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function bge(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],o=t[3]*s,i=t[2]*o,a=t[1]*i,{newShape:l,keptDims:u}=el(t);if(l.length<t.length){const m=["row","col","depth","depth2","depth3"];return`\n      ${Rd(Fd(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Md(m,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${Od(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${$u(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function vge(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=el(t);if(s.length<t.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Rd(Fd(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Md(y,o)});\n      }\n    `}const i=t[5],a=t[4]*i,l=t[3]*a,u=t[2]*l,c=t[1]*u;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Od(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1];if(p===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${$u(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function NV(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function lge(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${cs().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function cge(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,o=cs();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function hge(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],l=cs();if(null!=o&&Pt(e,o))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function pge(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const f=[1,2],g=["b","row","col"];return`\n        ${NV(Fd(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Md(g,f)});\n        }\n      `}const a=cs();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(e[1]/2)}, ${c}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function gge(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=cs();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],d=Math.ceil(o[i-1]/2);let h=d*Math.ceil(o[i-2]/2),f="int b, int row, int col",p=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<i-1;g++)f=`int b${g}, `+f,h*=o[i-g-1],p=`b${g} * ${h} + `+p;return`\n    vec4 ${r}(${f}) {\n      int index = ${p};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const Kme="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Xme="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Jme="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Zme="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function $u(n){return`offset${n}`}function Od(n){const t=n.name,e=Z(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function an(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function yI(n,t,e){const{newShape:r,keptDims:s}=el(t),o=t.length,i=n&&3===o&&1===t[0],a=i?t.slice(1):r,l=!n&&o>1&&!Pt(t,e)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:s}}function Fd(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Md(n,t){return t.map(e=>n[e]).join(", ")}function IV(n,t,e){const r=[],s=[];let o,i,a,l=null,u=null;u=n.getUniformLocation(e,"NAN",!1),1===G().getNumber("WEBGL_VERSION")&&(l=n.getUniformLocation(e,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const h={name:d,uniform:n.getUniformLocation(e,d,c),offset:n.getUniformLocation(e,`offset${d}`,c)};t.enableShapeUniforms&&(h.shape=n.getUniformLocation(e,`${d}Shape`,c),h.texShape=n.getUniformLocation(e,`${d}TexShape`,c)),r.push(h)}if(t.enableShapeUniforms&&(o=n.getUniformLocation(e,"outShape",c),a=n.getUniformLocation(e,"outShapeStrides",c),i=n.getUniformLocation(e,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)s.push(n.getUniformLocation(e,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function _V(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,o=t[r],i=o.shape;if(!Pt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!Pt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Zr(n){return G().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Tge{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ed.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=cs();this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?yb(["r","c","d"],t):Lu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Ige{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ed.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=cs();this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?yb(["r","c","d"],t):Lu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class _ge{constructor(t){this.variableNames=["A"],this.outTexUsage=qs.DOWNLOAD;const e=cs();this.outputShape=t,this.userCode=`\n      ${CV}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Ege{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qs.DOWNLOAD;const e=cs();this.outputShape=t,this.userCode=`\n      ${CV}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const Dge={R:0,G:1,B:2,A:3};class EV{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=cs();this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++)i+=`\n          if(offset == ${a}) {\n            result = values[${Dge[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":mI(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${i}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class kge{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=cs();this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length);let s="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=2*i+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":mI(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function Xp(n,t,e,r,s,o){!function Sme(n,t){const e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const i=function Cme(n){return _a(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return _e(n,()=>n.bindTexture(a,i)),_e(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),_e(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),_e(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),_e(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===G().getNumber("WEBGL_VERSION")?_e(n,()=>n.texImage2D(a,0,r,t,e,0,s,o,null)):_e(n,()=>n.texStorage2D(a,1,r,t,e)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function DV(n){return n.internalFormatFloat}function kV(n){return n.internalFormatHalfFloat}function AV(n){return n.downloadTextureFormat}function RV(n){return n.internalFormatPackedFloat}function OV(n){return n.internalFormatPackedHalfFloat}class bI{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=G().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function ome(n,t){_l[n]=t}(e,t)):this.gl=bi(e),t=this.gl,2===G().getNumber("WEBGL_VERSION")){const o=t;this.createVertexArray=()=>_e(o,()=>o.createVertexArray()),this.bindVertexArray=i=>_e(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>_e(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>_e(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=t){const o=t.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>_e(t,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>_e(t,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>_e(t,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>_e(t,()=>t.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===G().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=cb(this.gl,"OES_texture_float"),Wo(this.gl,i))this.textureHalfFloatExtension=cb(this.gl,i);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Wo(this.gl,s))this.colorBufferHalfFloatExtension=cb(this.gl,s);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Wo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Wo(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function Rge(n){return function wme(n,t){const e=_a(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return _e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),_e(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function Oge(n){return function xme(n,t){const e=_a(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return _e(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),_e(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Nme(n){return _a(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=dI(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;_e(t,()=>t.finish()),_e(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),_e(t,()=>t.deleteFramebuffer(this.framebuffer)),_e(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),_e(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),_e(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function Fge(n,t,e,r){const[s,o]=qp(t,e);return Xp(n,s,o,DV(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function Mge(n,t,e,r){const[s,o]=qp(t,e);return Xp(n,s,o,kV(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function Pge(n,t,e,r){const[s,o]=qp(t,e);return Xp(n,s,o,AV(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function zge(n,t,e){_e(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===G().getNumber("WEBGL_VERSION")?_e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):_e(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===G().getNumber("WEBGL_VERSION")?_e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):_e(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function Bge(n,t,e,r,s,o){let i,a,l;_e(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(e*r*4),a=n.FLOAT,l=o.internalFormatPackedFloat),i.set(s),2===G().getNumber("WEBGL_VERSION")?_e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,i)):_e(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,i)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function $ge(n,t,e,r){const[s,o]=Dd(t,e);return Xp(n,s,o,OV(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function Lge(n,t,e,r){const[s,o]=Dd(t,e);return Xp(n,s,o,RV(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(vV(this.gl,this.framebuffer),this.outputTexture=null),_e(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function Hge(n,t,e,r){const[s,o]=qp(t,e),a=new Uint8Array(function lme(n,t){return n*t}(t*e,4));return _e(n,()=>n.readPixels(0,0,s,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,o,i){return function jge(n,t,e,r,s,o,i,a){const l=n,u=new Float32Array(function ume(n,t){const[e,r]=Dd(n,t);return e*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(t,e){return function Wge(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function Uge(n,t,e,r){const s=n.createBuffer();_e(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return _e(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),_e(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),_e(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(G().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function Gge(n,t,e){const r=new Float32Array(t*e*4);return _e(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function Age(n){const t=cs();return function mme(n,t){const e=_a(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(_e(n,()=>n.shaderSource(e,t)),_e(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function bme(n){return _a(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);_e(e,()=>e.attachShader(r,this.vertexShader)),_e(e,()=>e.attachShader(r,t)),function vme(n,t){if(_e(n,()=>n.linkProgram(t)),!G().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&hI(e,s),s}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;_e(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function Vge(n,t,e){_e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),bV(n,t,"clipSpacePos",e,3,20,0)&&bV(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(_e(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&hI(this.gl,this.program),_e(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function Ime(n,t,e){return _a(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function _me(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),_e(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Eme(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,o]=Dd(e,r);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&hI(this.gl,this.program),db(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}_e(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),_e(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=cb(this.gl,2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return J(function*(){return yield iO(()=>e.disposed||e.isQueryAvailable(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function qge(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in G().platform&&(r=G().platform.setTimeoutCustom.bind(G().platform)),iO(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),fI(this.gl,t,this.framebuffer),this.debug&&db(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(fI(this.gl,this.outputTexture,this.framebuffer),this.debug&&db(this.gl)):vV(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;fI(s,t,this.framebuffer),this.debug&&db(s),this.outputTexture=t,_e(s,()=>s.viewport(0,0,e,r)),_e(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),_e(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Kge,bincountImpl:FV,bincountReduceImpl:Xge,bitwiseAndImpl:Jge,castImpl:Zge,ceilImpl:Yge,concatImpl:Qge,equalImpl:eye,expImpl:tye,expm1Impl:nye,floorImpl:rye,gatherNdImpl:sye,gatherV2Impl:oye,greaterImpl:iye,greaterEqualImpl:aye,lessImpl:lye,lessEqualImpl:uye,linSpaceImpl:cye,logImpl:dye,maxImpl:hye,maximumImpl:fye,minimumImpl:pye,multiplyImpl:mye,negImpl:gye,notEqualImpl:yye,prodImpl:bye,raggedGatherImpl:vye,raggedRangeImpl:wye,raggedTensorToTensorImpl:xye,rangeImpl:Cye,rsqrtImpl:Sye,scatterImpl:Nye,sigmoidImpl:Tye,simpleAbsImpl:MV,sliceImpl:Iye,sparseFillEmptyRowsImpl:_ye,sparseReshapeImpl:Eye,sparseSegmentReductionImpl:PV,sqrtImpl:Dye,staticRegexReplaceImpl:kye,stridedSliceImpl:Aye,stringNGramsImpl:Rye,stringSplitImpl:Oye,stringToHashBucketFastImpl:Fye,subImpl:Mye,tileImpl:Pye,topKImpl:Lye,transposeImpl:vI,uniqueImpl:$ye}=O;function LV(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function ds(n,t){return 1===t?[n]:LV(n,t)}class Bye{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Zr(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=ds("rc",this.rank),r=an(this.rank),s=this.getOutOfBoundsCondition(e),o=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${t[t.length-1-i]},`+o;e.push(o)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class $V{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function zye(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function Vme(n,t,e="index"){const s=function $me(n,t){const e=n.length,r=n.map(o=>`${t}[${o}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let o=e-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(n.map((o,i)=>i),t);return s.map((o,i)=>`int ${n[i]} = ${e} / ${s[i]}; ${i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s[i]}`:`index -= ${n[i]} * ${s[i]}`};`).join("")}(["r","c","d"],"inputShape"):Lu(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":mI(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Uye{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){const s=BV(e,r),o=zV(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=VV(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===Fr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Fr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Fr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Fr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Fr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const o=BV(r,s),i=zV(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=VV(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=G().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function VV(n,t,e,r,s){const o=function Hye(n,t){switch(n){case Fr.PACKED_2X2_FLOAT32:return RV(t);case Fr.PACKED_2X2_FLOAT16:return OV(t);case Fr.UNPACKED_FLOAT32:return DV(t);case Fr.UNPACKED_FLOAT16:return kV(t);case Fr.PACKED_4X1_UNSIGNED_BYTE:return AV(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let i;if(s){const[l,u]=Dd(n[0],n[1]);i=l*u}else{const[l,u]=qp(n[0],n[1]);i=l*u}const a=function Wye(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,o);return i*a}function BV(n,t){if(n===qs.UPLOAD)return Fr.PACKED_2X2_FLOAT32;if(n===qs.RENDER||null==n)return function jye(n){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Fr.PACKED_2X2_FLOAT32:Fr.UNPACKED_FLOAT32:n?Fr.PACKED_2X2_FLOAT16:Fr.UNPACKED_FLOAT16}(t);if(n===qs.DOWNLOAD||n===qs.PIXELS)return Fr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function zV(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Gi{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const UV="return abs(x);",El="return x;";class Dl{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class n0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length);const e=t.length,r=ds("rc",e),s=an(e),o=function Vye(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const r0e=aN,vb={},a0e=G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let c0e=(()=>{class n extends CC{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof bI)r=e;else{const s=bi(G().getNumber("WEBGL_VERSION"),e);r=new bI(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=bi(G().getNumber("WEBGL_VERSION"));r=new bI(s),this.binaryCache=function i0e(n){return n in vb||(vb[n]={}),vb[n]}(G().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Uye(this.gpgpu),this.numMBBeforeWarning=function u0e(){return null==G().global.screen?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new sO(this,Us())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,o,i,a){const l=this.makeTensorInfo(r,s),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[o,i]},u.texShape=[o,i];const c=hb(r),d=new EV(c,!1,a),h=this.runWebGLProgram(d,[l],s,[[o,i]]);return h.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,r,s){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:qs.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if(G().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:qs.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(null!=a){let f;f=u?new Dl(l,El):new Gi(l,El);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:o}],o),g=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),g}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const c=null!=this.activeTimers;let d,h;return c&&(d=Ss()),h="complex64"===o?xa(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=Ss()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return J(function*(){if(r.pendingRead.has(e)){const m=r.pendingRead.get(e);return new Promise(y=>m.push(y))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=s;if(null!=a){let m;m=c?new Dl(i,El):new Gi(i,El);const y=r.runWebGLProgram(m,[{dataId:e,shape:i,dtype:l}],l),v=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),v}if(null!=o)return r.convertAndCacheOnCPU(e);if(G().getBool("DEBUG")&&!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===G().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&G().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const m=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(m.texture.texture,...ub(i))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const m=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);f=xa(m[0],m[1])}else if(null==d)f=r.getValuesFromTexture(e);else{const m=Z(i);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,m)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const m=r.gpgpu.gl;_e(m,()=>m.deleteBuffer(d))}const p=r.convertAndCacheOnCPU(e,f),g=r.pendingRead.get(e);return r.pendingRead.delete(e),g.forEach(m=>m(p)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Us().removeDataId(e,r),r.pendingDeletes--),p})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:o,shape:i,slice:a,dtype:l,isPacked:u,texture:c}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let p;p=u?new Dl(i,El):new Gi(i,El);const g=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:l}],l),m=this.readToGPU(g,r);return this.disposeIntermediateTensorInfo(g),m}if(null==c)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=Us().makeTensorFromTensorInfo(d),f=this.texData.get(d.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>sl(o));return Tt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Tt(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!fme(s))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=Z(r);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...ub(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),g}const a=G().getBool("WEBGL_PACK")&&!0===o,l=a?hb(r):r,u=a?new Ege(l):new _ge(l),c=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,o=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=o,i=!0):this.activeTimers.push(o),this.activeTimers=o,e();const a=mu(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=mu(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=s,i&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return J(function*(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=function DK(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ss(),endMs:null}}endTimer(e){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ss(),e)}getQueryTime(e){var r=this;return J(function*(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=a0e){return G().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&Z(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){lo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return r0e(e.shape,r)}packedUnaryOp(e,r,s){const o=new Dl(e.shape,r),i=this.compileAndRun(o,[e],s);return Us().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=MV(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,UV,e.dtype);const r=new Gi(e.shape,UV),s=this.compileAndRun(r,[e]);return Us().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&cf(s[0])){const i=s.map(a=>rl(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){return Us().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new n0e(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new Bye(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[kd(e.shape),...Ad(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[kd(r),...Ad(r)],a=new $V(i,s),c=this.runWebGLProgram(a,[o],e.dtype,[s],!0);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:o,shape:i,dtype:a}=s;null!=r&&_(Z(i)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=hb(i);let u;u=o?new Ige(l):new Tge(l);const d=[r??ub(l)];return{dtype:a,shape:i,dataId:this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,o,i=!1,a){const l=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Ed.DENSE){const v=a??ub(e.outputShape);u.texShape=v.map(w=>2*w)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===Z(l.shape))return u.values=Lr(l.dtype,0),l;const c=[],d=r.map(v=>{if("complex64"===v.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(null==w.texture){if(!e.packedInputs&&Z(v.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!e.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!pb(w.shape,v.shape)){const x=v,N=v.shape;v.shape=w.shape,v=this.packedReshape(v,N),c.push(v),w=this.texData.get(v.dataId),x.shape=N}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:u,isUniform:!1},f=function Nge(n,t,e){let r="";t.concat(e).forEach(i=>{const a=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=yI(n.packedInputs,i.shape,l);let h="",f="",p="";if(1===c.length&&n.packedInputs){const N=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${N[0]>1}_${N[1]>1}`}else if(2!==c.length||n.packedInputs){if(c.length>2&&!n.packedInputs){const N=Ge(c);p=`${N[0]===l[1]}_${N[N.length-1]===l[1]}`}}else f=`${c[0]>1}_${c[1]>1}`;const g=i.shape.length,m=2===c.length&&Pt(i.shape,l),y=1===Z(i.shape),v=ad(i.shape,e.shape),w=!n.packedInputs&&g===e.shape.length&&Pt(l,e.texData.texShape);r+=`${g}_${w}_${u?d:""}_${c.length}_${y}_${v}_${m}_${h}_${f}_${p}_${n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${a}`});let o=n.constructor.name;return o+="_"+r+"_"+n.userCode+`${G().getNumber("WEBGL_VERSION")}`,o}(e,d,h),p=this.getAndSaveBinary(f,()=>function Cge(n,t,e,r){const s=e.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),o=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Bme(s,i,t),l=function gme(n,t){const e=_a(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(_e(n,()=>n.shaderSource(e,t)),_e(n,()=>n.compileShader(e)),G().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw yV(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),u=n.createProgram(l);return G().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},IV(n,t,u)))}(this.gpgpu,e,d,h)),g=null!=this.activeTimers;let m;g&&(m=this.startTimer()),G().get("ENGINE_COMPILE_ONLY")||function Sge(n,t,e,r,s){t.program.enableShapeUniforms||(_V(t.inShapeInfos,e),_V([t.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===G().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const u=e[l],{uniform:c,offset:d,shape:h,texShape:f}=t.variablesLocations[l];if(h){const{uniformShape:p}=yI(t.program.packedInputs,u.shape,u.texData.texShape);switch(p.length){case 1:n.gl.uniform1iv(h,new Int32Array(p));break;case 2:n.gl.uniform2iv(h,new Int32Array(p));break;case 3:n.gl.uniform3iv(h,new Int32Array(p));break;case 4:n.gl.uniform4iv(h,new Int32Array(p))}}if(f&&n.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),null!=c){if(u.isUniform){if(Z(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let p=u.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),n.gl.uniform1fv(c,p)}continue}null!=u.texData.slice&&null!=d&&n.gl.uniform1i(d,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=Ge(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=s[l];if("float"===u.type)n.gl.uniform1fv(c,d);else if("vec2"===u.type)n.gl.uniform2fv(c,d);else if("vec3"===u.type)n.gl.uniform3fv(c,d);else if("vec4"===u.type)n.gl.uniform4fv(c,d);else if("int"===u.type)n.gl.uniform1iv(c,d);else if("ivec2"===u.type)n.gl.uniform2iv(c,d);else if("ivec3"===u.type)n.gl.uniform3iv(c,d);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);n.gl.uniform4iv(c,d)}}n.executeProgram()}(this.gpgpu,p,d,h,o),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const y=G().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const v=Ss();v-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===i){const v=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),v}return l}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=H(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=G().getBool("DEBUG");G().set("DEBUG",!1);const r=this.abs(Ke(1e-8)).dataSync()[0];if(G().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:u}=r;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=Ss());let h=r.texShape;if(null==h&&(h=function kme(n,t=!1){let e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=G().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&G().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,l)=>l>=n.length-2?SC(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=el(n).newShape);let s=Z(n),o=null;n.length<=1&&s<=e?o=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?o=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?o=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?o=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?o=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(o=[n[0],n[1]*n[2]*n[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||i)if(t){const a=kd(n);let l=2,u=2;n.length&&([l,u]=Ad(n)),s=a*(l/2)*(u/2),o=NC(s).map(c=>2*c)}else o=NC(s);return o}(s,u),r.texShape=h),null!=i){const f=hb(s);let p,g=h[1],m=h[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!y)&&([g,m]=Dd(h[0],h[1])),p=u?new kge(f,y):new EV(f,y);const v=y?[m,g]:h,w=this.makeTensorInfo(v,o),x=this.texData.get(w.dataId);x.usage=y?qs.PIXELS:qs.UPLOAD,x.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),g,m,i);const k=this.runWebGLProgram(p,[w],o,[[m,g]],!0),A=this.texData.get(k.dataId);r.texShape=A.texShape,r.isPacked=A.isPacked,r.usage=A.usage,G().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(r.texture=A.texture,r.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(w),c&&(this.uploadWaitMs+=Ss()-d)}else{const f=this.acquireTexture(h,l,o,u);r.texture=f}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return null!=r&&(s.values=function d0e(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*xy(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return J(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const o=new Promise(i=>{try{e.checkCompletion_(s),i(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return J(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield FM(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(yV(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:r,customUniformLocations:s,infLoc:o,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=IV(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=s,e.infLoc=o,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,r,s){e.channels=e.channels||"RGBA";const{texture:o,height:i,width:a,channels:l}=e,u=Us().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(o,r,s,i,a,l);return Us().makeTensorFromDataId(c,r,s,u)}}return n.nextDataId=0,n})();kO()&&FO("webgl",()=>new c0e,2);class Vu{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=mt(e,r),this.enableShapeUniforms=Zr(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Bu="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Pd{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=mt(e,r);const o=this.outputShape.length;this.enableShapeUniforms=Zr(o);let i="";if(s)if(0===o||1===Z(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${an(o)} coords = getOutputCoords();\n        `,1===o)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=ds("coords",o);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function Ks(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const p0e={kernelName:Af,backendName:"webgl",kernelFunc:Ks};function kl(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=Ks({inputs:{x:r},backend:e}),l=Ks({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:l},o}const m0e={kernelName:LC,backendName:"webgl",kernelFunc:kl},WV="return (a < 0.) ? b * a : a;",HV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",y0e={kernelName:Hy,backendName:"webgl",kernelFunc:function g0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r,i=e.makeTensorInfo([],"float32",nl(o,"float32")),a=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(HV,s.shape,i.shape):new Vu(WV,s.shape,i.shape),l=e.runWebGLProgram(a,[s,i],"float32");return e.disposeIntermediateTensorInfo(i),l}},jV="return (a < 0.) ? b * a : a;",GV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",v0e={kernelName:c0,backendName:"webgl",kernelFunc:function b0e(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(GV,r.shape,s.shape):new Vu(jV,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],"float32")}};function Wt({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const d=a.texData.get(i.dataId),h=e(d.values,l);return a.makeTensorInfo(i.shape,l,h)}let c;return c=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Dl(i.shape,t):new Gi(i.shape,n),a.runWebGLProgram(c,[i],l)}}function Hr({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(r&&"complex64"===l.dtype){const p=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,y]=[[p.complexTensorInfos.real,g.complexTensorInfos.real],[p.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(w=>{const[x,N]=w,I={dataId:x.dataId,dtype:x.dtype,shape:l.shape},k={dataId:N.dataId,dtype:N.dtype,shape:u.shape},A=new Vu(n,l.shape,u.shape);return c.runWebGLProgram(A,[I,k],zs(x.dtype,N.dtype))}),v=kl({inputs:{real:m,imag:y},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(y),v}const d=o||zs(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const p=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m="string"===l.dtype?Ca(p):p,y="string"===l.dtype?Ca(g):g,[v,w]=s(l.shape,u.shape,m,y,d),x=c.makeTensorInfo(w,d);return c.texData.get(x.dataId).values=v,x}let f;return f=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Pd(t,l.shape,u.shape,e):new Vu(n,l.shape,u.shape),c.runWebGLProgram(f,[l,u],d)}}function Jp(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?GV:jV;if("leakyrelu"===n)return t?HV:WV;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class qV{constructor(t,e,r,s=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Zr(this.outputShape.length);const d=Math.ceil((s?t[1]:t[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=o?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";a&&(m=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const v=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let w="rc.x",x="rc.x";t[0]<e[0]?w=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(x=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${w};\n        int batchB = ${x};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${g[0]});\n          result += (${p[1]} * ${g[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${v}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class XV{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=mt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const JV="return a * b;";function xI(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,o=zs(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),u=new XV("return areal * breal - aimag * bimag;",r.shape,s.shape),c=new XV("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=kl({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[u,c]=mye(r.shape,s.shape,a.values,l.values,o),d=e.makeTensorInfo(c,o);return e.texData.get(d.dataId).values=u,d}let i;return i=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(JV,r.shape,s.shape):new Vu(JV,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const w0e={kernelName:Bf,backendName:"webgl",kernelFunc:xI};function Te(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,i=e,a=Z(s.shape),l=aO(o,a),u=Z(l);_(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||pb(s.shape,l)||null!==c.texture&&pb(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function x0e(n,t,e){const r=[kd(n.shape),...Ad(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},o=[kd(t),...Ad(t)],i=new $V(o,r),u=e.runWebGLProgram(i,[s],n.dtype,[r],!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(s,l,i)}const C0e={kernelName:h0,backendName:"webgl",kernelFunc:Te};class ZV{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=t;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${qc(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class S0e{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=t;this.outputShape=[s,i];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function zu(n,t,e,r){const s=function N0e(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=g1(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let o=n;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===e?0===i?new ZV({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new ZV({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):new S0e({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},e),d=o,o=r.runWebGLProgram(c,[o],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class T0e{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[e[i]];this.outputShape=r,this.rank=r.length;const s=an(this.rank),o=function I0e(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class _0e{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let c=0;c<r.length;c++)r[c]=t[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=an(this.rank),o=LV("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function wb(n,t,e){const r=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _0e(n.shape,t):new T0e(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function xb(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;return function E0e(n,t,e,r){const o=n.shape.length,i=Rt(t,n.shape);let a=i;const l=Pn(a,o),u=null!=l;let c=n;u&&(c=wb(n,l,r),a=Zn(a.length,o)),Br("sum",a,o);const[d,h]=Rr(c.shape,a);let f=d;e&&(f=Jn(d,i));const p=Z(h),y=Te({inputs:{x:c},attrs:{shape:[Z(n.shape)/p,p]},backend:r}),w=zu(y,H2(n.dtype),"sum",r),x=Te({inputs:{x:w},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(w),u&&r.disposeIntermediateTensorInfo(c),x}(s,o,i,e)}const D0e={kernelName:b0,backendName:"webgl",kernelFunc:xb};function hs(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:o}=r,i=e,l=new Array(s.shape.length);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=vI(d,s.shape,s.dtype,o,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=h}else u=wb(s,o,i);return u}const k0e={kernelName:Yc,backendName:"webgl",kernelFunc:hs};function Cb({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=t.shape.length,d=e?n.shape[u-2]:n.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],f=e?n.shape[u-1]:n.shape[u-2],p=r?t.shape[c-2]:t.shape[c-1],g=n.shape.slice(0,-2),m=t.shape.slice(0,-2),y=Z(g),v=Z(m),x=mt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,p]);_(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const N=e?[y,d,f]:[y,f,d],I=r?[v,p,h]:[v,h,p],k=Te({inputs:{x:n},backend:s,attrs:{shape:N}}),A=Te({inputs:{x:t},backend:s,attrs:{shape:I}}),R=[k,A],F=Math.max(y,v),U=e?k.shape[1]:k.shape[2],q=null!=o,K=null!=i,Y="leakyrelu"===l,Q=null!=l?Jp(l,!0):null;let ie;if((1===f||1===p)&&U>1e3&&!1===(q||K||Y||null!=Q)){let ae=k,pe=A;e&&(ae=hs({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),R.push(ae)),r&&(pe=hs({inputs:{x:A},backend:s,attrs:{perm:[0,2,1]}}),R.push(pe));const we=1===p;let ye=ae;1!==p&&(ye=Te({inputs:{x:ae},backend:s,attrs:{shape:[F,U,1]}}),R.push(ye));const ke=1===p?2:1;let xe=pe;we&&(xe=Te({inputs:{x:pe},backend:s,attrs:{shape:[F,1,U]}}),R.push(xe));const Fe=xI({inputs:{a:ye,b:xe},backend:s});ie=xb({inputs:{x:Fe},backend:s,attrs:{axis:ke,keepDims:!0}}),R.push(Fe)}else{const ae=zs(n.dtype,t.dtype),pe=new qV(N,I,[F,f,p],e,r,q,Q,K,Y),me=[k,A];if(null!=o&&me.push(o),K&&me.push(i),Y){const we=s.makeTensorInfo([],"float32",nl(a,"float32"));me.push(we),R.push(we)}ie=s.runWebGLProgram(pe,me,ae)}const te=Te({inputs:{x:ie},backend:s,attrs:{shape:x}});R.push(ie);for(const ae of R)s.disposeIntermediateTensorInfo(ae);return te}const R0e={kernelName:I0,backendName:"webgl",kernelFunc:function A0e(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return Cb({a:s,b:o,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},QV="return abs(x);",F0e={kernelName:Cy,backendName:"webgl",kernelFunc:function O0e(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=MV(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Dl(r.shape,QV):new Gi(r.shape,QV),e.runWebGLProgram(s,[r],r.dtype)}},P0e=Wt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),L0e={kernelName:df,backendName:"webgl",kernelFunc:P0e},V0e=Wt({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),B0e={kernelName:hf,backendName:"webgl",kernelFunc:V0e},eB="return a + b;",z0e=Hr({opSnippet:eB,packedOpSnippet:eB,supportsComplex:!0,cpuKernelImpl:Kge}),U0e={kernelName:Zc,backendName:"webgl",kernelFunc:z0e};class W0e{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class H0e{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const j0e={kernelName:Sy,backendName:"webgl",kernelFunc:function Sb(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return Ks({inputs:{x:r[0]},backend:e});if(r.length>G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=Sb({inputs:r.slice(0,l),backend:e}),c=Sb({inputs:r.slice(l),backend:e});return Sb({inputs:[u,c],backend:e})}const s=r.map(l=>l.dtype).reduce((l,u)=>zs(l,u)),o=r.map(l=>l.shape),a=G().getBool("WEBGL_PACK")?new H0e(r[0].shape,o):new W0e(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},q0e={kernelName:"All",backendName:"webgl",kernelFunc:function G0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=Rt(o,s.shape);let u=l;const c=Pn(u,a);let d=s;null!=c&&(d=hs({inputs:{x:s},backend:e,attrs:{perm:c}}),u=Zn(u.length,a)),Br("all",u,a);const[h,f]=Rr(d.shape,u),g=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,Z(f)]}}),m=zu(g,g.dtype,"all",e);let y;return y=Te(i?{inputs:{x:m},backend:e,attrs:{shape:Jn(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},X0e={kernelName:"Any",backendName:"webgl",kernelFunc:function K0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=Rt(o,s.shape);let u=l;const c=Pn(u,a);let d=s;null!=c&&(d=hs({inputs:{x:s},backend:e,attrs:{perm:c}}),u=Zn(u.length,a)),Br("any",u,a);const[h,f]=Rr(d.shape,u),g=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,Z(f)]}}),m=zu(g,g.dtype,"any",e);let y;return y=Te(i?{inputs:{x:m},backend:e,attrs:{shape:Jn(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class J0e{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Z0e{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,_(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=an(l),c=ds("coords",l);let d,h;if(1===i){h=l+1;const A=an(h);d=`\n        ${A} sourceLocR = ${A}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${A} sourceLocG = ${A}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${A} sourceLocA = ${A}(${c.join()}, 0);\n        --${c[l-1]};\n        ${A} sourceLocB = ${A}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],g=f.map(A=>"int "+A),m=ds("sourceLocR",h-1).concat("inIdx.r"),y=ds("sourceLocG",h-1).concat("inIdx.g"),v=ds("sourceLocB",h-1).concat("inIdx.b"),w=ds("sourceLocA",h-1).concat("inIdx.a"),x="max"===r?"greaterThan":"lessThan",N=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()}),\n                             getBestIndicesAChannel(${w.join()})));`,I=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${v.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,k=s?"":`\n      float getBestIndicesAChannel(${g.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${g.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${N}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function tB(n,t,e,r=null){let s=t.shape[0],o=t.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=g1(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new J0e(a,e,null==r),u=[t];null!=r&&u.push(r);const c=n.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=tB(n,t,e,c);return n.disposeIntermediateTensorInfo(c),d}function nB(n,t,e,r=null){const s=null!=r?r.shape:t.shape,i=g1(s[s.length-1]),a=new Z0e(s,i,e,null==r),u=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(u.shape.length===t.shape.length){const c=nB(n,t,e,u);return n.disposeIntermediateTensorInfo(u),c}return u}function rB(n,t,e,r){const s=[e];if(Br("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const o=[],i=n.texData.get(t.dataId);let l=t;null!==i&&i.isPacked&&(l=n.unpackTensor(t),o.push(l));const[u,c]=Rr(l.shape,s),d=Z(c),h=Te({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});o.push(h);const f=tB(n,h,r);o.push(f);const p=Te({inputs:{x:f},backend:n,attrs:{shape:u}});return o.forEach(g=>n.disposeIntermediateTensorInfo(g)),p}return nB(n,t,r)}const Q0e={kernelName:Ny,backendName:"webgl",kernelFunc:function Y0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let i=Rt(o,s.shape);const a=Pn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=hs({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=Zn(i.length,l.shape.length)),Br("argMax",[i[0]],l.shape.length);const c=rB(e,l,i[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},t1e={kernelName:Ty,backendName:"webgl",kernelFunc:function e1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let i=Rt(o,s.shape);const a=Pn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=hs({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=Zn(i.length,l.shape.length)),Br("argMin",[i[0]],l.shape.length);const c=rB(e,l,i[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},r1e=Wt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),s1e={kernelName:ff,backendName:"webgl",kernelFunc:r1e},i1e=Wt({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),a1e={kernelName:pf,backendName:"webgl",kernelFunc:i1e},u1e=Wt({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),c1e={kernelName:mf,backendName:"webgl",kernelFunc:u1e},f1e=Hr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),p1e={kernelName:yf,backendName:"webgl",kernelFunc:f1e},g1e=Wt({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),y1e={kernelName:gf,backendName:"webgl",kernelFunc:g1e};class Zp{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const g="avg"===e;let v="0.0";if(g||(v="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / max(count, 1.0)");const N=4*Math.floor(i/4),I=i%4,k=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${N}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${N};\n          if (${1===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class CI{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,g=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,v=t.padInfo.left;this.outputShape=t.outShape;const w="avg"===e;let x="0.0";if(w||(x="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${m}, ${y}, ${v});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${g};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${g} +\n                      wR * ${g} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let I=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(I="avgValue / max(count, 1.0)");const k=4*Math.floor(i/4),A=i%4,R=`\n      if (${w}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${m}, ${y}, ${v});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${R}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${2===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${3===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${R}\n            }\n          }\n        }\n        setOutput(${I});\n      }\n    `}}const v1e={kernelName:Iy,backendName:"webgl",kernelFunc:function b1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Kp(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(Vr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&Pt(c.inShape,c.outShape))return Ks({inputs:{x:s},backend:e});const d=new Zp(c,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},x1e={kernelName:_y,backendName:"webgl",kernelFunc:function w1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,d=ba(s.shape,o,i,[1,1,1],a,l,u),h=new CI(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class C1e{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class S1e{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${f-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const T1e={kernelName:FC,backendName:"webgl",kernelFunc:function N1e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=ba(i.shape,a,l,[1,1,1],u,c),f=new S1e(h);return e.runWebGLProgram(f,[s],i.dtype)}},_1e={kernelName:OC,backendName:"webgl",kernelFunc:function I1e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o;Kp([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Ro(i.shape,a,l,1,u),d=new C1e(c);return e.runWebGLProgram(d,[s],i.dtype)}},D1e={kernelName:Ey,backendName:"webgl",kernelFunc:function E1e(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;return Cb({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class k1e{constructor(t,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],mt(t,e),mt(t,r);let a="0.0";null!=s&&(mt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(mt(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class A1e{constructor(t,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],mt(t,e),mt(t,r);let a="vec4(0.0)";null!=s&&(mt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(mt(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const R1e={kernelName:zy,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=n;_(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[r,s,o];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=a&&(d=a.shape,u.push(a));const h=G().getBool("WEBGL_PACK_NORMALIZATION")?new A1e(r.shape,s.shape,o.shape,c,d,l):new k1e(r.shape,s.shape,o.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}};class O1e{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=an(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function F1e(n){if(1===n)return"sourceLoc";if(n<=6)return SI.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((i,a)=>`sourceLoc.${SI[a]} = start[${a}] + coords.${SI[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const SI=["x","y","z","w","u","v"];class M1e{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=an(this.rank),r=ds("coords",this.rank),s=ds("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((c,d)=>`start[${d}]`).join()});`:t.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function $d(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:i}=r,[a,l]=W0(s,o,i);if(NS(s,a,l),0===Z(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Iye(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=e.texData.get(s.dataId),c=IS(s.shape,a,l);if(u||!c){const d=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new M1e(l):new O1e(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function P1e(n,t,e,r){const s=r.texData.get(n.dataId),o=r.makeTensorInfo(e,n.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=n.dtype;let a=_S(t,Ge(n.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,e)}const L1e={kernelName:y0,backendName:"webgl",kernelFunc:$d},$1e={kernelName:Dy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:i}=r;_(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((v,w)=>v*w),l=Tp(s.shape,o,a),u=Ip(l.length,o.length),c=_p(s.shape,o,a),d=NN(i,o.length),h=TN(c,i,o.length),f=[],p=Te({inputs:{x:s},backend:e,attrs:{shape:l}}),g=hs({inputs:{x:p},backend:e,attrs:{perm:u}}),m=Te({inputs:{x:g},backend:e,attrs:{shape:c}}),y=$d({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(g),f.push(m),f.forEach(v=>e.disposeIntermediateTensorInfo(v)),y}},B1e={kernelName:MC,backendName:"webgl",kernelFunc:function V1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i}=r,a=e.readSync(s.dataId),l=e.readSync(o.dataId),u=FV(a,l,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},H1e={kernelName:ky,backendName:"webgl",kernelFunc:function W1e(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=G().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,s])||1===i){const l=e.texData.get(r.dataId).values,u=e.texData.get(s.dataId).values,[c,d]=Jge(r.shape,s.shape,l,u,r.dtype),h=e.makeTensorInfo(d,r.dtype);return e.texData.get(h.dataId).values=c,h}let a;return a=o?new Pd("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new Vu("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),e.runWebGLProgram(a,[r,s],r.dtype)}},G1e={kernelName:PC,backendName:"webgl",kernelFunc:function j1e(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.readSync(r.dataId),i=e.readSync(s.dataId),a=mt(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},sB=Hr({opSnippet:"return float(a != b);",cpuKernelImpl:yye,dtype:"bool"}),q1e={kernelName:s0,backendName:"webgl",kernelFunc:sB};function Yp(n){const{inputs:t,backend:e}=n,{input:r}=t;return Ks({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const K1e={kernelName:b2,backendName:"webgl",kernelFunc:Yp},Z1e={kernelName:bf,backendName:"webgl",kernelFunc:function NI(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Ks({inputs:{x:s},backend:e});const i=ar(s.shape),a=NI({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=kl({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=Yp({inputs:{input:s},backend:e}),a=NI({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!lO(s.dtype,o)){const i=Ks({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId).values,[a,l,u]=Zge(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}if("int32"===o)return function J1e(n,t){const e=new Gi(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",Lr("bool",1)),l=sB({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},oB="return ceil(x);",Y1e=Wt({opSnippet:oB,packedOpSnippet:oB,cpuKernelImpl:Yge}),Q1e={kernelName:vf,backendName:"webgl",kernelFunc:Y1e};class ebe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class tbe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const rbe={kernelName:wf,backendName:"webgl",kernelFunc:function nbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:o,clipValueMax:i}=r;let a;return a=G().getBool("WEBGL_PACK_CLIP")?new tbe(s.shape):new ebe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[o],[i]])}};class sbe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function iB(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const ibe={kernelName:Ay,backendName:"webgl",kernelFunc:function obe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),o=new sbe(r.shape),i=[iB(r,s.complexTensorInfos.real),iB(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class abe{constructor(t){this.outputShape=[],this.outputShape=Li(t,1),this.variableNames=t.map((i,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class lbe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Li(t,e);const r=this.outputShape,s=r.length,o=an(s),i=ds("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((g,m)=>`T${m}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+t[g][e];const u=a[e],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let g=1;g<l.length;g++){const m=l[g-1];h+=`\n        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {\n          return getChannel(\n            getT${g}(${Nb(a,u,m)}),\n            vec2(${Nb(c,u,m)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Nb(a,u,p)}),\n          vec2(${Nb(c,u,p)}));`,this.userCode=`\n      float getValue(${a.map(g=>"int "+g)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Nb(n,t,e){const r=n.indexOf(t);return n.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function Tb(n){const{inputs:t,backend:e}=n,{input:r}=t;return Ks({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const ube={kernelName:s2,backendName:"webgl",kernelFunc:Tb};function Qp(n,t,e){const r=n[0].dtype;if("complex64"===r){const f=n.map(v=>Yp({inputs:{input:v},backend:e})),p=n.map(v=>Tb({inputs:{input:v},backend:e})),g=Qp(f,t,e),m=Qp(p,t,e),y=kl({inputs:{real:g,imag:m},backend:e});return f.forEach(v=>e.disposeIntermediateTensorInfo(v)),p.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const f=n.map(x=>{const N=Z(x.shape.slice(t));return Te({inputs:{x},backend:e,attrs:{shape:[-1,N]}})}),p=f.map(x=>({vals:e.readSync(x.dataId),shape:x.shape})),g=Li(f.map(x=>x.shape),1),y=Qge(p,g,r,1===f[0].shape[0]),v=Li(n.map(x=>x.shape),t),w=e.makeTensorInfo(v,r,y);return f.forEach(x=>e.disposeIntermediateTensorInfo(x)),w}const o=n.filter(f=>Z(f.shape)>0),i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const f=i?new Gi(n[0].shape,El):new Dl(n[0].shape,El);return e.runWebGLProgram(f,n,r)}const a=G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const f=[];for(let g=0;g<o.length;g+=a){const m=o.slice(g,g+a);f.push(Qp(m,t,e))}const p=Qp(f,t,e);for(const g of f)e.disposeIntermediateTensorInfo(g);return p}if(i){const f=new lbe(o.map(p=>p.shape),t);return e.runWebGLProgram(f,o,r)}const{tensors2D:l,outShape:u}=function cbe(n,t,e){const r=Li(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>Te({inputs:{x:o},attrs:{shape:[-1,Z(o.shape.slice(t))]},backend:e})),outShape:r}}(o,t,e),c=new abe(l.map(f=>f.shape)),d=e.runWebGLProgram(c,l,r);l.forEach(f=>e.disposeIntermediateTensorInfo(f));const h=Te({inputs:{x:d},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(d),h}function aB(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=Rt(s,t[0].shape)[0];xN(t.map(u=>u.shape),o);const a=Li(t.map(u=>u.shape),o);if(0===Z(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(u=>Z(u.shape)>0);return 1===l.length?Ks({inputs:{x:l[0]},backend:e}):Qp(l,o,e)}const dbe={kernelName:Ry,backendName:"webgl",kernelFunc:aB};class lB{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),g=t.inChannels%4,m="channelsLast"===t.dataFormat,y=m?1:2,v=m?2:3,w=m?3:1;let x="",N="";r&&(x=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,N="result = activation(result);");const I=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${w}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${v}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===g}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===g}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===g}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${I}\n        ${N}\n        setOutput(result);\n      }\n    `}}class hbe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,o=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),g=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===g}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class uB{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Zr(this.outputShape.length);const i=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let m=0;m<c;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(d+1)/2;m++){const y=2*m;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<c)){const v=i%2==0?SC(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${v};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===v?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${v};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<c&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<c&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<c&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let f="",p="";r&&(f=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,p="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${g}\n         ${p}\n         setOutput(result);\n       }\n     `}}class fbe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Zr(this.outputShape.length);const{dataFormat:r}=e,s=cs(),o="channelsLast"===r,i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${c};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${s.output} = result;\n      }\n    `}}function Ib(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function cB({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.shape,u=r.texData.get(n.dataId),c=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,f="channelsLast"===e.dataFormat;let m;const y=[];if(null!=o){const x=Ib(o.shape,f);null!=x&&(o=Te({inputs:{x:o},backend:r,attrs:{shape:x}}),y.push(o))}if(null!=s){const x=Ib(s.shape,f);null!=x&&(s=Te({inputs:{x:s},backend:r,attrs:{shape:x}}),y.push(s))}if((1!==d&&1!==h||!(c>1e3))&&u.isPacked&&f&&null!=u.texture&&l[2]%2!=0&&Pt(u.shape.slice(-3),l.slice(-3))){const N={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},I=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,_(pb(u.shape,N.shape),()=>`packed reshape ${u.shape} to ${N.shape} isn't free`);const k=Te({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(k);const A=Cb({a:N,b:k,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),R=r.texData.get(A.dataId);_(R.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=I,R.shape=e.outShape,m=Ks({inputs:{x:A},backend:r}),m.shape=e.outShape,y.push(A)}else{const x=e.outHeight*e.outWidth,N=Te({inputs:{x:n},backend:r,attrs:{shape:f?[e.batchSize,x,e.inChannels]:[e.batchSize,e.inChannels,x]}}),I=Te({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),k=Cb({a:f?N:I,b:f?I:N,transposeA:!f,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});m=Te({inputs:{x:k},backend:r,attrs:{shape:e.outShape}}),y.push(N),y.push(I),y.push(k)}for(const x of y)r.disposeIntermediateTensorInfo(x);return m}function dB({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,g=l*u*c,m=h*d,y=[e.batchSize,g,m],x=[];if(null!=o){const te=Ib(o.shape,p);null!=te&&(o=Te({inputs:{x:o},backend:r,attrs:{shape:te}}),x.push(o))}if(null!=s){const te=Ib(s.shape,p);null!=te&&(s=Te({inputs:{x:s},backend:r,attrs:{shape:te}}),x.push(s))}const N=Te({inputs:{x:t},backend:r,attrs:{shape:[1,g,Z(t.shape)/g]}});x.push(N);const I=new fbe(y,e),A=r.runWebGLProgram(I,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),R=Te({inputs:{x:A},backend:r,attrs:{shape:y}});x.push(A),x.push(R);const F=null!=s,U=null!=o,q="leakyrelu"===a,K=a?Jp(a,!0):null,Y=new qV(p?R.shape:N.shape,p?N.shape:R.shape,p?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],!0,!1,F,K,U,q),Q=p?[R,N]:[N,R];if(s&&Q.push(s),U&&Q.push(o),q){const te=r.makeTensorInfo([],"float32",nl(i,"float32"));Q.push(te),x.push(te)}const se=r.runWebGLProgram(Y,Q,"float32"),ie=Te({inputs:{x:se},backend:r,attrs:{shape:e.outShape}});x.push(se);for(const te of x)r.disposeIntermediateTensorInfo(te);return ie}const mbe={kernelName:Oy,backendName:"webgl",kernelFunc:function pbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=va(l),h=Ar(s.shape,o.shape,i,u,a,c,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&G().getBool("WEBGL_EXP_CONV")){const g=new uB(h);f=e.runWebGLProgram(g,[s,o],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(G().getBool("WEBGL_CONV_IM2COL"))f=dB({x:s,filter:o,convInfo:h,backend:e});else{const g=new lB(h);f=e.runWebGLProgram(g,[s,o],"float32")}else f=cB({x:s,filter:o,convInfo:h,backend:e});const p=Te({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class gbe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ybe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,i="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class bbe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vbe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const xbe={kernelName:$C,backendName:"webgl",kernelFunc:function wbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=va(l),h=Ar(s.shape,c,i,1,a,u,!1,d),f=new gbe(h);return e.runWebGLProgram(f,[s,o],"float32")}};class Cbe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Zr(this.outputShape.length);const e=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const Nbe={kernelName:Fy,backendName:"webgl",kernelFunc:function Sbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=va(u),h=Ar(i,o.shape,a,1,l,c,!1,d);if(G().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const f=[[h.strideHeight,h.strideWidth]],p=new Cbe(h);return e.runWebGLProgram(p,[s,o],"float32",f)}{const f=new ybe(h);return e.runWebGLProgram(f,[s,o],"float32")}}},Ibe={kernelName:My,backendName:"webgl",kernelFunc:function Tbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r,u=dl(s.shape,o.shape,i,l,a),c=new hbe(u);return e.runWebGLProgram(c,[s,o],"float32")}},Ebe={kernelName:VC,backendName:"webgl",kernelFunc:function _be(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:l}=r,u=dl(s.shape,l,i,1,a),c=new bbe(u);return e.runWebGLProgram(c,[s,o],"float32")}},kbe={kernelName:BC,backendName:"webgl",kernelFunc:function Dbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:l}=r,u=dl(l,o.shape,a,1,i),c=new vbe(u);return e.runWebGLProgram(c,[s,o],"float32")}},Obe=Wt({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Bu}\n  return result;\n`}),Fbe={kernelName:xf,backendName:"webgl",kernelFunc:Obe},Mbe=Wt({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Pbe={kernelName:Cf,backendName:"webgl",kernelFunc:Mbe};class Lbe{constructor(t,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=t,[c]=e,[d,h]=r;this.outputShape=[c,d,h,u];const f="bilinear"===s?1:0,[p,g]=[a-1+".0",l-1+".0"],[m,y,v]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[w,x,N]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${w});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${x};\n\n        float in_y = ${v};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${N};\n        if( in_x < 0.0 || in_x > ${g} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const $be={kernelName:UC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=r,c=new Lbe(s.shape,o.shape,a,l,u);return e.runWebGLProgram(c,[s,o,i],"float32")}};var Vd=(()=>{return(n=Vd||(Vd={})).Prod="*",n.Sum="+",Vd;var n})();class hB{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===Vd.Prod?"1.0":"0.0":`getX(${fB(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?"end != "+(l-1):"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${an(o)} coords = getOutputCoords();\n        int end = ${pB(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${c};\n          ${pB(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${fB(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function fB(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function pB(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function mB(n,t,e,r,s,o){const i=t.shape.length,a=Pn([r],i);let l=t;null!=a&&(l=hs({inputs:{x:t},backend:e,attrs:{perm:a}}));const u=Zn(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=Ks({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const f=new hB(n,l.shape,!1,o),g=d;d=e.runWebGLProgram(f,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(g)}if(s){const h=new hB(n,l.shape,s,o),f=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(f)}if(null!=a){const f=hs({inputs:{x:d},backend:e,attrs:{perm:pl(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),f}return d}const Bbe={kernelName:zC,backendName:"webgl",kernelFunc:function Vbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;return mB(Vd.Prod,s,e,o,i,a)}},Ube={kernelName:Py,backendName:"webgl",kernelFunc:function zbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;return mB(Vd.Sum,s,e,o,i,a)}},Hbe={kernelName:WC,backendName:"webgl",kernelFunc:function Wbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=FV(l,u,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const l=e.bufferSync(s),u=e.bufferSync(o),c=Xge(l,u,i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class jbe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const qbe={kernelName:HC,backendName:"webgl",kernelFunc:function Gbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:i}=r,a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,h=("NHWC"===i?s.shape[2]:s.shape[3])*o,f=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),g=new jbe("NHWC"===i?[a,d,h,f]:[a,f,d,h],o,i);return e.runWebGLProgram(g,[s],s.dtype)}};class gB{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Zr(this.outputShape.length);const i=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";r&&(u=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,c="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${c}\n        setOutput(result);\n      }\n    `}}class yB{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Zr(this.outputShape.length);const i=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,h=d;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)f+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;f+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let y=0;y<d;y++)f+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const v=2*y;if(f+=`\n          xC = xCCorner + ${v*u};\n          `,1===l){if(v<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n              `,f+=1===u&&v>0?`\n                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);\n                  } else {\n                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                xC${v} = xTexelC${v};\n                `,v+1<d)){const w=a%2==0?SC(u):u;u%2==0&&a%2==1||u%2!=0&&a%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${w};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${v+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${v+1}Ready = 1;\n                  }\n                  `,f+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);\n                    } else {\n                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);\n                    }\n                    `:`\n                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);\n                    `):f+=1===w?`\n                    xC${v+1} = xTexelC${v};\n                    `:`\n                    xCOffset = xC + ${w};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${v+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${v+1}Ready = 1;\n                    }\n\n                    xC${v+1} = xTexelC${v+1};\n                    `}}else v<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {\n                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${v+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${v+1}Ready = 1;\n                }\n\n                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);\n              `,v+1<d&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v+1}.zw = vec2(0.);\n                  }\n                  xTexelC${v+1}Ready = 1;\n                }\n\n                xC${v} = vec4(\n                  xTexelC${v}.xy, xTexelC${v+1}.xy);\n              `,v+1<d&&(f+=`\n                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);\n                `)));v<d&&(f+=`\n            wTexel = getW(r, ${v}, d1, q);\n            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);\n          `,v+1<d&&(f+=`\n              wTexel = getW(r, ${v+1}, d1, q);\n              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let p="",g="";r&&(p=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,g="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${g}\n        setOutput(result);\n      }\n    `}}const Xbe={kernelName:Ly,backendName:"webgl",kernelFunc:function Kbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),_(Vr(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Ar(s.shape,o.shape,i,c,a,u,!0);let h;return h=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new yB(d):new gB(d),e.runWebGLProgram(h,[s,o],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class Jbe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Zbe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Qbe={kernelName:jC,backendName:"webgl",kernelFunc:function Ybe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=Ar(s.shape,c,i,a,l,u,!0),h=new Jbe(d);return e.runWebGLProgram(h,[s,o],"float32")}},tve={kernelName:GC,backendName:"webgl",kernelFunc:function eve(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=Ar(c,o.shape,i,a,l,u,!0),h=new Zbe(d);return e.runWebGLProgram(h,[s,o],"float32")}};class nve{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const sve={kernelName:qC,backendName:"webgl",kernelFunc:function rve(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],o=Z(r.shape),i=Te({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new nve(o),l=e.runWebGLProgram(a,[i],i.dtype),u=Te({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}};class ove{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const ave={kernelName:$y,backendName:"webgl",kernelFunc:function ive(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r,u=dp(s.shape,o.shape,i,a,"NHWC",l);let c;const d=new ove(u);c=e.runWebGLProgram(d,[s,o],"float32");const h=Te({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},uve={kernelName:ZC,backendName:"webgl",kernelFunc:function lve(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:l}=MN(s,o.length);LN(i.length,l,o);const{path:u,steps:c}=$N(a,l),d=c.length;let h=null,f=i.length;const p=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:v}=PN(f,l[m]);let w;VN(y)?w=o[m]:(w=hs({inputs:{x:o[m]},backend:e,attrs:{perm:y}}),p.push(w));const x=w.shape.slice();for(let N=0;N<v.length;++N)x.splice(v[N],0,1);Pt(w.shape,x)||(w=Te({inputs:{x:w},backend:e,attrs:{shape:x}}),p.push(w)),null===h?h=w:(h=xI({inputs:{a:w,b:h},backend:e}),p.push(h))}g<d-1&&(u[g]>=0&&(h=xb({inputs:{x:h},backend:e,attrs:{axis:u[g]-(i.length-f),keepDims:!1}}),p.push(h)),f--)}for(const g of p)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},cve=Wt({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),dve={kernelName:Nf,backendName:"webgl",kernelFunc:cve},pve={kernelName:YC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Vu("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},mve=Hr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:eye}),gve={kernelName:Vy,backendName:"webgl",kernelFunc:mve},bve=Wt({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${_N};\n  float a1 = ${EN};\n  float a2 = ${DN};\n  float a3 = ${kN};\n  float a4 = ${AN};\n  float a5 = ${RN};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),vve={kernelName:Tf,backendName:"webgl",kernelFunc:bve},bB=Wt({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:tye,dtype:"float32"}),xve={kernelName:If,backendName:"webgl",kernelFunc:bB};function TI(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:o}=t,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(_(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Te({inputs:{x:o},backend:r,attrs:{shape:a}})}const Cve={kernelName:By,backendName:"webgl",kernelFunc:TI},vB="return exp(x) - 1.0;",Sve=Wt({opSnippet:vB,packedOpSnippet:vB,cpuKernelImpl:nye}),Nve={kernelName:_f,backendName:"webgl",kernelFunc:Sve};class wB{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function xB(n,t,e){const r=e.texData.get(n.dataId),s=Z(n.shape),o=n.shape[n.shape.length-1],a=Te({inputs:{x:n},backend:e,attrs:{shape:[s/o,o]}}),l=a.shape,u=new wB("real",l,t),c=new wB("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=kl({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const g=Te({inputs:{x:p},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),g}const Ive={kernelName:"FFT",backendName:"webgl",kernelFunc:function Tve(n){const{inputs:t,backend:e}=n,{input:r}=t;return xB(r,!1,e)}};class _ve{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function em(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||Xc(s),"string"===o){const i=Xn(o,Z(r));return i.fill(s),t.makeTensorInfo(r,o,i)}{const i=new _ve(r,s);return t.runWebGLProgram(i,[],o,[[s]])}}const Eve={kernelName:e2,backendName:"webgl",kernelFunc:em};class Dve{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const kve={kernelName:t2,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new Dve(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},CB="return floor(x);",Ave=Wt({opSnippet:CB,packedOpSnippet:CB,cpuKernelImpl:rye}),Rve={kernelName:Ef,backendName:"webgl",kernelFunc:Ave},Ove=Hr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Fve={kernelName:Df,backendName:"webgl",kernelFunc:Ove};class Mve{constructor(t){this.variableNames=["A"];const e=cs(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Pve{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=cs(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const Lve={kernelName:L2,backendName:"webgl",kernelFunc:function $ve(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,o];if(a||i){const g=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Bd||g!==II)&&(II=g,Bd=document.createElement("canvas").getContext("2d",{willReadFrequently:II})),Bd.canvas.width=l,Bd.canvas.height=u,Bd.drawImage(s,0,0,l,u),s=Bd.canvas}const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=qs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const f=G().getBool("WEBGL_PACK")?new Pve(d):new Mve(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let Bd,II=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Bve={kernelName:_0,backendName:"webgl",kernelFunc:function Vve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,g=va(c),m=Ar(s.shape,o.shape,l,d,u,h,!1,g);let y;const v=[],w=null!=i,x=null!=a,N="leakyrelu"===f,I=()=>{const A=[s,o],R=(F,U)=>{if("NCHW"===U&&1===F.shape.length&&1!==F.shape[0]){const q=Te({inputs:{x:F},backend:e,attrs:{shape:[F.shape[0],1,1]}});return v.push(q),q}return F};if(w&&A.push(R(i,c)),x&&A.push(R(a,c)),N){const F=e.makeTensorInfo([],"float32",nl(p,"float32"));A.push(F),v.push(F)}return A};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&G().getBool("WEBGL_EXP_CONV")){const A=f?Jp(f,!0):null,R=new uB(m,w,A,x,N),F=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],U=I();y=e.runWebGLProgram(R,U,"float32",F)}else if(G().getBool("WEBGL_CONV_IM2COL"))y=dB({x:s,filter:o,convInfo:m,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const A=f?Jp(f,!1):null,R=new lB(m,w,A,x,N),F=I();y=e.runWebGLProgram(R,F,"float32")}else y=cB({x:s,filter:o,convInfo:m,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const k=Te({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return v.push(y),v.forEach(A=>e.disposeIntermediateTensorInfo(A)),k}},Uve={kernelName:E0,backendName:"webgl",kernelFunc:function zve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let g=c;null==g&&(g=[1,1]),_(Vr(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=Ar(s.shape,o.shape,l,g,u,d,!0),y=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,v=h?Jp(h,y):null,w=[s,o],x=null!=i,N=null!=a,I="leakyrelu"===h;if(x&&w.push(i),N&&w.push(a),I){const F=e.makeTensorInfo([],"float32",nl(f,"float32"));w.push(F),p.push(F)}let k;k=y?new yB(m,x,v,N,I):new gB(m,x,v,N,I);const R=e.runWebGLProgram(k,w,"float32",[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]]);return p.forEach(F=>e.disposeIntermediateTensorInfo(F)),R}};class Wve{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=an(r.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const jve={kernelName:n2,backendName:"webgl",kernelFunc:function Hve(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=s.shape,i=o[o.length-1],a=Z(r.shape),[l,u,c,d]=IN(r,s),h=Te({inputs:{x:s},backend:e,attrs:{shape:[u,i]}}),f=Te({inputs:{x:r},backend:e,attrs:{shape:[Z(r.shape)/c,c]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=e.readSync(s.dataId),v=e.bufferSync(r),w=sye(y,v,r.dtype,u,i,c,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,w.values)}const p=new Wve(i,d,[u,c],r.shape),g=e.runWebGLProgram(p,[f,h],f.dtype),m=Te({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}};class Gve{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=an(this.rank),s=function qve(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function SB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:i,batchDims:a}=r,l=Rt(i,s.shape)[0];if(G().get("DEBUG")){const v=e.readSync(o.dataId),w=s.shape[l];for(let x=0;x<v.length;++x){const N=v[x];_(N<=w-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${w-1}]`)}}const u=UN(s,o,l,a),c=Z(o.shape),d=[],h=Te({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=Te({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(f);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const v=e.bufferSync(f),w=e.bufferSync(h),x=oye(w,v,p);return d.forEach(N=>e.disposeIntermediateTensorInfo(N)),e.makeTensorInfo(u.outputShape,x.dtype,x.values)}const g=new Gve(h.shape,p),m=e.runWebGLProgram(g,[h,f],h.dtype);d.push(m);const y=Te({inputs:{x:m},backend:e,attrs:{shape:u.outputShape}});return d.forEach(v=>e.disposeIntermediateTensorInfo(v)),y}const Kve={kernelName:Uy,backendName:"webgl",kernelFunc:SB},Xve=Hr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:iye,dtype:"bool"}),Jve={kernelName:Wy,backendName:"webgl",kernelFunc:Xve},Zve=Hr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:aye}),Yve={kernelName:kf,backendName:"webgl",kernelFunc:Zve},ewe={kernelName:r2,backendName:"webgl",kernelFunc:function Qve(n){const{inputs:t,backend:e}=n,{input:r}=t;return xB(r,!0,e)}},twe=Wt({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),nwe={kernelName:Rf,backendName:"webgl",kernelFunc:twe},rwe=Wt({opSnippet:"return float(isinf(x));",dtype:"bool"}),swe={kernelName:Of,backendName:"webgl",kernelFunc:rwe},owe=Wt({opSnippet:"return float(isnan(x));",dtype:"bool"}),iwe={kernelName:Ff,backendName:"webgl",kernelFunc:owe},awe=Hr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:lye,dtype:"bool"}),lwe={kernelName:jy,backendName:"webgl",kernelFunc:awe},uwe=Hr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:uye,dtype:"bool"}),cwe={kernelName:Gy,backendName:"webgl",kernelFunc:uwe},hwe={kernelName:o2,backendName:"webgl",kernelFunc:function dwe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,i=cye(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},pwe=Wt({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:dye}),mwe={kernelName:Mf,backendName:"webgl",kernelFunc:pwe},ywe=Wt({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),bwe={kernelName:Pf,backendName:"webgl",kernelFunc:ywe},vwe=Hr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),wwe={kernelName:qy,backendName:"webgl",kernelFunc:vwe},xwe=Wt({opSnippet:"return float(!(x >= 1.0));"}),Cwe={kernelName:Ky,backendName:"webgl",kernelFunc:xwe},Swe=Hr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Nwe={kernelName:Xy,backendName:"webgl",kernelFunc:Swe};class Twe{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=t[3]-1;let l;this.outputShape=t;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class Iwe{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=t[3]-1;let l;this.outputShape=t;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const _we={kernelName:Jy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:l}=r,u=G().getBool("WEBGL_PACK_NORMALIZATION")?new Iwe(s.shape,o,i,a,l):new Twe(s.shape,o,i,a,l);return e.runWebGLProgram(u,[s],s.dtype)}};class Ewe{constructor(t,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Dwe={kernelName:i2,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new Ewe(s.shape,a,l,u,c);return e.runWebGLProgram(d,[s,o,i],s.dtype)}};function NB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=Rt(o,s.shape);let u=l;const c=Pn(u,a),d=null!=c,h=e.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const w=e.texData.get(f.dataId).values,x=new Array(a);for(let k=0;k<x.length;k++)x[k]=s.shape[c[k]];const N=vI(w,s.shape,s.dtype,c,x);f=e.makeTensorInfo(x,s.dtype),e.texData.get(f.dataId).values=N}else f=wb(s,c,e);u=Zn(u.length,a)}Br("max",u,a);const[p,g]=Rr(f.shape,u);let y,m=p;if(i&&(m=Jn(p,l)),h){const w=e.texData.get(f.dataId).values,x=hye(w,Z(g),m,s.dtype);y=e.makeTensorInfo(m,s.dtype),e.texData.get(y.dataId).values=x}else y=function kwe(n,t,e,r){const s=Z(t),a=Te({inputs:{x:n},attrs:{shape:[Z(n.shape)/s,s]},backend:r}),l=zu(a,n.dtype,"max",r),u=Te({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(f,g,m,e);return d&&e.disposeIntermediateTensorInfo(f),y}const Awe={kernelName:Zy,backendName:"webgl",kernelFunc:NB},Fwe=Hr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:fye}),Mwe={kernelName:Lf,backendName:"webgl",kernelFunc:Fwe},Lwe={kernelName:Yy,backendName:"webgl",kernelFunc:function Pwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Kp(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(Vr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&Pt(c.inShape,c.outShape))return Ks({inputs:{x:s},backend:e});const d=new Zp(c,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},Vwe={kernelName:Qy,backendName:"webgl",kernelFunc:function $we(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,d=ba(s.shape,o,i,[1,1,1],a,u,l),h=new CI(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class Bwe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const o=t.effectiveFilterHeight,i=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zwe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${u-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Wwe={kernelName:l2,backendName:"webgl",kernelFunc:function Uwe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=ba(i.shape,a,l,[1,1,1],u,c),f=new CI(h,"max",!0),p=e.runWebGLProgram(f,[i],i.dtype),g=new zwe(h),m=e.runWebGLProgram(g,[s,p],i.dtype);return e.disposeIntermediateTensorInfo(p),m}},jwe={kernelName:a2,backendName:"webgl",kernelFunc:function Hwe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:i}=t,a=o;Kp([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Ro(a.shape,l,u,1,c,d),p=new Zp(h,"max",!0),g=e.runWebGLProgram(p,[a],a.dtype),m=new Bwe(h),y=e.runWebGLProgram(m,[s,g],a.dtype);return e.disposeIntermediateTensorInfo(g),y}},qwe={kernelName:u2,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,l=e;_(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];_(Vr(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Ro(r.shape,s,o,u,i),[d,h]=function Gwe(n,t,e,r){let s=new Zp(e,"max",!1);const o=r.runWebGLProgram(s,[n],"float32");return s=new Zp(e,"max",!0,!0,t),[o,r.runWebGLProgram(s,[n],"float32")]}(r,a,c,l);return[d,h]}},Xwe={kernelName:e0,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:o}=t,i=e,a=r.shape.length,l=Rt(o,r.shape);let u=l;const c=Pn(u,a),d=null!=c,h=i.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const x=i.texData.get(p.dataId).values,N=new Array(a);for(let A=0;A<N.length;A++)N[A]=r.shape[c[A]];const I=vI(x,r.shape,r.dtype,c,N);p=i.makeTensorInfo(N,r.dtype),i.texData.get(p.dataId).values=I}else p=wb(r,c,i);f.push(p),u=Zn(u.length,a)}Br("sum",u,a);const[g,m]=Rr(p.shape,u);let y=g;s&&(y=Jn(g,l));const v=function Kwe(n,t,e,r){const s=Z(t),a=Te({inputs:{x:n},attrs:{shape:[Z(n.shape)/s,s]},backend:r}),l=zu(a,"float32","mean",r),u=Te({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(p,m,y,i);for(const w of f)i.disposeIntermediateTensorInfo(w);return v}},Zwe={kernelName:t0,backendName:"webgl",kernelFunc:function Jwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=Rt(o,s.shape);let u=l;const c=Pn(u,a);let d=s;null!=c&&(d=hs({inputs:{x:s},backend:e,attrs:{perm:c}}),u=Zn(u.length,s.shape.length)),Br("min",u,a);const[h,f]=Rr(d.shape,u),g=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,Z(f)]}}),m=zu(g,g.dtype,"min",e);let y;return y=Te(i?{inputs:{x:m},backend:e,attrs:{shape:Jn(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},exe=Hr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:pye}),txe={kernelName:$f,backendName:"webgl",kernelFunc:exe};class nxe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+t[d]+c[1]);const s=t.length,o=an(s),i=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class rxe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,g)=>p[0]+t[g]+p[1]);const s=t.length,o=an(s),i=e.map(p=>p[0]).join(","),a=e.map((p,g)=>p[0]+t[g]).join(","),l=ds("rc",s),u=ds("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const p=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${c}) {\n            ${p}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const sxe={kernelName:n0,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:o}=e,i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rxe(r.shape,s,o):new nxe(r.shape,s,o);return t.runWebGLProgram(i,[r],r.dtype)}},axe=Hr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),lxe={kernelName:Vf,backendName:"webgl",kernelFunc:axe};class uxe{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const TB=Hr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),cxe={kernelName:Sf,backendName:"webgl",kernelFunc:TB},IB="return a - b;",_B=Hr({opSnippet:IB,packedOpSnippet:IB,supportsComplex:!0,cpuKernelImpl:Mye}),dxe={kernelName:tp,backendName:"webgl",kernelFunc:_B};function EB(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,i=Rt([o],s.shape),a=NB({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=Jn(a.shape,i),u=Te({inputs:{x:a},backend:e,attrs:{shape:l}}),c=_B({inputs:{a:s,b:u},backend:e}),d=bB({inputs:{x:c},backend:e}),h=xb({inputs:{x:d},backend:e,attrs:{axis:i,keepDims:!1}}),f=Te({inputs:{x:h},backend:e,attrs:{shape:l}}),p=TB({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const hxe={kernelName:x0,backendName:"webgl",kernelFunc:EB},pxe={kernelName:c2,backendName:"webgl",kernelFunc:function fxe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r,l=a?s:EB({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new uxe(l.shape[0],l.shape[1],o),f=e.runWebGLProgram(d,[l],"int32",[[i]]);return a||e.disposeIntermediateTensorInfo(l),f}},bxe={kernelName:r0,backendName:"webgl",kernelFunc:function yxe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=gye(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Dl(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Gi(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(s,[r],r.dtype)}},vxe=pN,xxe={kernelName:d2,backendName:"webgl",kernelFunc:function wxe(n){lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),{selectedIndices:d}=vxe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Cxe=mN,Nxe={kernelName:h2,backendName:"webgl",kernelFunc:function Sxe(n){lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),{selectedIndices:h,validOutputs:f}=Cxe(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},Txe=gN,_xe={kernelName:f2,backendName:"webgl",kernelFunc:function Ixe(n){lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),h=i,f=a,p=l,g=u,{selectedIndices:m,selectedScores:y}=Txe(c,d,h,f,p,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class Exe{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const Dxe={kernelName:a0,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:i,onValue:a,offValue:l}=r,u=Z(s.shape),c=new Exe(u,i,a,l),d=Te({inputs:{x:s},backend:e,attrs:{shape:[u]}}),h=e.runWebGLProgram(c,[d],o);e.disposeIntermediateTensorInfo(d);const p=Te({inputs:{x:h},backend:e,attrs:{shape:[...s.shape,i]}});return e.disposeIntermediateTensorInfo(h),p}};function _b(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=Yp({inputs:{input:r},backend:e}),o=_b({inputs:{x:s},backend:e}),i=Tb({inputs:{input:r},backend:e}),a=_b({inputs:{x:i},backend:e}),l=kl({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return em({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const kxe={kernelName:T0,backendName:"webgl",kernelFunc:_b},Axe={kernelName:o0,backendName:"webgl",kernelFunc:function DB(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=Yp({inputs:{input:r},backend:e}),o=DB({inputs:{x:s},backend:e}),i=Tb({inputs:{input:r},backend:e}),a=_b({inputs:{x:i},backend:e}),l=kl({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return em({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},Oxe={kernelName:l0,backendName:"webgl",kernelFunc:function Rxe(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return TI({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(c=>{Bs(o,c.shape,"All tensors passed to stack must have matching shapes"),_(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=aB({inputs:t.map(c=>{const d=TI({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class Fxe{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);const s=t.length,o=an(s),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Mxe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+t[m]+g[1]);const s=t.length,o=an(s),i=e.map(g=>g[0]).join(","),a=e.map((g,m)=>g[0]+t[m]).join(","),l=ds("rc",s),u=ds("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${c}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${c}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let g=0,m=1===s?2:4;g<m;g++)p+=`\n        ${h[g]}\n        if (${f}) {\n          result[${g}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${g}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const kB=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:i}=r;if(0===Z(s.shape))return em({backend:e,attrs:{shape:o.map((c,d)=>c[0]+s.shape[d]+c[1]),value:i,dtype:s.dtype}});const a=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mxe(s.shape,o,i):new Fxe(s.shape,o,i);return e.runWebGLProgram(a,[s],s.dtype,[[i]])},Pxe={kernelName:u0,backendName:"webgl",kernelFunc:kB},Vxe=Hr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),Bxe={kernelName:zf,backendName:"webgl",kernelFunc:Vxe},Uxe={kernelName:d0,backendName:"webgl",kernelFunc:function zxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],u=Rt(o,s.shape);let c=u;const d=Pn(c,a);let f,h=s;if(null!=d&&(h=hs({inputs:{x:s},backend:e,attrs:{perm:d}}),c=Zn(c.length,a),l.push(h)),Br("prod",c,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:g,outShape:m,outDtype:y}=bye(h.shape,h.dtype,p,c);f=e.makeTensorInfo(m,y,g)}else{const[p,g]=Rr(h.shape,c),m=Z(g),y=Te({inputs:{x:h},backend:e,attrs:{shape:[-1,m]}}),w=zu(y,H2(s.dtype),"prod",e);f=Te({inputs:{x:w},backend:e,attrs:{shape:p}}),l.push(y),l.push(w)}if(i){l.push(f);const p=Jn(f.shape,u);f=Te({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},Hxe={kernelName:p2,backendName:"webgl",kernelFunc:function Wxe(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=t,{outputRaggedRank:a}=r,l=s.map(y=>e.readSync(y.dataId)),u=s.map(y=>y.shape),c=e.readSync(o.dataId),d=e.readSync(i.dataId),[h,f,p]=vye(l,u,c,o.shape,o.dtype,d,i.shape,a),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(p,o.dtype,f);return g.concat([m])}},Gxe={kernelName:m2,backendName:"webgl",kernelFunc:function jxe(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=wye(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}},Kxe={kernelName:g2,backendName:"webgl",kernelFunc:function qxe(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),d=e.readSync(i.dataId),h=a.map(m=>e.readSync(m.dataId)),f=a.map(m=>m.shape),[p,g]=xye(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,f,l);return e.makeTensorInfo(p,o.dtype,g)}},AB=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:o,dtype:i}=e,a=Cye(r,s,o,i);return t.makeTensorInfo([a.length],i,a)},Xxe={kernelName:y2,backendName:"webgl",kernelFunc:AB},Jxe=Wt({opSnippet:"return 1.0 / x;"}),Zxe={kernelName:Uf,backendName:"webgl",kernelFunc:Jxe},Qxe=Wt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),eCe={kernelName:Wf,backendName:"webgl",kernelFunc:Qxe},nCe=Wt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),rCe={kernelName:Hf,backendName:"webgl",kernelFunc:nCe};class sCe{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class oCe{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const aCe={kernelName:p0,backendName:"webgl",kernelFunc:function iCe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new oCe(s.shape,l,u,o,i):new sCe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],"float32")}};class lCe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=t,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const cCe={kernelName:w2,backendName:"webgl",kernelFunc:function uCe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r,a=new lCe(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class dCe{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class hCe{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const pCe={kernelName:f0,backendName:"webgl",kernelFunc:function fCe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new hCe(s.shape,l,u,o,i):new dCe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],s.dtype)}};class mCe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=t,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const yCe={kernelName:v2,backendName:"webgl",kernelFunc:function gCe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r,a=new mCe(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class bCe{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const o=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=an(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class vCe{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=ds("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=an(r);function h(p){const g=t.map((v,w)=>function f(p,g){return-1!==e.indexOf(p)&&1!==t[p]?`${t[p]} - ${g[p]} - 1`:`${g[p]}`}(w,p));return`getChannel(getX(${g.join(",")}), vec2(${g.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${o}){\n            result.g = ${function u(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function c(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const xCe={kernelName:m0,backendName:"webgl",kernelFunc:function wCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r,i=s.shape.length,a=Rt(o,s.shape);if(0===i)return Ks({inputs:{x:s},backend:e});const l=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vCe(s.shape,a):new bCe(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class CCe{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const SCe={kernelName:$2,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=t,a=e,l=new CCe(r.shape,o),[u,c]=SN(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},NCe=Wt({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),TCe={kernelName:jf,backendName:"webgl",kernelFunc:NCe},ICe=Wt({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Sye}),_Ce={kernelName:Gf,backendName:"webgl",kernelFunc:ICe};class _I{constructor(t,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=an(o.length),c=an(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let f="";1===s?f="i":2===s&&(f="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${f});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, float(found)));\n        }\n      `}}class ECe{constructor(t,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=an(o.length),c=an(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let f="";1===s?f="i":2===s&&(f="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${d}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${f});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, found));\n        }\n      `}}const kCe={kernelName:x2,backendName:"webgl",kernelFunc:function DCe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Tu(0,s,i),h=[d/u,u];if(0===d)return e.makeTensorInfo(i,s.dtype);const f=Te({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),p=Te({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=G().getBool("WEBGL_PACK")?new ECe(l,a,f.shape.length,p.shape.length,c,h):new _I(l,a,f.shape.length,p.shape.length,c,h);const y=e.runWebGLProgram(m,[p,f,g],p.dtype),v=Te({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),v}};class ACe{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===G().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const OCe={kernelName:S2,backendName:"webgl",kernelFunc:function RCe(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:i}=r,a=new ACe(s.shape[0],s.shape[1],o.shape[1],i);return e.runWebGLProgram(a,[s,o],"int32",[[s.shape[1]]])}};class FCe{constructor(t,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<t&&l.push(`${a[c]}`);s=l.join(),o=u.join()}const i=an(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const PCe={kernelName:g0,backendName:"webgl",kernelFunc:function MCe(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t,i=new FCe(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],zs(s.dtype,o.dtype))}},$Ce=Wt({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${y1};\n  float scale = ${b1};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),VCe={kernelName:qf,backendName:"webgl",kernelFunc:$Ce},zCe=Wt({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Tye}),UCe={kernelName:Zf,backendName:"webgl",kernelFunc:zCe},WCe=Wt({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),HCe={kernelName:Jf,backendName:"webgl",kernelFunc:WCe},qCe=Wt({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Bu}\n  return result;\n`}),KCe={kernelName:Kf,backendName:"webgl",kernelFunc:qCe},XCe=Wt({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),JCe={kernelName:Xf,backendName:"webgl",kernelFunc:XCe},ZCe=Wt({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),YCe={kernelName:Yf,backendName:"webgl",kernelFunc:ZCe},QCe={kernelName:v0,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:i}=r;_(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,v)=>y*v),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=kB({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Tp(c.shape,o,a,!1),h=Ip(d.length,o.length,!1),f=_p(c.shape,o,a,!1),p=Te({inputs:{x:c},backend:e,attrs:{shape:d}}),g=hs({inputs:{x:p},backend:e,attrs:{perm:h}}),m=Te({inputs:{x:g},backend:e,attrs:{shape:f}});return u.push(c),u.push(p),u.push(g),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},t2e={kernelName:N2,backendName:"webgl",kernelFunc:function e2e(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=e.readSync(i.dataId)[0],[d,h,f,p,g]=_ye(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}},r2e={kernelName:T2,backendName:"webgl",kernelFunc:function n2e(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(o.dataId)),[u,c,d]=Eye(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},o2e={kernelName:I2,backendName:"webgl",kernelFunc:function s2e(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=PV(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},a2e={kernelName:_2,backendName:"webgl",kernelFunc:function i2e(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=PV(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},u2e={kernelName:E2,backendName:"webgl",kernelFunc:function l2e(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Tu(0,s,a);if("string"===o.dtype){const y=e.bufferSync(s),v=e.bufferSync(o),w=sl(e.readSync(i.dataId)[0]),x=Nye(y,v,a,h,c,u,l,d,w,!1);return e.makeTensorInfo(a,x.dtype,x.values)}const p=new _I(u,l,s.shape.length,o.shape.length,d,[h,1],!1),g=e.runWebGLProgram(p,[o,s,i],o.dtype),m=Te({inputs:{x:g},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),m}},d2e={kernelName:w0,backendName:"webgl",kernelFunc:function c2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=Rt(i,s.shape)[0],l=BN(s,o,a),c=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=$d({inputs:{x:s},backend:e,attrs:{begin:c,size:f}});return c[a]+=h,p})}},RB="return sqrt(x);",h2e=Wt({opSnippet:RB,packedOpSnippet:RB,cpuKernelImpl:Dye}),f2e={kernelName:Qf,backendName:"webgl",kernelFunc:h2e},m2e={kernelName:D2,backendName:"webgl",kernelFunc:Wt({opSnippet:"return x * x;"})},OB="return (a - b) * (a - b);",g2e=Hr({opSnippet:OB,packedOpSnippet:OB}),y2e={kernelName:ep,backendName:"webgl",kernelFunc:g2e},v2e={kernelName:C0,backendName:"webgl",kernelFunc:function b2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const i=Ca(e.readSync(s.dataId)),a=kye(i,"string",r);return e.makeTensorInfo(s.shape,"string",a)}},x2e={kernelName:op,backendName:"webgl",kernelFunc:function w2e({inputs:n,attrs:t,backend:e}){const{x:r}=n,o=new Gi(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class C2e{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=an(r.length),i=an(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,1===r.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const N2e={kernelName:k2,backendName:"webgl",kernelFunc:function S2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:v,end:w,strides:x}=ES(s.shape,o,i,a,l,u,c,d,h);let N;if(g)N=Te({inputs:{x:s},backend:e,attrs:{shape:p}});else if(m||y){_(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=TS(v,w,x),A=$d({inputs:{x:s},backend:e,attrs:{begin:v,size:k}});N=Te({inputs:{x:A},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(A)}else if(e.shouldExecuteOnCPU([s])){const A=e.readSync(s.dataId),R=Tt(s.shape,s.dtype,A),F=Aye(f,R,x,v);N=e.makeTensorInfo(p,s.dtype,F.values)}else{const A=new C2e(v,x,f);N=e.runWebGLProgram(A,[s],s.dtype)}const I=Te({inputs:{x:N},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(N),I}},I2e={kernelName:A2,backendName:"webgl",kernelFunc:function T2e(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=e.readSync(c.dataId),f=e.readSync(d.dataId),[p,g]=Rye(h,f,s,o,i,a,l,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",g)]}},E2e={kernelName:R2,backendName:"webgl",kernelFunc:function _2e(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.readSync(o.dataId),l=e.readSync(i.dataId)[0],[u,c,d]=Oye(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},k2e={kernelName:O2,backendName:"webgl",kernelFunc:function D2e(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=e.readSync(o.dataId),a=Fye(i,s);return e.makeTensorInfo(o.shape,"int32",a)}},A2e=Wt({opSnippet:"return tan(x);"}),R2e={kernelName:np,backendName:"webgl",kernelFunc:A2e},O2e=Wt({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),F2e={kernelName:rp,backendName:"webgl",kernelFunc:O2e},P2e={kernelName:C2,backendName:"webgl",kernelFunc:function M2e(n){const{inputs:t,backend:e}=n,{tensor:s,indices:o,updates:i}=t,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Tu(0,o,s.shape),h=[d/u,u];if(0===d)return e.makeTensorInfo(s.shape,o.dtype);const f=Te({inputs:{x:o},backend:e,attrs:{shape:[l,a]}}),p=Te({inputs:{x:i},backend:e,attrs:{shape:[l,u]}}),g=Te({inputs:{x:s},backend:e,attrs:{shape:h}}),m=new _I(l,a,f.shape.length,p.shape.length,c,h,!1,!0),y=e.runWebGLProgram(m,[p,f,g],g.dtype),v=Te({inputs:{x:y},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),v}};class L2e{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*e[i];this.outputShape=r,this.rank=r.length;const s=an(this.rank),o=function $2e(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function FB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),u="string"===s.dtype?l.map(h=>sl(h)):l,c=Tt(s.shape,s.dtype,u),d=Pye(c,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new L2e(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const V2e={kernelName:sp,backendName:"webgl",kernelFunc:FB};class B2e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class z2e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Uu(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function MB(n){let t=1;for(;t<n;)t*=2;return t}const W2e={kernelName:F2,backendName:"webgl",kernelFunc:function U2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:i}=r,a=G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([s])||c<a||o>l){const F=e.readSync(s.dataId),[U,q]=Lye(F,u,s.dtype,o,i);return[e.makeTensorInfo(U.shape,U.dtype,U.values),e.makeTensorInfo(q.shape,q.dtype,q.values)]}if(0===o)return u[u.length-1]=0,[e.makeTensorInfo(u,s.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(1===c)return[s,em({attrs:{shape:u,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,f=h?e.unpackTensor(s):s,g=Z(u)/c,m=Te({inputs:{x:f},attrs:{shape:[g,c]},backend:e});h&&Uu(e,f);const y=MB(o),v=MB(c);let w=null;const x=()=>null===w?[m,m]:[m,w],N=(F,U,q)=>{const K=x(),Y=new B2e(q),ie=w;w=e.runWebGLProgram(Y,K,"int32",[[c],[null===w?1:0],[Number.NEGATIVE_INFINITY],[F],[U]]),Uu(e,ie)};for(let F=1;F<y;F*=2){const U=2*F;for(let q=F;q>=1;q/=2)N(U,q,[g,v])}for(let F=v;F>y;F/=2){const U=x(),q=new z2e([g,F/2]),Q=w;w=e.runWebGLProgram(q,U,"int32",[[c],[null===w?1:0],[y]]),Uu(e,Q);const se=y/2,ie=2*se;for(let te=se;te>=1;te/=2)N(ie,te,w.shape)}let I=w;w=$d({inputs:{x:w},backend:e,attrs:{begin:0,size:[g,o]}}),Uu(e,I);let k=SB({inputs:{x:m,indices:w},backend:e,attrs:{axis:1,batchDims:1}});Uu(e,m);const A=u.slice(0,-1);A.push(o),I=w,w=Te({inputs:{x:w},attrs:{shape:A},backend:e}),Uu(e,I);const R=k;return k=Te({inputs:{x:k},attrs:{shape:A},backend:e}),Uu(e,R),[k,w]}};class H2e{constructor(t,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const G2e={kernelName:M2,backendName:"webgl",kernelFunc:function j2e(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,h,f]=s.shape,[p,g]=u??[d,h],y=new H2e(d,h,i,a,l,[c,p,g,f]);return e.runWebGLProgram(y,[s,o],"float32")}},K2e={kernelName:P2,backendName:"webgl",kernelFunc:function q2e(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;Kp(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=$ye(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},J2e={kernelName:S0,backendName:"webgl",kernelFunc:function X2e(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(u[c++]=i.shape[g]);const d=[],h=new Array(a).fill(0),f=i.shape.slice();f[o]=1;const p=new Array(l);for(let g=0;g<p.length;g++){h[o]=g;const m=$d({inputs:{x:i},backend:e,attrs:{begin:h,size:f}}),y=Te({inputs:{x:m},backend:e,attrs:{shape:u}});p[g]=y,d.push(m)}return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}};class Z2e{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,o=t.inSize,i=t.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const eSe=[R0e,F0e,L0e,B0e,U0e,j0e,q0e,X0e,Q0e,t1e,s1e,a1e,c1e,p1e,y1e,v1e,x1e,T1e,_1e,D1e,R1e,$1e,B1e,H1e,G1e,Z1e,Q1e,rbe,m0e,ibe,dbe,mbe,xbe,Nbe,Ibe,Ebe,kbe,Fbe,Pbe,$be,Bbe,Ube,Hbe,qbe,Xbe,Qbe,tve,sve,ave,uve,dve,pve,gve,vve,xve,Cve,Nve,Ive,Eve,kve,Rve,Fve,Lve,Bve,Uve,jve,Kve,Jve,Yve,p0e,ewe,ube,nwe,swe,iwe,y0e,lwe,cwe,hwe,mwe,bwe,wwe,Cwe,Nwe,_we,Dwe,Awe,Mwe,Lwe,Vwe,Wwe,jwe,qwe,Xwe,Zwe,txe,sxe,lxe,pxe,w0e,bxe,xxe,Nxe,_xe,q1e,Dxe,Axe,Oxe,Pxe,Bxe,v0e,Uxe,Hxe,Gxe,Kxe,Xxe,K1e,cxe,Zxe,eCe,rCe,C0e,aCe,cCe,pCe,yCe,xCe,SCe,TCe,_Ce,kCe,OCe,PCe,VCe,UCe,HCe,KCe,JCe,L1e,hxe,YCe,QCe,t2e,r2e,o2e,a2e,u2e,d2e,f2e,m2e,y2e,v2e,x2e,N2e,I2e,E2e,k2e,dxe,D0e,R2e,F2e,P2e,V2e,W2e,G2e,k0e,K2e,J2e,{kernelName:N0,backendName:"webgl",kernelFunc:function Y2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:i}=r,a=s.shape.length,l=[];let u=0;const c=Pn([u],a);let d=s;null!=c&&(d=hs({inputs:{x:s},backend:e,attrs:{perm:c}}),l.push(d),u=Zn(1,a)[0]);const h=oP(d.shape,u,i),f=Z([d.shape[u]]),p=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const g=H2(s.dtype),m=(x,N,I,k,A)=>{const R=x.shape[0],F=x.shape[1],U=sP(F,A),K=new Z2e({windowSize:U,inSize:F,batchSize:R,numSegments:A},N),Y=e.compileAndRun(K,[x,I],k);if(l.push(Y),Y.shape[1]===A)return Y;const Q=AB({backend:e,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),se=FB({inputs:{x:Q},backend:e,attrs:{reps:[F/U]}});return l.push(Q),l.push(se),m(Y,N,se,k,A)},v=Te({inputs:{x:m(p,"unsortedSegmentSum",o,g,i)},backend:e,attrs:{shape:h}});let w=v;if(null!=c){l.push(v);const x=pl(c);w=hs({inputs:{x:w},backend:e,attrs:{perm:x}})}return l.forEach(x=>e.disposeIntermediateTensorInfo(x)),w}},kxe];for(const n of eSe)B2(n);var Wu=(()=>{return(n=Wu||(Wu={})).FACE_RECOGNITION="FACE_RECOGNITION",n.HELMET_AND_VEST_DETECTION="HELMET_AND_VEST_DETECTION",Wu;var n})();function PB(n){return Os((t,e)=>{Zs(n).subscribe(ps(e,()=>e.complete(),xi)),!e.closed&&t.subscribe(e)})}function Eb(n,t){return Os((e,r)=>{let s=0;e.subscribe(ps(r,o=>n.call(t,o,s++)&&r.next(o)))})}function EI(n){return n<=0?()=>ih:Os((t,e)=>{let r=0;t.subscribe(ps(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}const qi=Object.create(null);qi.open="0",qi.close="1",qi.ping="2",qi.pong="3",qi.message="4",qi.upgrade="5",qi.noop="6";const Db=Object.create(null);Object.keys(qi).forEach(n=>{Db[qi[n]]=n});const DI={type:"error",data:"parser error"},LB="function"==typeof Blob||typeof Blob<"u"&&"[object BlobConstructor]"===Object.prototype.toString.call(Blob),$B="function"==typeof ArrayBuffer,VB=n=>"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(n):n&&n.buffer instanceof ArrayBuffer,kI=({type:n,data:t},e,r)=>LB&&t instanceof Blob?e?r(t):BB(t,r):$B&&(t instanceof ArrayBuffer||VB(t))?e?r(t):BB(new Blob([t]),r):r(qi[n]+(t||"")),BB=(n,t)=>{const e=new FileReader;return e.onload=function(){const r=e.result.split(",")[1];t("b"+(r||""))},e.readAsDataURL(n)};function zB(n){return n instanceof Uint8Array?n:n instanceof ArrayBuffer?new Uint8Array(n):new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}let AI;const zd="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",tm=typeof Uint8Array>"u"?[]:new Uint8Array(256);for(let n=0;n<zd.length;n++)tm[zd.charCodeAt(n)]=n;const sSe="function"==typeof ArrayBuffer,RI=(n,t)=>{if("string"!=typeof n)return{type:"message",data:UB(n,t)};const e=n.charAt(0);return"b"===e?{type:"message",data:oSe(n.substring(1),t)}:Db[e]?n.length>1?{type:Db[e],data:n.substring(1)}:{type:Db[e]}:DI},oSe=(n,t)=>{if(sSe){const e=(n=>{let r,o,i,a,l,t=.75*n.length,e=n.length,s=0;"="===n[n.length-1]&&(t--,"="===n[n.length-2]&&t--);const u=new ArrayBuffer(t),c=new Uint8Array(u);for(r=0;r<e;r+=4)o=tm[n.charCodeAt(r)],i=tm[n.charCodeAt(r+1)],a=tm[n.charCodeAt(r+2)],l=tm[n.charCodeAt(r+3)],c[s++]=o<<2|i>>4,c[s++]=(15&i)<<4|a>>2,c[s++]=(3&a)<<6|63&l;return u})(n);return UB(e,t)}return{base64:!0,data:n}},UB=(n,t)=>"blob"===t?n instanceof Blob?n:new Blob([n]):n instanceof ArrayBuffer?n:n.buffer,WB=String.fromCharCode(30);let OI;function kb(n){return n.reduce((t,e)=>t+e.length,0)}function Ab(n,t){if(n[0].length===t)return n.shift();const e=new Uint8Array(t);let r=0;for(let s=0;s<t;s++)e[s]=n[0][r++],r===n[0].length&&(n.shift(),r=0);return n.length&&r<n[0].length&&(n[0]=n[0].slice(r)),e}function wr(n){if(n)return function cSe(n){for(var t in wr.prototype)n[t]=wr.prototype[t];return n}(n)}wr.prototype.on=wr.prototype.addEventListener=function(n,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+n]=this._callbacks["$"+n]||[]).push(t),this},wr.prototype.once=function(n,t){function e(){this.off(n,e),t.apply(this,arguments)}return e.fn=t,this.on(n,e),this},wr.prototype.off=wr.prototype.removeListener=wr.prototype.removeAllListeners=wr.prototype.removeEventListener=function(n,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var e=this._callbacks["$"+n];if(!e)return this;if(1==arguments.length)return delete this._callbacks["$"+n],this;for(var r,s=0;s<e.length;s++)if((r=e[s])===t||r.fn===t){e.splice(s,1);break}return 0===e.length&&delete this._callbacks["$"+n],this},wr.prototype.emitReserved=wr.prototype.emit=function(n){this._callbacks=this._callbacks||{};for(var t=new Array(arguments.length-1),e=this._callbacks["$"+n],r=1;r<arguments.length;r++)t[r-1]=arguments[r];if(e){r=0;for(var s=(e=e.slice(0)).length;r<s;++r)e[r].apply(this,t)}return this},wr.prototype.listeners=function(n){return this._callbacks=this._callbacks||{},this._callbacks["$"+n]||[]},wr.prototype.hasListeners=function(n){return!!this.listeners(n).length};const Rb="function"==typeof Promise&&"function"==typeof Promise.resolve?t=>Promise.resolve().then(t):(t,e)=>e(t,0),Ho=typeof self<"u"?self:typeof window<"u"?window:Function("return this")();function jB(n,...t){return t.reduce((e,r)=>(n.hasOwnProperty(r)&&(e[r]=n[r]),e),{})}const hSe=Ho.setTimeout,fSe=Ho.clearTimeout;function Ob(n,t){t.useNativeTimers?(n.setTimeoutFn=hSe.bind(Ho),n.clearTimeoutFn=fSe.bind(Ho)):(n.setTimeoutFn=Ho.setTimeout.bind(Ho),n.clearTimeoutFn=Ho.clearTimeout.bind(Ho))}function mSe(n){return"string"==typeof n?function gSe(n){let t=0,e=0;for(let r=0,s=n.length;r<s;r++)t=n.charCodeAt(r),t<128?e+=1:t<2048?e+=2:t<55296||t>=57344?e+=3:(r++,e+=4);return e}(n):Math.ceil(1.33*(n.byteLength||n.size))}function GB(){return Date.now().toString(36).substring(3)+Math.random().toString(36).substring(2,5)}class vSe extends Error{constructor(t,e,r){super(t),this.description=e,this.context=r,this.type="TransportError"}}class FI extends wr{constructor(t){super(),this.writable=!1,Ob(this,t),this.opts=t,this.query=t.query,this.socket=t.socket,this.supportsBinary=!t.forceBase64}onError(t,e,r){return super.emitReserved("error",new vSe(t,e,r)),this}open(){return this.readyState="opening",this.doOpen(),this}close(){return("opening"===this.readyState||"open"===this.readyState)&&(this.doClose(),this.onClose()),this}send(t){"open"===this.readyState&&this.write(t)}onOpen(){this.readyState="open",this.writable=!0,super.emitReserved("open")}onData(t){const e=RI(t,this.socket.binaryType);this.onPacket(e)}onPacket(t){super.emitReserved("packet",t)}onClose(t){this.readyState="closed",super.emitReserved("close",t)}pause(t){}createUri(t,e={}){return t+"://"+this._hostname()+this._port()+this.opts.path+this._query(e)}_hostname(){const t=this.opts.hostname;return-1===t.indexOf(":")?t:"["+t+"]"}_port(){return this.opts.port&&(this.opts.secure&&Number(443!==this.opts.port)||!this.opts.secure&&80!==Number(this.opts.port))?":"+this.opts.port:""}_query(t){const e=function ySe(n){let t="";for(let e in n)n.hasOwnProperty(e)&&(t.length&&(t+="&"),t+=encodeURIComponent(e)+"="+encodeURIComponent(n[e]));return t}(t);return e.length?"?"+e:""}}class wSe extends FI{constructor(){super(...arguments),this._polling=!1}get name(){return"polling"}doOpen(){this._poll()}pause(t){this.readyState="pausing";const e=()=>{this.readyState="paused",t()};if(this._polling||!this.writable){let r=0;this._polling&&(r++,this.once("pollComplete",function(){--r||e()})),this.writable||(r++,this.once("drain",function(){--r||e()}))}else e()}_poll(){this._polling=!0,this.doPoll(),this.emitReserved("poll")}onData(t){((n,t)=>{const e=n.split(WB),r=[];for(let s=0;s<e.length;s++){const o=RI(e[s],t);if(r.push(o),"error"===o.type)break}return r})(t,this.socket.binaryType).forEach(r=>{if("opening"===this.readyState&&"open"===r.type&&this.onOpen(),"close"===r.type)return this.onClose({description:"transport closed by the server"}),!1;this.onPacket(r)}),"closed"!==this.readyState&&(this._polling=!1,this.emitReserved("pollComplete"),"open"===this.readyState&&this._poll())}doClose(){const t=()=>{this.write([{type:"close"}])};"open"===this.readyState?t():this.once("open",t)}write(t){this.writable=!1,((n,t)=>{const e=n.length,r=new Array(e);let s=0;n.forEach((o,i)=>{kI(o,!1,a=>{r[i]=a,++s===e&&t(r.join(WB))})})})(t,e=>{this.doWrite(e,()=>{this.writable=!0,this.emitReserved("drain")})})}uri(){const t=this.opts.secure?"https":"http",e=this.query||{};return!1!==this.opts.timestampRequests&&(e[this.opts.timestampParam]=GB()),!this.supportsBinary&&!e.sid&&(e.b64=1),this.createUri(t,e)}}let qB=!1;try{qB=typeof XMLHttpRequest<"u"&&"withCredentials"in new XMLHttpRequest}catch{}const xSe=qB;function CSe(){}class SSe extends wSe{constructor(t){if(super(t),typeof location<"u"){const e="https:"===location.protocol;let r=location.port;r||(r=e?"443":"80"),this.xd=typeof location<"u"&&t.hostname!==location.hostname||r!==t.port}}doWrite(t,e){const r=this.request({method:"POST",data:t});r.on("success",e),r.on("error",(s,o)=>{this.onError("xhr post error",s,o)})}doPoll(){const t=this.request();t.on("data",this.onData.bind(this)),t.on("error",(e,r)=>{this.onError("xhr poll error",e,r)}),this.pollXhr=t}}let Fb=(()=>{class n extends wr{constructor(e,r,s){super(),this.createRequest=e,Ob(this,s),this._opts=s,this._method=s.method||"GET",this._uri=r,this._data=void 0!==s.data?s.data:null,this._create()}_create(){var e;const r=jB(this._opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");r.xdomain=!!this._opts.xd;const s=this._xhr=this.createRequest(r);try{s.open(this._method,this._uri,!0);try{if(this._opts.extraHeaders){s.setDisableHeaderCheck&&s.setDisableHeaderCheck(!0);for(let o in this._opts.extraHeaders)this._opts.extraHeaders.hasOwnProperty(o)&&s.setRequestHeader(o,this._opts.extraHeaders[o])}}catch{}if("POST"===this._method)try{s.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch{}try{s.setRequestHeader("Accept","*/*")}catch{}null===(e=this._opts.cookieJar)||void 0===e||e.addCookies(s),"withCredentials"in s&&(s.withCredentials=this._opts.withCredentials),this._opts.requestTimeout&&(s.timeout=this._opts.requestTimeout),s.onreadystatechange=()=>{var o;3===s.readyState&&(null===(o=this._opts.cookieJar)||void 0===o||o.parseCookies(s.getResponseHeader("set-cookie"))),4===s.readyState&&(200===s.status||1223===s.status?this._onLoad():this.setTimeoutFn(()=>{this._onError("number"==typeof s.status?s.status:0)},0))},s.send(this._data)}catch(o){return void this.setTimeoutFn(()=>{this._onError(o)},0)}typeof document<"u"&&(this._index=n.requestsCount++,n.requests[this._index]=this)}_onError(e){this.emitReserved("error",e,this._xhr),this._cleanup(!0)}_cleanup(e){if(!(typeof this._xhr>"u"||null===this._xhr)){if(this._xhr.onreadystatechange=CSe,e)try{this._xhr.abort()}catch{}typeof document<"u"&&delete n.requests[this._index],this._xhr=null}}_onLoad(){const e=this._xhr.responseText;null!==e&&(this.emitReserved("data",e),this.emitReserved("success"),this._cleanup())}abort(){this._cleanup()}}return n.requestsCount=0,n.requests={},n})();function KB(){for(let n in Fb.requests)Fb.requests.hasOwnProperty(n)&&Fb.requests[n].abort()}typeof document<"u"&&("function"==typeof attachEvent?attachEvent("onunload",KB):"function"==typeof addEventListener&&addEventListener("onpagehide"in Ho?"pagehide":"unload",KB,!1));const NSe=function(){const n=XB({xdomain:!1});return n&&null!==n.responseType}();function XB(n){const t=n.xdomain;try{if(typeof XMLHttpRequest<"u"&&(!t||xSe))return new XMLHttpRequest}catch{}if(!t)try{return new(Ho[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch{}}const JB=typeof navigator<"u"&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase();class ISe extends FI{get name(){return"websocket"}doOpen(){const t=this.uri(),e=this.opts.protocols,r=JB?{}:jB(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(r.headers=this.opts.extraHeaders);try{this.ws=this.createSocket(t,e,r)}catch(s){return this.emitReserved("error",s)}this.ws.binaryType=this.socket.binaryType,this.addEventListeners()}addEventListeners(){this.ws.onopen=()=>{this.opts.autoUnref&&this.ws._socket.unref(),this.onOpen()},this.ws.onclose=t=>this.onClose({description:"websocket connection closed",context:t}),this.ws.onmessage=t=>this.onData(t.data),this.ws.onerror=t=>this.onError("websocket error",t)}write(t){this.writable=!1;for(let e=0;e<t.length;e++){const r=t[e],s=e===t.length-1;kI(r,this.supportsBinary,o=>{try{this.doWrite(r,o)}catch{}s&&Rb(()=>{this.writable=!0,this.emitReserved("drain")},this.setTimeoutFn)})}}doClose(){typeof this.ws<"u"&&(this.ws.onerror=()=>{},this.ws.close(),this.ws=null)}uri(){const t=this.opts.secure?"wss":"ws",e=this.query||{};return this.opts.timestampRequests&&(e[this.opts.timestampParam]=GB()),this.supportsBinary||(e.b64=1),this.createUri(t,e)}}const MI=Ho.WebSocket||Ho.MozWebSocket,DSe={websocket:class _Se extends ISe{createSocket(t,e,r){return JB?new MI(t,e,r):e?new MI(t,e):new MI(t)}doWrite(t,e){this.ws.send(e)}},webtransport:class ESe extends FI{get name(){return"webtransport"}doOpen(){try{this._transport=new WebTransport(this.createUri("https"),this.opts.transportOptions[this.name])}catch(t){return this.emitReserved("error",t)}this._transport.closed.then(()=>{this.onClose()}).catch(t=>{this.onError("webtransport error",t)}),this._transport.ready.then(()=>{this._transport.createBidirectionalStream().then(t=>{const e=function uSe(n,t){OI||(OI=new TextDecoder);const e=[];let r=0,s=-1,o=!1;return new TransformStream({transform(i,a){for(e.push(i);;){if(0===r){if(kb(e)<1)break;const l=Ab(e,1);o=128==(128&l[0]),s=127&l[0],r=s<126?3:126===s?1:2}else if(1===r){if(kb(e)<2)break;const l=Ab(e,2);s=new DataView(l.buffer,l.byteOffset,l.length).getUint16(0),r=3}else if(2===r){if(kb(e)<8)break;const l=Ab(e,8),u=new DataView(l.buffer,l.byteOffset,l.length),c=u.getUint32(0);if(c>Math.pow(2,21)-1){a.enqueue(DI);break}s=c*Math.pow(2,32)+u.getUint32(4),r=3}else{if(kb(e)<s)break;const l=Ab(e,s);a.enqueue(RI(o?l:OI.decode(l),t)),r=0}if(0===s||s>n){a.enqueue(DI);break}}}})}(Number.MAX_SAFE_INTEGER,this.socket.binaryType),r=t.readable.pipeThrough(e).getReader(),s=function lSe(){return new TransformStream({transform(n,t){!function nSe(n,t){LB&&n.data instanceof Blob?n.data.arrayBuffer().then(zB).then(t):$B&&(n.data instanceof ArrayBuffer||VB(n.data))?t(zB(n.data)):kI(n,!1,e=>{AI||(AI=new TextEncoder),t(AI.encode(e))})}(n,e=>{const r=e.length;let s;if(r<126)s=new Uint8Array(1),new DataView(s.buffer).setUint8(0,r);else if(r<65536){s=new Uint8Array(3);const o=new DataView(s.buffer);o.setUint8(0,126),o.setUint16(1,r)}else{s=new Uint8Array(9);const o=new DataView(s.buffer);o.setUint8(0,127),o.setBigUint64(1,BigInt(r))}n.data&&"string"!=typeof n.data&&(s[0]|=128),t.enqueue(s),t.enqueue(e)})}})}();s.readable.pipeTo(t.writable),this._writer=s.writable.getWriter();const o=()=>{r.read().then(({done:a,value:l})=>{a||(this.onPacket(l),o())}).catch(a=>{})};o();const i={type:"open"};this.query.sid&&(i.data=`{"sid":"${this.query.sid}"}`),this._writer.write(i).then(()=>this.onOpen())})})}write(t){this.writable=!1;for(let e=0;e<t.length;e++){const s=e===t.length-1;this._writer.write(t[e]).then(()=>{s&&Rb(()=>{this.writable=!0,this.emitReserved("drain")},this.setTimeoutFn)})}}doClose(){var t;null===(t=this._transport)||void 0===t||t.close()}},polling:class TSe extends SSe{constructor(t){super(t),this.supportsBinary=NSe&&!(t&&t.forceBase64)}request(t={}){return Object.assign(t,{xd:this.xd},this.opts),new Fb(XB,this.uri(),t)}}},kSe=/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,ASe=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];function PI(n){if(n.length>8e3)throw"URI too long";const t=n,e=n.indexOf("["),r=n.indexOf("]");-1!=e&&-1!=r&&(n=n.substring(0,e)+n.substring(e,r).replace(/:/g,";")+n.substring(r,n.length));let s=kSe.exec(n||""),o={},i=14;for(;i--;)o[ASe[i]]=s[i]||"";return-1!=e&&-1!=r&&(o.source=t,o.host=o.host.substring(1,o.host.length-1).replace(/;/g,":"),o.authority=o.authority.replace("[","").replace("]","").replace(/;/g,":"),o.ipv6uri=!0),o.pathNames=function RSe(n,t){const r=t.replace(/\/{2,9}/g,"/").split("/");return("/"==t.slice(0,1)||0===t.length)&&r.splice(0,1),"/"==t.slice(-1)&&r.splice(r.length-1,1),r}(0,o.path),o.queryKey=function OSe(n,t){const e={};return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,function(r,s,o){s&&(e[s]=o)}),e}(0,o.query),o}const LI="function"==typeof addEventListener&&"function"==typeof removeEventListener,Mb=[];LI&&addEventListener("offline",()=>{Mb.forEach(n=>n())},!1);let $I=(()=>{class n extends wr{constructor(e,r){if(super(),this.binaryType="arraybuffer",this.writeBuffer=[],this._prevBufferLen=0,this._pingInterval=-1,this._pingTimeout=-1,this._maxPayload=-1,this._pingTimeoutTime=1/0,e&&"object"==typeof e&&(r=e,e=null),e){const s=PI(e);r.hostname=s.host,r.secure="https"===s.protocol||"wss"===s.protocol,r.port=s.port,s.query&&(r.query=s.query)}else r.host&&(r.hostname=PI(r.host).host);Ob(this,r),this.secure=null!=r.secure?r.secure:typeof location<"u"&&"https:"===location.protocol,r.hostname&&!r.port&&(r.port=this.secure?"443":"80"),this.hostname=r.hostname||(typeof location<"u"?location.hostname:"localhost"),this.port=r.port||(typeof location<"u"&&location.port?location.port:this.secure?"443":"80"),this.transports=[],this._transportsByName={},r.transports.forEach(s=>{const o=s.prototype.name;this.transports.push(o),this._transportsByName[o]=s}),this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,addTrailingSlash:!0,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!1},r),this.opts.path=this.opts.path.replace(/\/$/,"")+(this.opts.addTrailingSlash?"/":""),"string"==typeof this.opts.query&&(this.opts.query=function bSe(n){let t={},e=n.split("&");for(let r=0,s=e.length;r<s;r++){let o=e[r].split("=");t[decodeURIComponent(o[0])]=decodeURIComponent(o[1])}return t}(this.opts.query)),LI&&(this.opts.closeOnBeforeunload&&(this._beforeunloadEventListener=()=>{this.transport&&(this.transport.removeAllListeners(),this.transport.close())},addEventListener("beforeunload",this._beforeunloadEventListener,!1)),"localhost"!==this.hostname&&(this._offlineEventListener=()=>{this._onClose("transport close",{description:"network connection lost"})},Mb.push(this._offlineEventListener))),this.opts.withCredentials&&(this._cookieJar=void 0),this._open()}createTransport(e){const r=Object.assign({},this.opts.query);r.EIO=4,r.transport=e,this.id&&(r.sid=this.id);const s=Object.assign({},this.opts,{query:r,socket:this,hostname:this.hostname,secure:this.secure,port:this.port},this.opts.transportOptions[e]);return new this._transportsByName[e](s)}_open(){if(0===this.transports.length)return void this.setTimeoutFn(()=>{this.emitReserved("error","No transports available")},0);const e=this.opts.rememberUpgrade&&n.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket")?"websocket":this.transports[0];this.readyState="opening";const r=this.createTransport(e);r.open(),this.setTransport(r)}setTransport(e){this.transport&&this.transport.removeAllListeners(),this.transport=e,e.on("drain",this._onDrain.bind(this)).on("packet",this._onPacket.bind(this)).on("error",this._onError.bind(this)).on("close",r=>this._onClose("transport close",r))}onOpen(){this.readyState="open",n.priorWebsocketSuccess="websocket"===this.transport.name,this.emitReserved("open"),this.flush()}_onPacket(e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emitReserved("packet",e),this.emitReserved("heartbeat"),e.type){case"open":this.onHandshake(JSON.parse(e.data));break;case"ping":this._sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong"),this._resetPingTimeout();break;case"error":const r=new Error("server error");r.code=e.data,this._onError(r);break;case"message":this.emitReserved("data",e.data),this.emitReserved("message",e.data)}}onHandshake(e){this.emitReserved("handshake",e),this.id=e.sid,this.transport.query.sid=e.sid,this._pingInterval=e.pingInterval,this._pingTimeout=e.pingTimeout,this._maxPayload=e.maxPayload,this.onOpen(),"closed"!==this.readyState&&this._resetPingTimeout()}_resetPingTimeout(){this.clearTimeoutFn(this._pingTimeoutTimer);const e=this._pingInterval+this._pingTimeout;this._pingTimeoutTime=Date.now()+e,this._pingTimeoutTimer=this.setTimeoutFn(()=>{this._onClose("ping timeout")},e),this.opts.autoUnref&&this._pingTimeoutTimer.unref()}_onDrain(){this.writeBuffer.splice(0,this._prevBufferLen),this._prevBufferLen=0,0===this.writeBuffer.length?this.emitReserved("drain"):this.flush()}flush(){if("closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){const e=this._getWritablePackets();this.transport.send(e),this._prevBufferLen=e.length,this.emitReserved("flush")}}_getWritablePackets(){if(!(this._maxPayload&&"polling"===this.transport.name&&this.writeBuffer.length>1))return this.writeBuffer;let r=1;for(let s=0;s<this.writeBuffer.length;s++){const o=this.writeBuffer[s].data;if(o&&(r+=mSe(o)),s>0&&r>this._maxPayload)return this.writeBuffer.slice(0,s);r+=2}return this.writeBuffer}_hasPingExpired(){if(!this._pingTimeoutTime)return!0;const e=Date.now()>this._pingTimeoutTime;return e&&(this._pingTimeoutTime=0,Rb(()=>{this._onClose("ping timeout")},this.setTimeoutFn)),e}write(e,r,s){return this._sendPacket("message",e,r,s),this}send(e,r,s){return this._sendPacket("message",e,r,s),this}_sendPacket(e,r,s,o){if("function"==typeof r&&(o=r,r=void 0),"function"==typeof s&&(o=s,s=null),"closing"===this.readyState||"closed"===this.readyState)return;(s=s||{}).compress=!1!==s.compress;const i={type:e,data:r,options:s};this.emitReserved("packetCreate",i),this.writeBuffer.push(i),o&&this.once("flush",o),this.flush()}close(){const e=()=>{this._onClose("forced close"),this.transport.close()},r=()=>{this.off("upgrade",r),this.off("upgradeError",r),e()},s=()=>{this.once("upgrade",r),this.once("upgradeError",r)};return("opening"===this.readyState||"open"===this.readyState)&&(this.readyState="closing",this.writeBuffer.length?this.once("drain",()=>{this.upgrading?s():e()}):this.upgrading?s():e()),this}_onError(e){if(n.priorWebsocketSuccess=!1,this.opts.tryAllTransports&&this.transports.length>1&&"opening"===this.readyState)return this.transports.shift(),this._open();this.emitReserved("error",e),this._onClose("transport error",e)}_onClose(e,r){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){if(this.clearTimeoutFn(this._pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),LI&&(this._beforeunloadEventListener&&removeEventListener("beforeunload",this._beforeunloadEventListener,!1),this._offlineEventListener)){const s=Mb.indexOf(this._offlineEventListener);-1!==s&&Mb.splice(s,1)}this.readyState="closed",this.id=null,this.emitReserved("close",e,r),this.writeBuffer=[],this._prevBufferLen=0}}}return n.protocol=4,n})();class FSe extends $I{constructor(){super(...arguments),this._upgrades=[]}onOpen(){if(super.onOpen(),"open"===this.readyState&&this.opts.upgrade)for(let t=0;t<this._upgrades.length;t++)this._probe(this._upgrades[t])}_probe(t){let e=this.createTransport(t),r=!1;$I.priorWebsocketSuccess=!1;const s=()=>{r||(e.send([{type:"ping",data:"probe"}]),e.once("packet",d=>{if(!r)if("pong"===d.type&&"probe"===d.data){if(this.upgrading=!0,this.emitReserved("upgrading",e),!e)return;$I.priorWebsocketSuccess="websocket"===e.name,this.transport.pause(()=>{r||"closed"!==this.readyState&&(c(),this.setTransport(e),e.send([{type:"upgrade"}]),this.emitReserved("upgrade",e),e=null,this.upgrading=!1,this.flush())})}else{const h=new Error("probe error");h.transport=e.name,this.emitReserved("upgradeError",h)}}))};function o(){r||(r=!0,c(),e.close(),e=null)}const i=d=>{const h=new Error("probe error: "+d);h.transport=e.name,o(),this.emitReserved("upgradeError",h)};function a(){i("transport closed")}function l(){i("socket closed")}function u(d){e&&d.name!==e.name&&o()}const c=()=>{e.removeListener("open",s),e.removeListener("error",i),e.removeListener("close",a),this.off("close",l),this.off("upgrading",u)};e.once("open",s),e.once("error",i),e.once("close",a),this.once("close",l),this.once("upgrading",u),-1!==this._upgrades.indexOf("webtransport")&&"webtransport"!==t?this.setTimeoutFn(()=>{r||e.open()},200):e.open()}onHandshake(t){this._upgrades=this._filterUpgrades(t.upgrades),super.onHandshake(t)}_filterUpgrades(t){const e=[];for(let r=0;r<t.length;r++)~this.transports.indexOf(t[r])&&e.push(t[r]);return e}}class ZB extends FSe{constructor(t,e={}){const r="object"==typeof t?t:e;(!r.transports||r.transports&&"string"==typeof r.transports[0])&&(r.transports=(r.transports||["polling","websocket","webtransport"]).map(s=>DSe[s]).filter(s=>!!s)),super(t,r)}}const PSe="function"==typeof ArrayBuffer,YB=Object.prototype.toString,$Se="function"==typeof Blob||typeof Blob<"u"&&"[object BlobConstructor]"===YB.call(Blob),VSe="function"==typeof File||typeof File<"u"&&"[object FileConstructor]"===YB.call(File);function VI(n){return PSe&&(n instanceof ArrayBuffer||(n=>"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(n):n.buffer instanceof ArrayBuffer)(n))||$Se&&n instanceof Blob||VSe&&n instanceof File}function Pb(n,t){if(!n||"object"!=typeof n)return!1;if(Array.isArray(n)){for(let e=0,r=n.length;e<r;e++)if(Pb(n[e]))return!0;return!1}if(VI(n))return!0;if(n.toJSON&&"function"==typeof n.toJSON&&1===arguments.length)return Pb(n.toJSON(),!0);for(const e in n)if(Object.prototype.hasOwnProperty.call(n,e)&&Pb(n[e]))return!0;return!1}function BSe(n){const t=[],r=n;return r.data=BI(n.data,t),r.attachments=t.length,{packet:r,buffers:t}}function BI(n,t){if(!n)return n;if(VI(n)){const e={_placeholder:!0,num:t.length};return t.push(n),e}if(Array.isArray(n)){const e=new Array(n.length);for(let r=0;r<n.length;r++)e[r]=BI(n[r],t);return e}if("object"==typeof n&&!(n instanceof Date)){const e={};for(const r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=BI(n[r],t));return e}return n}function zSe(n,t){return n.data=zI(n.data,t),delete n.attachments,n}function zI(n,t){if(!n)return n;if(n&&!0===n._placeholder){if("number"==typeof n.num&&n.num>=0&&n.num<t.length)return t[n.num];throw new Error("illegal attachments")}if(Array.isArray(n))for(let e=0;e<n.length;e++)n[e]=zI(n[e],t);else if("object"==typeof n)for(const e in n)Object.prototype.hasOwnProperty.call(n,e)&&(n[e]=zI(n[e],t));return n}const USe=["connect","connect_error","disconnect","disconnecting","newListener","removeListener"],WSe=5;var Vt=(()=>{return(n=Vt||(Vt={}))[n.CONNECT=0]="CONNECT",n[n.DISCONNECT=1]="DISCONNECT",n[n.EVENT=2]="EVENT",n[n.ACK=3]="ACK",n[n.CONNECT_ERROR=4]="CONNECT_ERROR",n[n.BINARY_EVENT=5]="BINARY_EVENT",n[n.BINARY_ACK=6]="BINARY_ACK",Vt;var n})();class HSe{constructor(t){this.replacer=t}encode(t){return t.type!==Vt.EVENT&&t.type!==Vt.ACK||!Pb(t)?[this.encodeAsString(t)]:this.encodeAsBinary({type:t.type===Vt.EVENT?Vt.BINARY_EVENT:Vt.BINARY_ACK,nsp:t.nsp,data:t.data,id:t.id})}encodeAsString(t){let e=""+t.type;return(t.type===Vt.BINARY_EVENT||t.type===Vt.BINARY_ACK)&&(e+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(e+=t.nsp+","),null!=t.id&&(e+=t.id),null!=t.data&&(e+=JSON.stringify(t.data,this.replacer)),e}encodeAsBinary(t){const e=BSe(t),r=this.encodeAsString(e.packet),s=e.buffers;return s.unshift(r),s}}function QB(n){return"[object Object]"===Object.prototype.toString.call(n)}class UI extends wr{constructor(t){super(),this.reviver=t}add(t){let e;if("string"==typeof t){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");e=this.decodeString(t);const r=e.type===Vt.BINARY_EVENT;r||e.type===Vt.BINARY_ACK?(e.type=r?Vt.EVENT:Vt.ACK,this.reconstructor=new jSe(e),0===e.attachments&&super.emitReserved("decoded",e)):super.emitReserved("decoded",e)}else{if(!VI(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");e=this.reconstructor.takeBinaryData(t),e&&(this.reconstructor=null,super.emitReserved("decoded",e))}}decodeString(t){let e=0;const r={type:Number(t.charAt(0))};if(void 0===Vt[r.type])throw new Error("unknown packet type "+r.type);if(r.type===Vt.BINARY_EVENT||r.type===Vt.BINARY_ACK){const o=e+1;for(;"-"!==t.charAt(++e)&&e!=t.length;);const i=t.substring(o,e);if(i!=Number(i)||"-"!==t.charAt(e))throw new Error("Illegal attachments");r.attachments=Number(i)}if("/"===t.charAt(e+1)){const o=e+1;for(;++e&&","!==t.charAt(e)&&e!==t.length;);r.nsp=t.substring(o,e)}else r.nsp="/";const s=t.charAt(e+1);if(""!==s&&Number(s)==s){const o=e+1;for(;++e;){const i=t.charAt(e);if(null==i||Number(i)!=i){--e;break}if(e===t.length)break}r.id=Number(t.substring(o,e+1))}if(t.charAt(++e)){const o=this.tryParse(t.substr(e));if(!UI.isPayloadValid(r.type,o))throw new Error("invalid payload");r.data=o}return r}tryParse(t){try{return JSON.parse(t,this.reviver)}catch{return!1}}static isPayloadValid(t,e){switch(t){case Vt.CONNECT:return QB(e);case Vt.DISCONNECT:return void 0===e;case Vt.CONNECT_ERROR:return"string"==typeof e||QB(e);case Vt.EVENT:case Vt.BINARY_EVENT:return Array.isArray(e)&&("number"==typeof e[0]||"string"==typeof e[0]&&-1===USe.indexOf(e[0]));case Vt.ACK:case Vt.BINARY_ACK:return Array.isArray(e)}}destroy(){this.reconstructor&&(this.reconstructor.finishedReconstruction(),this.reconstructor=null)}}class jSe{constructor(t){this.packet=t,this.buffers=[],this.reconPack=t}takeBinaryData(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){const e=zSe(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null}finishedReconstruction(){this.reconPack=null,this.buffers=[]}}function vi(n,t,e){return n.on(t,e),function(){n.off(t,e)}}const GSe=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class ez extends wr{constructor(t,e,r){super(),this.connected=!1,this.recovered=!1,this.receiveBuffer=[],this.sendBuffer=[],this._queue=[],this._queueSeq=0,this.ids=0,this.acks={},this.flags={},this.io=t,this.nsp=e,r&&r.auth&&(this.auth=r.auth),this._opts=Object.assign({},r),this.io._autoConnect&&this.open()}get disconnected(){return!this.connected}subEvents(){if(this.subs)return;const t=this.io;this.subs=[vi(t,"open",this.onopen.bind(this)),vi(t,"packet",this.onpacket.bind(this)),vi(t,"error",this.onerror.bind(this)),vi(t,"close",this.onclose.bind(this))]}get active(){return!!this.subs}connect(){return this.connected||(this.subEvents(),this.io._reconnecting||this.io.open(),"open"===this.io._readyState&&this.onopen()),this}open(){return this.connect()}send(...t){return t.unshift("message"),this.emit.apply(this,t),this}emit(t,...e){var r,s,o;if(GSe.hasOwnProperty(t))throw new Error('"'+t.toString()+'" is a reserved event name');if(e.unshift(t),this._opts.retries&&!this.flags.fromQueue&&!this.flags.volatile)return this._addToQueue(e),this;const i={type:Vt.EVENT,data:e,options:{}};if(i.options.compress=!1!==this.flags.compress,"function"==typeof e[e.length-1]){const c=this.ids++,d=e.pop();this._registerAckCallback(c,d),i.id=c}const a=null===(s=null===(r=this.io.engine)||void 0===r?void 0:r.transport)||void 0===s?void 0:s.writable,l=this.connected&&!(null!==(o=this.io.engine)&&void 0!==o&&o._hasPingExpired());return this.flags.volatile&&!a||(l?(this.notifyOutgoingListeners(i),this.packet(i)):this.sendBuffer.push(i)),this.flags={},this}_registerAckCallback(t,e){var r;const s=null!==(r=this.flags.timeout)&&void 0!==r?r:this._opts.ackTimeout;if(void 0===s)return void(this.acks[t]=e);const o=this.io.setTimeoutFn(()=>{delete this.acks[t];for(let a=0;a<this.sendBuffer.length;a++)this.sendBuffer[a].id===t&&this.sendBuffer.splice(a,1);e.call(this,new Error("operation has timed out"))},s),i=(...a)=>{this.io.clearTimeoutFn(o),e.apply(this,a)};i.withError=!0,this.acks[t]=i}emitWithAck(t,...e){return new Promise((r,s)=>{const o=(i,a)=>i?s(i):r(a);o.withError=!0,e.push(o),this.emit(t,...e)})}_addToQueue(t){let e;"function"==typeof t[t.length-1]&&(e=t.pop());const r={id:this._queueSeq++,tryCount:0,pending:!1,args:t,flags:Object.assign({fromQueue:!0},this.flags)};t.push((s,...o)=>r!==this._queue[0]?void 0:(null!==s?r.tryCount>this._opts.retries&&(this._queue.shift(),e&&e(s)):(this._queue.shift(),e&&e(null,...o)),r.pending=!1,this._drainQueue())),this._queue.push(r),this._drainQueue()}_drainQueue(t=!1){if(!this.connected||0===this._queue.length)return;const e=this._queue[0];e.pending&&!t||(e.pending=!0,e.tryCount++,this.flags=e.flags,this.emit.apply(this,e.args))}packet(t){t.nsp=this.nsp,this.io._packet(t)}onopen(){"function"==typeof this.auth?this.auth(t=>{this._sendConnectPacket(t)}):this._sendConnectPacket(this.auth)}_sendConnectPacket(t){this.packet({type:Vt.CONNECT,data:this._pid?Object.assign({pid:this._pid,offset:this._lastOffset},t):t})}onerror(t){this.connected||this.emitReserved("connect_error",t)}onclose(t,e){this.connected=!1,delete this.id,this.emitReserved("disconnect",t,e),this._clearAcks()}_clearAcks(){Object.keys(this.acks).forEach(t=>{if(!this.sendBuffer.some(r=>String(r.id)===t)){const r=this.acks[t];delete this.acks[t],r.withError&&r.call(this,new Error("socket has been disconnected"))}})}onpacket(t){if(t.nsp===this.nsp)switch(t.type){case Vt.CONNECT:t.data&&t.data.sid?this.onconnect(t.data.sid,t.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case Vt.EVENT:case Vt.BINARY_EVENT:this.onevent(t);break;case Vt.ACK:case Vt.BINARY_ACK:this.onack(t);break;case Vt.DISCONNECT:this.ondisconnect();break;case Vt.CONNECT_ERROR:this.destroy();const r=new Error(t.data.message);r.data=t.data.data,this.emitReserved("connect_error",r)}}onevent(t){const e=t.data||[];null!=t.id&&e.push(this.ack(t.id)),this.connected?this.emitEvent(e):this.receiveBuffer.push(Object.freeze(e))}emitEvent(t){if(this._anyListeners&&this._anyListeners.length){const e=this._anyListeners.slice();for(const r of e)r.apply(this,t)}super.emit.apply(this,t),this._pid&&t.length&&"string"==typeof t[t.length-1]&&(this._lastOffset=t[t.length-1])}ack(t){const e=this;let r=!1;return function(...s){r||(r=!0,e.packet({type:Vt.ACK,id:t,data:s}))}}onack(t){const e=this.acks[t.id];"function"==typeof e&&(delete this.acks[t.id],e.withError&&t.data.unshift(null),e.apply(this,t.data))}onconnect(t,e){this.id=t,this.recovered=e&&this._pid===e,this._pid=e,this.connected=!0,this.emitBuffered(),this.emitReserved("connect"),this._drainQueue(!0)}emitBuffered(){this.receiveBuffer.forEach(t=>this.emitEvent(t)),this.receiveBuffer=[],this.sendBuffer.forEach(t=>{this.notifyOutgoingListeners(t),this.packet(t)}),this.sendBuffer=[]}ondisconnect(){this.destroy(),this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach(t=>t()),this.subs=void 0),this.io._destroy(this)}disconnect(){return this.connected&&this.packet({type:Vt.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}close(){return this.disconnect()}compress(t){return this.flags.compress=t,this}get volatile(){return this.flags.volatile=!0,this}timeout(t){return this.flags.timeout=t,this}onAny(t){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(t),this}prependAny(t){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(t),this}offAny(t){if(!this._anyListeners)return this;if(t){const e=this._anyListeners;for(let r=0;r<e.length;r++)if(t===e[r])return e.splice(r,1),this}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}onAnyOutgoing(t){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(t),this}prependAnyOutgoing(t){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(t),this}offAnyOutgoing(t){if(!this._anyOutgoingListeners)return this;if(t){const e=this._anyOutgoingListeners;for(let r=0;r<e.length;r++)if(t===e[r])return e.splice(r,1),this}else this._anyOutgoingListeners=[];return this}listenersAnyOutgoing(){return this._anyOutgoingListeners||[]}notifyOutgoingListeners(t){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){const e=this._anyOutgoingListeners.slice();for(const r of e)r.apply(this,t.data)}}}function Ud(n){this.ms=(n=n||{}).min||100,this.max=n.max||1e4,this.factor=n.factor||2,this.jitter=n.jitter>0&&n.jitter<=1?n.jitter:0,this.attempts=0}Ud.prototype.duration=function(){var n=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var t=Math.random(),e=Math.floor(t*this.jitter*n);n=0==(1&Math.floor(10*t))?n-e:n+e}return 0|Math.min(n,this.max)},Ud.prototype.reset=function(){this.attempts=0},Ud.prototype.setMin=function(n){this.ms=n},Ud.prototype.setMax=function(n){this.max=n},Ud.prototype.setJitter=function(n){this.jitter=n};class WI extends wr{constructor(t,e){var r;super(),this.nsps={},this.subs=[],t&&"object"==typeof t&&(e=t,t=void 0),(e=e||{}).path=e.path||"/socket.io",this.opts=e,Ob(this,e),this.reconnection(!1!==e.reconnection),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(null!==(r=e.randomizationFactor)&&void 0!==r?r:.5),this.backoff=new Ud({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(e.timeout??2e4),this._readyState="closed",this.uri=t;const s=e.parser||Ie;this.encoder=new s.Encoder,this.decoder=new s.Decoder,this._autoConnect=!1!==e.autoConnect,this._autoConnect&&this.open()}reconnection(t){return arguments.length?(this._reconnection=!!t,t||(this.skipReconnect=!0),this):this._reconnection}reconnectionAttempts(t){return void 0===t?this._reconnectionAttempts:(this._reconnectionAttempts=t,this)}reconnectionDelay(t){var e;return void 0===t?this._reconnectionDelay:(this._reconnectionDelay=t,null===(e=this.backoff)||void 0===e||e.setMin(t),this)}randomizationFactor(t){var e;return void 0===t?this._randomizationFactor:(this._randomizationFactor=t,null===(e=this.backoff)||void 0===e||e.setJitter(t),this)}reconnectionDelayMax(t){var e;return void 0===t?this._reconnectionDelayMax:(this._reconnectionDelayMax=t,null===(e=this.backoff)||void 0===e||e.setMax(t),this)}timeout(t){return arguments.length?(this._timeout=t,this):this._timeout}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()}open(t){if(~this._readyState.indexOf("open"))return this;this.engine=new ZB(this.uri,this.opts);const e=this.engine,r=this;this._readyState="opening",this.skipReconnect=!1;const s=vi(e,"open",function(){r.onopen(),t&&t()}),o=a=>{this.cleanup(),this._readyState="closed",this.emitReserved("error",a),t?t(a):this.maybeReconnectOnOpen()},i=vi(e,"error",o);if(!1!==this._timeout){const l=this.setTimeoutFn(()=>{s(),o(new Error("timeout")),e.close()},this._timeout);this.opts.autoUnref&&l.unref(),this.subs.push(()=>{this.clearTimeoutFn(l)})}return this.subs.push(s),this.subs.push(i),this}connect(t){return this.open(t)}onopen(){this.cleanup(),this._readyState="open",this.emitReserved("open");const t=this.engine;this.subs.push(vi(t,"ping",this.onping.bind(this)),vi(t,"data",this.ondata.bind(this)),vi(t,"error",this.onerror.bind(this)),vi(t,"close",this.onclose.bind(this)),vi(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(t){try{this.decoder.add(t)}catch(e){this.onclose("parse error",e)}}ondecoded(t){Rb(()=>{this.emitReserved("packet",t)},this.setTimeoutFn)}onerror(t){this.emitReserved("error",t)}socket(t,e){let r=this.nsps[t];return r?this._autoConnect&&!r.active&&r.connect():(r=new ez(this,t,e),this.nsps[t]=r),r}_destroy(t){const e=Object.keys(this.nsps);for(const r of e)if(this.nsps[r].active)return;this._close()}_packet(t){const e=this.encoder.encode(t);for(let r=0;r<e.length;r++)this.engine.write(e[r],t.options)}cleanup(){this.subs.forEach(t=>t()),this.subs.length=0,this.decoder.destroy()}_close(){this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close")}disconnect(){return this._close()}onclose(t,e){var r;this.cleanup(),null===(r=this.engine)||void 0===r||r.close(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",t,e),this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const t=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const e=this.backoff.duration();this._reconnecting=!0;const r=this.setTimeoutFn(()=>{t.skipReconnect||(this.emitReserved("reconnect_attempt",t.backoff.attempts),!t.skipReconnect&&t.open(s=>{s?(t._reconnecting=!1,t.reconnect(),this.emitReserved("reconnect_error",s)):t.onreconnect()}))},e);this.opts.autoUnref&&r.unref(),this.subs.push(()=>{this.clearTimeoutFn(r)})}}onreconnect(){const t=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",t)}}const nm={};function rm(n,t){"object"==typeof n&&(t=n,n=void 0);const e=function MSe(n,t="",e){let r=n;e=e||typeof location<"u"&&location,null==n&&(n=e.protocol+"//"+e.host),"string"==typeof n&&("/"===n.charAt(0)&&(n="/"===n.charAt(1)?e.protocol+n:e.host+n),/^(https?|wss?):\/\//.test(n)||(n=typeof e<"u"?e.protocol+"//"+n:"https://"+n),r=PI(n)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";const o=-1!==r.host.indexOf(":")?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+o+":"+r.port+t,r.href=r.protocol+"://"+o+(e&&e.port===r.port?"":":"+r.port),r}(n,(t=t||{}).path||"/socket.io"),r=e.source,s=e.id;let l;return t.forceNew||t["force new connection"]||!1===t.multiplex||nm[s]&&e.path in nm[s].nsps?l=new WI(r,t):(nm[s]||(nm[s]=new WI(r,t)),l=nm[s]),e.query&&!t.query&&(t.query=e.queryKey),l.socket(e.path,t)}Object.assign(rm,{Manager:WI,Socket:ez,io:rm,connect:rm});class Ki extends Go{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const om=["Hemlet","Vest","Head"],qSe={video:{width:640,height:640}};class im{enter;exit;_enterSubject$;_exitSubject$;constructor(){this._enterSubject$=new Ki(0),this.enter=this._enterSubject$.asObservable(),this._exitSubject$=new Ki(0),this.exit=this._exitSubject$.asObservable()}get enterCount(){return this._enterSubject$.value}get exitCount(){return this._exitSubject$.value}get totalCount(){return this.enterCount+this.exitCount}changeTrigger(t){"enter"===t?this._enterSubject$.next(this.enterCount+1):"exit"===t&&this._exitSubject$.next(this.exitCount+1)}reset(t="all"){"exit"!=t&&this._enterSubject$.next(0),"enter"!=t&&this._exitSubject$.next(0)}static \u0275fac=function(e){return new(e||im)};static \u0275prov=Qe({token:im,factory:im.\u0275fac,providedIn:"root"})}class HI{_curBox;_id;_center;_isEnter;preBox=[];frameCount=0;id;isReAssign=!1;center=[];isEnter=!1;constructor(t,e,r,s){this._curBox=t,this._id=e,this._center=r,this._isEnter=s,this.preBox=[...this._curBox],this.id=this._id,this.center=[...this._center],this.isEnter=this._isEnter}update(t,e){this.preBox=[...t],this.center=[...e],this.frameCount=0}decay(){this.frameCount++}checkSideChange(t){const[e,r]=this.center,s=this.isEnter;if(t.x2===t.x1){let o=!(e<t.x1);return this.isEnter=o,o!=s?o?"exit":"enter":"none"}if(t.y2===t.y1){let o=!(r<t.y1);return this.isEnter=o,o!=s?o?"exit":"enter":"none"}{const o=(t.y2-t.y1)/(t.x2-t.x1);let l=!(r<o*e+(t.y1-t.x1*o));return this.isEnter=l,l!=s?l?"exit":"enter":"none"}}calculateIntersectionOverUnion(t){const e=[...this.preBox];let r=Math.max(e[0],t[0]),s=Math.max(e[1],t[1]),o=Math.min(e[2],t[2]),i=Math.min(e[3],t[3]),u=Math.max(0,o-r+1)*Math.max(0,i-s+1);return u/((e[2]-e[0]+1)*(e[3]-e[1]+1)+(t[2]-t[0]+1)*(t[3]-t[1]+1)-u)}}class am{_countingService;_history=[];_current=[];_historyFrameTimestamp=0;_currentFrameTimestamp=0;id_counting=1;THRESHOLD=.5;DECAY_THRESHOLD=900;checkLine={x1:0,y1:0,x2:0,y2:0};constructor(t){this._countingService=t}_map(t){let e=null,r=-1;return this._history.forEach((s,o)=>{let i=s.calculateIntersectionOverUnion(t);if(i>this.THRESHOLD&&(null===e||i>r)){const a=this._history[o];e=new HI(a.preBox,s.id,a.center,a.isEnter),r=i,this._history[o].isReAssign=!0}}),e}feed(t,e){if(0===this._historyFrameTimestamp){const r=this.id_counting;this._currentFrameTimestamp=e;const s=new HI(t.box,r,[t.x_center,t.y_center],!1);return s.checkSideChange(this.checkLine),this._current.push(s),this.id_counting++,r}{const r=this._map(t.box);let s=this.id_counting;return this._currentFrameTimestamp=e,r?(r.update(t.box,[t.x_center,t.y_center]),this._countingService.changeTrigger(r.checkSideChange(this.checkLine)),s=r.id,this._current.push(r)):(new HI(t.box,this.id_counting,[t.x_center,t.y_center],!1).checkSideChange(this.checkLine),this._current.push(),this.id_counting++),s}}next(){const t=this._history.filter(e=>!e.isReAssign&&e.frameCount<=this.DECAY_THRESHOLD);t.forEach(e=>e.decay()),this._historyFrameTimestamp=this._currentFrameTimestamp,this._history=[...this._current,...t],this._currentFrameTimestamp=0,this._current=[]}setCheckLine(t){this.checkLine={...t}}static \u0275fac=function(e){return new(e||am)(Nt(im))};static \u0275prov=Qe({token:am,factory:am.\u0275fac,providedIn:"root"})}class lm{_trackerService;loadingModelProgress;currentModel;dataBuffer=[];objectDetectStatus;_loadingModelProgressSubject$;_currentModel$;_objectDetectStatusSubject$;_confidenceThreshold=.72;constructor(t){this._trackerService=t,this._loadingModelProgressSubject$=new Ki({loading:!1,progress:0}),this.loadingModelProgress=this._loadingModelProgressSubject$.asObservable(),this._currentModel$=new Ki(null),this.currentModel=this._currentModel$.asObservable(),this._objectDetectStatusSubject$=new Ki([]),this.objectDetectStatus=this._objectDetectStatusSubject$.asObservable()}_preProcess(t,e,r){let s,o;return[H(()=>{const a=U0(t),[l,u]=a.shape.slice(0,2),c=Math.max(u,l),d=a.pad([[0,c-l],[0,c-u],[0,0]]);return s=c/e,o=c/r,Ur.resizeBilinear(d,[e,r]).div(255).expandDims(0)}),s,o]}_renderBoxes(t,e,r,s,o){const i=t.getContext("2d");i.clearRect(0,0,i.canvas.width,i.canvas.height);const a=new $b,l=`${Math.max(Math.round(Math.max(i.canvas.width,i.canvas.height)/40),14)}px Arial`;i.font=l,i.textBaseline="top";const u=(new Date).getTime();console.log(r);for(let c=0;c<r.length;++c){if(0!=s[c]||100*r[c]<60)continue;const d=om[s[c]],h=a.get(s[c]),f=(100*r[c]).toFixed(1);let[p,g,m,y]=e.slice(4*c,4*(c+1));g*=o[0],y*=o[0],p*=o[1],m*=o[1];const v=y-g,w=m-p,x=g+v/2,N=p+w/2,I={x_center:x,y_center:N,box:[g,p,y,m],confidence:parseFloat(f)},k=this._trackerService.feed(I,u);i.fillStyle=h,i.beginPath(),i.arc(x,N,2,0,2*Math.PI),i.stroke(),i.fillStyle=$b.hexToRgba(h,.2),i.fillRect(g,p,v,w),i.strokeStyle=h,i.lineWidth=Math.max(Math.min(i.canvas.width,i.canvas.height)/200,2.5),i.strokeRect(g,p,v,w),i.fillStyle=h;const A=i.measureText(`${d} - ${f}%, ID = ${k}`).width,R=parseInt(l,10),F=p-(R+i.lineWidth);i.fillRect(g-1,F<0?0:F,A+i.lineWidth,R+i.lineWidth),i.fillStyle="#ffffff",i.fillText(`${d} - ${f}%, ID = ${k}`,g-1,F<0?0:F)}this._trackerService.next()}_renderBoxesOfHelmetVest(t,e,r,s,o){const i=t.getContext("2d");i.clearRect(0,0,i.canvas.width,i.canvas.height);const a=new $b,l=`${Math.max(Math.round(Math.max(i.canvas.width,i.canvas.height)/40),14)}px Arial`;i.font=l,i.textBaseline="top";for(let u=0;u<r.length;++u){if(r[u]<this._confidenceThreshold)continue;const c=om[s[u]],d=a.get(s[u]),h=(100*r[u]).toFixed(1);let[f,p,g,m]=e.slice(4*u,4*(u+1));p*=o[0],m*=o[0],f*=o[1],g*=o[1];const y=m-p,v=g-f;i.fillStyle=$b.hexToRgba(d,.2),i.fillRect(p,f,y,v),i.strokeStyle=d,i.lineWidth=Math.max(Math.min(i.canvas.width,i.canvas.height)/200,2.5),i.strokeRect(p,f,y,v),i.fillStyle=d;const w=i.measureText(`${c} - ${h}%`).width,x=parseInt(l,10),N=f-(x+i.lineWidth);i.fillRect(p-1,N<0?0:N,w+i.lineWidth,x+i.lineWidth),i.fillStyle="#ffffff",i.fillText(`${c} - ${h}%`,p-1,N<0?0:N)}}loadTFModel(t){var e=this;return J(function*(){(function vX(){return $.ready()})().then(J(function*(){const r=yield GT(`${t}`,{onProgress:i=>{e._loadingModelProgressSubject$.next({loading:!0,progress:i})}}),s=Is(r.inputs[0].shape),o=r.execute(s);e._loadingModelProgressSubject$.next({loading:!1,progress:1}),e._currentModel$.next({net:r,inputShape:r.inputs[0].shape}),ut([o,s])}))})()}detect(t,e,r,s){var o=this;return J(function*(){const[i,a]=e.inputShape.slice(1,3);Us().startScope();const[l,u,c]=o._preProcess(t,i,a),d=e.net.execute(l),h=d.transpose([0,2,1]),f=H(()=>{const N=h.slice([0,0,2],[-1,-1,1]),I=h.slice([0,0,3],[-1,-1,1]),k=De(h.slice([0,0,0],[-1,-1,1]),Ee(N,2)),A=De(h.slice([0,0,1],[-1,-1,1]),Ee(I,2));return _n([A,k,ue(A,I),ue(k,N)],2).squeeze()}),p=om.length,[g,m]=H(()=>{const N=h.slice([0,0,4],[-1,-1,p]).squeeze(0);return[N.max(1),N.argMax(1)]}),y=yield Ur.nonMaxSuppressionAsync(f,g,500,.45,.2),v=f.gather(y,0).dataSync(),w=g.gather(y,0).dataSync(),x=m.gather(y,0).dataSync();o._renderBoxes(r,v,w,x,[u,c]),ut([d,h,f,g,m,y]),s(),Us().endScope()})()}detectHelmetVest(t,e,r,s){var o=this;return J(function*(){const[i,a]=e.inputShape.slice(1,3);Us().startScope();const[l,u,c]=o._preProcess(t,i,a),d=e.net.execute(l),h=d.transpose([0,2,1]),f=H(()=>{const I=h.slice([0,0,2],[-1,-1,1]),k=h.slice([0,0,3],[-1,-1,1]),A=De(h.slice([0,0,0],[-1,-1,1]),Ee(I,2)),R=De(h.slice([0,0,1],[-1,-1,1]),Ee(k,2));return _n([R,A,ue(R,k),ue(A,I)],2).squeeze()}),p=om.length,[g,m]=H(()=>{const I=h.slice([0,0,4],[-1,-1,p]).squeeze(0);return[I.max(1),I.argMax(1)]}),y=yield Ur.nonMaxSuppressionAsync(f,g,500,.45,.2),v=f.gather(y,0).dataSync(),w=g.gather(y,0).dataSync(),x=m.gather(y,0).dataSync();o._renderBoxesOfHelmetVest(r,v,w,x,[u,c]);const N=Array.from(x).filter((I,k)=>w[k]>=o._confidenceThreshold).map(I=>om[I]);o._objectDetectStatusSubject$.next(N),ut([d,h,f,g,m,y]),s(),Us().endScope()})()}detectVideo(t,e,r){var s=this;const o=r.getContext("2d");this._trackerService.setCheckLine({x1:o.canvas.width/2,y1:0,x2:o.canvas.width/2,y2:o.canvas.height});const i=function(){var a=J(function*(){0!==t.videoWidth||null!==t.srcObject?s.detect(t,e,r,()=>{requestAnimationFrame(i)}):o.clearRect(0,0,o.canvas.width,o.canvas.height)});return function(){return a.apply(this,arguments)}}();i()}detectVideoFromStreaming(t,e,r){var s=this;const o=r.getContext("2d");this._trackerService.setCheckLine({x1:0,y1:o.canvas.height/2+100,x2:o.canvas.width,y2:o.canvas.height/2-100});const i=function(){var a=J(function*(){0!==t.width||null!==t.src?s.detect(t,e,r,()=>{requestAnimationFrame(i)}):o.clearRect(0,0,o.canvas.width,o.canvas.height)});return function(){return a.apply(this,arguments)}}();i()}static \u0275fac=function(e){return new(e||lm)(Nt(am))};static \u0275prov=Qe({token:lm,factory:lm.\u0275fac,providedIn:"root"})}class $b{palette=[];n;constructor(){this.palette=["#FF3838","#FF9D97","#FF701F","#FFB21D","#CFD231","#48F90A","#92CC17","#3DDB86","#1A9334","#00D4BB","#2C99A8","#00C2FF","#344593","#6473FF","#0018EC","#8438FF","#520085","#CB38FF","#FF95C8","#FF37C7"],this.n=this.palette.length}get(t){return this.palette[Math.floor(t)%this.n]}static hexToRgba(t,e){var r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return r?`rgba(${[parseInt(r[1],16),parseInt(r[2],16),parseInt(r[3],16)].join(", ")}, ${e})`:null}}class Wd{currentSream;_mediaStreamConstraints={...qSe};_mediaDevices=navigator.mediaDevices;_currentSream$;_streamObj=null;constructor(){this._currentSream$=new Ki(null),this.currentSream=this._currentSream$.asObservable()}startCamera(t=640,e=640){this._streamObj||(this._mediaStreamConstraints.video.height=t,this._mediaStreamConstraints.video.width=e,this._mediaDevices.getUserMedia(this._mediaStreamConstraints).then(r=>{this._streamObj=r,this._currentSream$.next(this._streamObj)}).catch(r=>{console.log("navigator.getUserMedia error: ",r)}))}stopCamera(){!this._streamObj||(this._streamObj.getTracks().forEach(function(t){t.stop()}),this._streamObj=null,this._currentSream$.next(this._streamObj))}static \u0275fac=function(e){return new(e||Wd)};static \u0275prov=Qe({token:Wd,factory:Wd.\u0275fac,providedIn:"root"})}var KSe=ee(956),Al=function(){return Al=Object.assign||function(n){for(var t,e=1,r=arguments.length;e<r;e++)for(var s in t=arguments[e])Object.prototype.hasOwnProperty.call(t,s)&&(n[s]=t[s]);return n},Al.apply(this,arguments)};function Da(n,t,e,r){return new(e||(e=Promise))(function(s,o){function i(u){try{l(r.next(u))}catch(c){o(c)}}function a(u){try{l(r.throw(u))}catch(c){o(c)}}function l(u){var c;u.done?s(u.value):(c=u.value,c instanceof e?c:new e(function(d){d(c)})).then(i,a)}l((r=r.apply(n,t||[])).next())})}function ka(n,t){var e,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(u){return function(c){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,r=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==c[0]&&2!==c[0])){i=0;continue}if(3===c[0]&&(!s||c[1]>s[0]&&c[1]<s[3])){i.label=c[1];break}if(6===c[0]&&i.label<s[1]){i.label=s[1],s=c;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(c);break}s[2]&&i.ops.pop(),i.trys.pop();continue}c=t.call(n,i)}catch(d){c=[6,d],r=0}finally{e=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}var nz=["rightEye","leftEye","noseTip","mouthCenter","rightEarTragion","leftEarTragion"],jI={modelType:"short",runtime:"mediapipe",maxFaces:1},XSe=function(){function n(t){var e=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceDetectorSolution=new KSe.FaceDetection({locateFile:function(r,s){if(t.solutionPath){var o=t.solutionPath.replace(/\/+$/,"");return"".concat(o,"/").concat(r)}return"".concat(s,"/").concat(r)}}),this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode,model:t.modelType}),this.faceDetectorSolution.onResults(function(r){if(e.height=r.image.height,e.width=r.image.width,e.faces=[],null!==r.detections)for(var s=0,o=r.detections;s<o.length;s++){var i=o[s];e.faces.push(e.normalizedToAbsolute(i.landmarks,{xMin:l=(a=i.boundingBox).xCenter-a.width/2,xMax:l+a.width,yMin:c=a.yCenter-a.height/2,yMax:c+a.height,width:a.width,height:a.height}))}var a,l,c})}return n.prototype.normalizedToAbsolute=function(t,e){var r=this;return{keypoints:t.map(function(s,o){return{x:s.x*r.width,y:s.y*r.height,name:nz[o]}}),box:{xMin:e.xMin*this.width,yMin:e.yMin*this.height,xMax:e.xMax*this.width,yMax:e.yMax*this.height,width:e.width*this.width,height:e.height*this.height}}},n.prototype.estimateFaces=function(t,e){return Da(this,void 0,void 0,function(){var r,s;return ka(this,function(o){switch(o.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode})),t instanceof on?(s=ImageData.bind,[4,MJ(t)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,o.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:r=t,o.label=3;case 3:return[4,this.faceDetectorSolution.send({image:t=r})];case 4:return o.sent(),[2,this.faces]}})})},n.prototype.dispose=function(){this.faceDetectorSolution.close()},n.prototype.reset=function(){this.faceDetectorSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},n.prototype.initialize=function(){return this.faceDetectorSolution.initialize()},n}();function JSe(n){return Da(this,void 0,void 0,function(){var t,e;return ka(this,function(r){switch(r.label){case 0:return t=function(s){if(null==s)return Al({},jI);var o=Al({},s);return o.runtime="mediapipe",null==o.modelType&&(o.modelType=jI.modelType),null==o.maxFaces&&(o.maxFaces=jI.maxFaces),o}(n),[4,(e=new XSe(t)).initialize()];case 1:return r.sent(),[2,e]}})})}function rz(n){return n instanceof on?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function sz(n){return n instanceof on?n:U0(n)}function GI(n,t){_(0!==n.width,function(){return"".concat(t," width cannot be 0.")}),_(0!==n.height,function(){return"".concat(t," height cannot be 0.")})}function oz(n){null==n.reduceBoxesInLowestLayer&&(n.reduceBoxesInLowestLayer=!1),null==n.interpolatedScaleAspectRatio&&(n.interpolatedScaleAspectRatio=1),null==n.fixedAnchorSize&&(n.fixedAnchorSize=!1);for(var t=[],e=0;e<n.numLayers;){for(var r=[],s=[],o=[],i=[],a=e;a<n.strides.length&&n.strides[a]===n.strides[e];){var l=iz(n.minScale,n.maxScale,a,n.strides.length);if(0===a&&n.reduceBoxesInLowestLayer)o.push(1),o.push(2),o.push(.5),i.push(.1),i.push(l),i.push(l);else{for(var u=0;u<n.aspectRatios.length;++u)o.push(n.aspectRatios[u]),i.push(l);if(n.interpolatedScaleAspectRatio>0){var c=a===n.strides.length-1?1:iz(n.minScale,n.maxScale,a+1,n.strides.length);i.push(Math.sqrt(l*c)),o.push(n.interpolatedScaleAspectRatio)}}a++}for(var d=0;d<o.length;++d){var h=Math.sqrt(o[d]);r.push(i[d]/h),s.push(i[d]*h)}var f=0,p=0;if(n.featureMapHeight.length>0)f=n.featureMapHeight[e],p=n.featureMapWidth[e];else{var g=n.strides[e];f=Math.ceil(n.inputSizeHeight/g),p=Math.ceil(n.inputSizeWidth/g)}for(var m=0;m<f;++m)for(var y=0;y<p;++y)for(var v=0;v<r.length;++v){var w={xCenter:(y+n.anchorOffsetX)/p,yCenter:(m+n.anchorOffsetY)/f,width:0,height:0};n.fixedAnchorSize?(w.width=1,w.height=1):(w.width=s[v],w.height=r[v]),t.push(w)}e=a}return t}function iz(n,t,e,r){return 1===r?.5*(n+t):n+(t-n)*e/(r-1)}function az(n,t){var e=t[0],r=t[1];return[e*n[0]+r*n[1]+n[3],e*n[4]+r*n[5]+n[7]]}function tNe(n,t,e,r){return Da(this,void 0,void 0,function(){var s,o,i,a,l;return ka(this,function(u){switch(u.label){case 0:return n.sort(function(c,d){return Math.max.apply(Math,d.score)-Math.max.apply(Math,c.score)}),s=Pi(n.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),o=Qn(n.map(function(c){return c.score[0]})),[4,Ur.nonMaxSuppressionAsync(s,o,t,e)];case 1:return[4,(i=u.sent()).array()];case 2:return a=u.sent(),l=n.filter(function(c,d){return a.indexOf(d)>-1}),ut([s,o,i]),[2,l]}})})}function nNe(n,t,e){return Da(this,void 0,void 0,function(){var r,o,i,a;return ka(this,function(l){switch(l.label){case 0:return r=n[0],u=n[1],c=t,d=e,o=H(function(){var h,f,p,g;d.reverseOutputOrder?(f=Yn(rt(u,[0,d.boxCoordOffset+0],[-1,1])),h=Yn(rt(u,[0,d.boxCoordOffset+1],[-1,1])),g=Yn(rt(u,[0,d.boxCoordOffset+2],[-1,1])),p=Yn(rt(u,[0,d.boxCoordOffset+3],[-1,1]))):(h=Yn(rt(u,[0,d.boxCoordOffset+0],[-1,1])),f=Yn(rt(u,[0,d.boxCoordOffset+1],[-1,1])),p=Yn(rt(u,[0,d.boxCoordOffset+2],[-1,1])),g=Yn(rt(u,[0,d.boxCoordOffset+3],[-1,1]))),f=ue(L(Ee(f,d.xScale),c.w),c.x),h=ue(L(Ee(h,d.yScale),c.h),c.y),d.applyExponentialOnBoxSize?(p=L(ls(Ee(p,d.hScale)),c.h),g=L(ls(Ee(g,d.wScale)),c.w)):(p=L(Ee(p,d.hScale),c.h),g=L(Ee(g,d.wScale),c.h));var m=De(h,Ee(p,2)),y=De(f,Ee(g,2)),v=ue(h,Ee(p,2)),w=ue(f,Ee(g,2)),x=_n([V(m,[d.numBoxes,1]),V(y,[d.numBoxes,1]),V(v,[d.numBoxes,1]),V(w,[d.numBoxes,1])],1);if(d.numKeypoints)for(var N=0;N<d.numKeypoints;++N){var I=d.keypointCoordOffset+N*d.numValuesPerKeypoint,k=void 0,A=void 0;d.reverseOutputOrder?(k=Yn(rt(u,[0,I],[-1,1])),A=Yn(rt(u,[0,I+1],[-1,1]))):(A=Yn(rt(u,[0,I],[-1,1])),k=Yn(rt(u,[0,I+1],[-1,1])));var R=ue(L(Ee(k,d.xScale),c.w),c.x),F=ue(L(Ee(A,d.yScale),c.h),c.y);x=_n([x,V(R,[d.numBoxes,1]),V(F,[d.numBoxes,1])],1)}return x}),i=H(function(){var u=r;return e.sigmoidScore?(null!=e.scoreClippingThresh&&(u=Ts(r,-e.scoreClippingThresh,e.scoreClippingThresh)),u=ci(u)):u}),[4,rNe(o,i,e)];case 1:return a=l.sent(),ut([o,i]),[2,a]}var u,c,d})})}function rNe(n,t,e){return Da(this,void 0,void 0,function(){var r,s,o,i,a,l,u,c,d,h,f;return ka(this,function(g){switch(g.label){case 0:return r=[],[4,n.data()];case 1:return s=g.sent(),[4,t.data()];case 2:for(o=g.sent(),i=0;i<e.numBoxes;++i)if(!(null!=e.minScoreThresh&&o[i]<e.minScoreThresh||(a=i*e.numCoords,l=sNe(s[a+0],s[a+1],s[a+2],s[a+3],o[i],e.flipVertically,i),(u=l.locationData.relativeBoundingBox).width<0||u.height<0))){if(e.numKeypoints>0)for((c=l.locationData).relativeKeypoints=[],d=e.numKeypoints*e.numValuesPerKeypoint,h=0;h<d;h+=e.numValuesPerKeypoint)c.relativeKeypoints.push({x:s[(f=a+e.keypointCoordOffset+h)+0],y:e.flipVertically?1-s[f+1]:s[f+1]});r.push(l)}return[2,r]}})})}function sNe(n,t,e,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:t,yMin:o?1-e:n,xMax:r,yMax:o?1-n:e,width:r-t,height:e-n}}}}var zb,oNe={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:4,minScale:.1484375,maxScale:.75,inputSizeHeight:128,inputSizeWidth:128,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,16,16],aspectRatios:[1],fixedAnchorSize:!0},iNe={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:0,featureMapHeight:[],featureMapWidth:[],numLayers:1,minScale:.1484375,maxScale:.75,inputSizeHeight:192,inputSizeWidth:192,anchorOffsetX:.5,anchorOffsetY:.5,strides:[4],aspectRatios:[1],fixedAnchorSize:!0},qI={runtime:"tfjs",modelType:"short",maxFaces:1,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"},aNe={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:896,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:128,yScale:128,hScale:128,wScale:128,minScoreThresh:.5},lNe={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2304,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:192,yScale:192,hScale:192,wScale:192,minScoreThresh:.6},cNe={outputTensorSize:{width:128,height:128},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},dNe={outputTensorSize:{width:192,height:192},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},hNe=function(){function n(t,e,r){this.detectorModel=e,this.maxFaces=r,"full"===t?(this.imageToTensorConfig=dNe,this.tensorsToDetectionConfig=lNe,this.anchors=oz(iNe)):(this.imageToTensorConfig=cNe,this.tensorsToDetectionConfig=aNe,this.anchors=oz(oNe));var s=Qn(this.anchors.map(function(l){return l.width})),o=Qn(this.anchors.map(function(l){return l.height})),i=Qn(this.anchors.map(function(l){return l.xCenter})),a=Qn(this.anchors.map(function(l){return l.yCenter}));this.anchorTensor={x:i,y:a,w:s,h:o}}return n.prototype.dispose=function(){this.detectorModel.dispose(),ut([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},n.prototype.reset=function(){},n.prototype.detectFaces=function(t,e){return void 0===e&&(e=!1),Da(this,void 0,void 0,function(){var r,s,o,i,a,l,u,c,d,h,f;return ka(this,function(p){switch(p.label){case 0:return null==t?(this.reset(),[2,[]]):(r=H(function(){var g=Ce(sz(t),"float32");return e&&(g=Yn(Ur.flipLeftRight(zr(g,0)),[0])),g}),s=function QSe(n,t,e){var h,f,r=t.outputTensorSize,s=t.keepAspectRatio,o=t.borderMode,i=t.outputTensorFloatRange,a=rz(n),l=(h=a,(f=e)?{xCenter:f.xCenter*h.width,yCenter:f.yCenter*h.height,width:f.width*h.width,height:f.height*h.height,rotation:f.rotation}:{xCenter:.5*h.width,yCenter:.5*h.height,width:h.width,height:h.height,rotation:0}),u=function(h,f,p){if(void 0===p&&(p=!1),!p)return{top:0,left:0,right:0,bottom:0};var g=f.height,m=f.width;GI(f,"targetSize"),GI(h,"roi");var y,v,w=g/m,x=h.height/h.width,N=0,I=0;return w>x?(y=h.width,v=h.width*w,I=(1-x/w)/2):(y=h.height/w,v=h.height,N=(1-w/x)/2),h.width=y,h.height=v,{top:I,left:N,right:N,bottom:I}}(l,r,s),c=function ZSe(n,t,e,r){var s=n.width,o=n.height,i=r?-1:1,a=Math.cos(n.rotation),l=Math.sin(n.rotation),u=n.xCenter,c=n.yCenter,d=1/t,h=1/e,f=new Array(16);return f[0]=s*a*i*d,f[1]=-o*l*d,f[2]=0,f[3]=(-.5*s*a*i+.5*o*l+u)*d,f[4]=s*l*i*h,f[5]=o*a*h,f[6]=0,f[7]=(-.5*o*a-.5*s*l*i+c)*h,f[8]=0,f[9]=0,f[10]=s*d,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,function(p){if(16!==p.length)throw new Error("Array length must be 16 but got ".concat(p.length));return[[p[0],p[1],p[2],p[3]],[p[4],p[5],p[6],p[7]],[p[8],p[9],p[10],p[11]],[p[12],p[13],p[14],p[15]]]}(f)}(l,a.width,a.height,!1),d=H(function(){var m,y,v,h=sz(n),f=Pi((m=c,y=a,GI(v=r,"inputResolution"),[1/v.width*m[0][0]*y.width,1/v.height*m[0][1]*y.width,m[0][3]*y.width,1/v.width*m[1][0]*y.height,1/v.height*m[1][1]*y.height,m[1][3]*y.height,0,0]),[1,8]),p="zero"===o?"constant":"nearest",g=Ur.transform(zr(Ce(h,"float32")),f,"bilinear",p,0,[r.height,r.width]);return null!=i?function YSe(n,t){var o,u,e={scale:u=(t[1]-(o=t[0]))/255,offset:o-0*u};return H(function(){return ue(L(n,e.scale),e.offset)})}(g,i):g});return{imageTensor:d,padding:u,transformationMatrix:c}}(r,this.imageToTensorConfig),i=s.transformationMatrix,a=this.detectorModel.execute(o=s.imageTensor,"Identity:0"),l=function eNe(n){return H(function(){var s,t=(s=n,H(function(){return[rt(s,[0,0,0],[1,-1,1]),rt(s,[0,0,1],[1,-1,-1])]})),e=t[0];return{boxes:Yn(t[1]),logits:Yn(e)}})}(a),[4,nNe([c=l.logits,u=l.boxes],this.anchorTensor,this.tensorsToDetectionConfig)]);case 1:return 0===(d=p.sent()).length?(ut([r,o,a,c,u]),[2,d]):[4,tNe(d,this.maxFaces,.3)];case 2:return h=p.sent(),f=function(g,m){void 0===g&&(g=[]);var v=[].concat.apply([],m);return g.forEach(function(w){var x=w.locationData;x.relativeKeypoints.forEach(function(F){var U=az(v,[F.x,F.y]),K=U[1];F.x=U[0],F.y=K});var N=x.relativeBoundingBox,I=Number.MAX_VALUE,k=Number.MAX_VALUE,A=Number.MIN_VALUE,R=Number.MIN_VALUE;[[N.xMin,N.yMin],[N.xMin+N.width,N.yMin],[N.xMin+N.width,N.yMin+N.height],[N.xMin,N.yMin+N.height]].forEach(function(F){var U=az(v,F),q=U[0],K=U[1];I=Math.min(I,q),A=Math.max(A,q),k=Math.min(k,K),R=Math.max(R,K)}),x.relativeBoundingBox={xMin:I,xMax:A,yMin:k,yMax:R,width:A-I,height:R-k}}),g}(h,i),ut([r,o,a,c,u]),[2,f]}})})},n.prototype.estimateFaces=function(t,e){return Da(this,void 0,void 0,function(){var r;return ka(this,function(o){return r=rz(t),[2,this.detectFaces(t,!!e&&e.flipHorizontal).then(function(i){return i.map(function(a){for(var l=a.locationData.relativeKeypoints.map(function(p,g){return Al(Al({},p),{x:p.x*r.width,y:p.y*r.height,name:nz[g]})}),u=a.locationData.relativeBoundingBox,c=0,d=["width","xMax","xMin"];c<d.length;c++)u[d[c]]*=r.width;for(var h=0,f=["height","yMax","yMin"];h<f.length;h++)u[f[h]]*=r.height;return{keypoints:l,box:u}})})]})})},n}();function fNe(n){return Da(this,void 0,void 0,function(){var t,e,r;return ka(this,function(s){switch(s.label){case 0:return t=function(o){if(null==o)return Al({},qI);var i=Al({},o);return null==i.modelType&&(i.modelType=qI.modelType),null==i.maxFaces&&(i.maxFaces=qI.maxFaces),null==i.detectorModelUrl&&(i.detectorModelUrl="full"===i.modelType?"https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1":"https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"),i}(n),e="string"==typeof t.detectorModelUrl&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,[4,GT(t.detectorModelUrl,{fromTFHub:e})];case 1:return r=s.sent(),[2,new hNe(t.modelType,r,t.maxFaces)]}})})}(zb||(zb={})).MediaPipeFaceDetector="MediaPipeFaceDetector";class um{isModelReady;_isModelReady$;_model=zb.MediaPipeFaceDetector;_detectorConfig={runtime:"tfjs",maxFaces:1,modelType:"short"};_detector=null;_estimationConfig={flipHorizontal:!1};constructor(){this._isModelReady$=new Ki(!1),this.isModelReady=this._isModelReady$.asObservable(),this._initializefaceDetector().then(()=>{this._isModelReady$.next(!0)})}_initializefaceDetector(){var t=this;return J(function*(){t._detector=yield function pNe(n,t){return Da(this,void 0,void 0,function(){var e,r;return ka(this,function(s){if(n===zb.MediaPipeFaceDetector){if(r=void 0,null!=(e=t)){if("tfjs"===e.runtime)return[2,fNe(e)];if("mediapipe"===e.runtime)return[2,JSe(e)];r=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r))}throw new Error("".concat(n," is not a supported model name."))})})}(t._model,t._detectorConfig)})()}detect(t){var e=this;return J(function*(){return e._detector?yield e._detector.estimateFaces(t,e._estimationConfig):[]})()}static \u0275fac=function(e){return new(e||um)};static \u0275prov=Qe({token:um,factory:um.\u0275fac,providedIn:"root"})}class lz{}class uz{}class Aa{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(e=>{const r=e.indexOf(":");if(r>0){const s=e.slice(0,r),o=s.toLowerCase(),i=e.slice(r+1).trim();this.maybeSetNormalizedName(s,o),this.headers.has(o)?this.headers.get(o).push(i):this.headers.set(o,[i])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let r=t[e];const s=e.toLowerCase();"string"==typeof r&&(r=[r]),r.length>0&&(this.headers.set(s,r),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof Aa?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new Aa;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof Aa?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let r=t.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...r),this.headers.set(e,s);break;case"d":const o=t.value;if(o){let i=this.headers.get(e);if(!i)return;i=i.filter(a=>-1===o.indexOf(a)),0===i.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,i)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class yNe{encodeKey(t){return cz(t)}encodeValue(t){return cz(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}const vNe=/%(\d[a-f0-9])/gi,wNe={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function cz(n){return encodeURIComponent(n).replace(vNe,(t,e)=>wNe[e]??t)}function Ub(n){return`${n}`}class Rl{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new yNe,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function bNe(n,t){const e=new Map;return n.length>0&&n.replace(/^\?/,"").split("&").forEach(s=>{const o=s.indexOf("="),[i,a]=-1==o?[t.decodeKey(s),""]:[t.decodeKey(s.slice(0,o)),t.decodeValue(s.slice(o+1))],l=e.get(i)||[];l.push(a),e.set(i,l)}),e}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const r=t.fromObject[e],s=Array.isArray(r)?r.map(Ub):[Ub(r)];this.map.set(e,s)})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(r=>{const s=t[r];Array.isArray(s)?s.forEach(o=>{e.push({param:r,value:o,op:"a"})}):e.push({param:r,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(r=>e+"="+this.encoder.encodeValue(r)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new Rl({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(Ub(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let r=this.map.get(t.param)||[];const s=r.indexOf(Ub(t.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(t.param,r):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class xNe{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}has(t){return this.map.has(t)}keys(){return this.map.keys()}}function dz(n){return typeof ArrayBuffer<"u"&&n instanceof ArrayBuffer}function hz(n){return typeof Blob<"u"&&n instanceof Blob}function fz(n){return typeof FormData<"u"&&n instanceof FormData}class cm{constructor(t,e,r,s){let o;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function CNe(n){switch(n){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,o=s):o=r,o&&(this.reportProgress=!!o.reportProgress,this.withCredentials=!!o.withCredentials,o.responseType&&(this.responseType=o.responseType),o.headers&&(this.headers=o.headers),o.context&&(this.context=o.context),o.params&&(this.params=o.params)),this.headers||(this.headers=new Aa),this.context||(this.context=new xNe),this.params){const i=this.params.toString();if(0===i.length)this.urlWithParams=e;else{const a=e.indexOf("?");this.urlWithParams=e+(-1===a?"?":a<e.length-1?"&":"")+i}}else this.params=new Rl,this.urlWithParams=e}serializeBody(){return null===this.body?null:dz(this.body)||hz(this.body)||fz(this.body)||function SNe(n){return typeof URLSearchParams<"u"&&n instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof Rl?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||fz(this.body)?null:hz(this.body)?this.body.type||null:dz(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof Rl?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){const e=t.method||this.method,r=t.url||this.url,s=t.responseType||this.responseType,o=void 0!==t.body?t.body:this.body,i=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,a=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let l=t.headers||this.headers,u=t.params||this.params;const c=t.context??this.context;return void 0!==t.setHeaders&&(l=Object.keys(t.setHeaders).reduce((d,h)=>d.set(h,t.setHeaders[h]),l)),t.setParams&&(u=Object.keys(t.setParams).reduce((d,h)=>d.set(h,t.setParams[h]),u)),new cm(e,r,o,{params:u,headers:l,context:c,reportProgress:a,responseType:s,withCredentials:i})}}var xr=(()=>((xr=xr||{})[xr.Sent=0]="Sent",xr[xr.UploadProgress=1]="UploadProgress",xr[xr.ResponseHeader=2]="ResponseHeader",xr[xr.DownloadProgress=3]="DownloadProgress",xr[xr.Response=4]="Response",xr[xr.User=5]="User",xr))();class KI{constructor(t,e=200,r="OK"){this.headers=t.headers||new Aa,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||r,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class XI extends KI{constructor(t={}){super(t),this.type=xr.ResponseHeader}clone(t={}){return new XI({headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class Wb extends KI{constructor(t={}){super(t),this.type=xr.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new Wb({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class pz extends KI{constructor(t){super(t,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${t.url||"(unknown url)"}`:`Http failure response for ${t.url||"(unknown url)"}: ${t.status} ${t.statusText}`,this.error=t.error||null}}function JI(n,t){return{body:t,headers:n.headers,context:n.context,observe:n.observe,params:n.params,reportProgress:n.reportProgress,responseType:n.responseType,withCredentials:n.withCredentials}}let mz=(()=>{class n{constructor(e){this.handler=e}request(e,r,s={}){let o;if(e instanceof cm)o=e;else{let l,u;l=s.headers instanceof Aa?s.headers:new Aa(s.headers),s.params&&(u=s.params instanceof Rl?s.params:new Rl({fromObject:s.params})),o=new cm(e,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:u,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials})}const i=function mNe(...n){return Gl(n,ah(n))}(o).pipe(function gNe(n,t){return Ne(t)?jl(n,t,1):jl(n,1)}(l=>this.handler.handle(l)));if(e instanceof cm||"events"===s.observe)return i;const a=i.pipe(Eb(l=>l instanceof Wb));switch(s.observe||"body"){case"body":switch(o.responseType){case"arraybuffer":return a.pipe(Si(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(Si(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(Si(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(Si(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(e,r={}){return this.request("DELETE",e,r)}get(e,r={}){return this.request("GET",e,r)}head(e,r={}){return this.request("HEAD",e,r)}jsonp(e,r){return this.request("JSONP",e,{params:(new Rl).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,r={}){return this.request("OPTIONS",e,r)}patch(e,r,s={}){return this.request("PATCH",e,JI(s,r))}post(e,r,s={}){return this.request("POST",e,JI(s,r))}put(e,r,s={}){return this.request("PUT",e,JI(s,r))}}return n.\u0275fac=function(e){return new(e||n)(Nt(lz))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();class gz{constructor(t,e){this.next=t,this.interceptor=e}handle(t){return this.interceptor.intercept(t,this.next)}}const yz=new dt("HTTP_INTERCEPTORS");let NNe=(()=>{class n{intercept(e,r){return r.handle(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();const TNe=/^\)\]\}',?\n/;let bz=(()=>{class n{constructor(e){this.xhrFactory=e}handle(e){if("JSONP"===e.method)throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");return new Gn(r=>{const s=this.xhrFactory.build();if(s.open(e.method,e.urlWithParams),e.withCredentials&&(s.withCredentials=!0),e.headers.forEach((f,p)=>s.setRequestHeader(f,p.join(","))),e.headers.has("Accept")||s.setRequestHeader("Accept","application/json, text/plain, */*"),!e.headers.has("Content-Type")){const f=e.detectContentTypeHeader();null!==f&&s.setRequestHeader("Content-Type",f)}if(e.responseType){const f=e.responseType.toLowerCase();s.responseType="json"!==f?f:"text"}const o=e.serializeBody();let i=null;const a=()=>{if(null!==i)return i;const f=s.statusText||"OK",p=new Aa(s.getAllResponseHeaders()),g=function INe(n){return"responseURL"in n&&n.responseURL?n.responseURL:/^X-Request-URL:/m.test(n.getAllResponseHeaders())?n.getResponseHeader("X-Request-URL"):null}(s)||e.url;return i=new XI({headers:p,status:s.status,statusText:f,url:g}),i},l=()=>{let{headers:f,status:p,statusText:g,url:m}=a(),y=null;204!==p&&(y=typeof s.response>"u"?s.responseText:s.response),0===p&&(p=y?200:0);let v=p>=200&&p<300;if("json"===e.responseType&&"string"==typeof y){const w=y;y=y.replace(TNe,"");try{y=""!==y?JSON.parse(y):null}catch(x){y=w,v&&(v=!1,y={error:x,text:y})}}v?(r.next(new Wb({body:y,headers:f,status:p,statusText:g,url:m||void 0})),r.complete()):r.error(new pz({error:y,headers:f,status:p,statusText:g,url:m||void 0}))},u=f=>{const{url:p}=a(),g=new pz({error:f,status:s.status||0,statusText:s.statusText||"Unknown Error",url:p||void 0});r.error(g)};let c=!1;const d=f=>{c||(r.next(a()),c=!0);let p={type:xr.DownloadProgress,loaded:f.loaded};f.lengthComputable&&(p.total=f.total),"text"===e.responseType&&!!s.responseText&&(p.partialText=s.responseText),r.next(p)},h=f=>{let p={type:xr.UploadProgress,loaded:f.loaded};f.lengthComputable&&(p.total=f.total),r.next(p)};return s.addEventListener("load",l),s.addEventListener("error",u),s.addEventListener("timeout",u),s.addEventListener("abort",u),e.reportProgress&&(s.addEventListener("progress",d),null!==o&&s.upload&&s.upload.addEventListener("progress",h)),s.send(o),r.next({type:xr.Sent}),()=>{s.removeEventListener("error",u),s.removeEventListener("abort",u),s.removeEventListener("load",l),s.removeEventListener("timeout",u),e.reportProgress&&(s.removeEventListener("progress",d),null!==o&&s.upload&&s.upload.removeEventListener("progress",h)),s.readyState!==s.DONE&&s.abort()}})}}return n.\u0275fac=function(e){return new(e||n)(Nt(M3))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})();const ZI=new dt("XSRF_COOKIE_NAME"),YI=new dt("XSRF_HEADER_NAME");class vz{}let _Ne=(()=>{class n{constructor(e,r,s){this.doc=e,this.platform=r,this.cookieName=s,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const e=this.doc.cookie||"";return e!==this.lastCookieString&&(this.parseCount++,this.lastToken=S3(e,this.cookieName),this.lastCookieString=e),this.lastToken}}return n.\u0275fac=function(e){return new(e||n)(Nt(To),Nt(Vx),Nt(ZI))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})(),QI=(()=>{class n{constructor(e,r){this.tokenService=e,this.headerName=r}intercept(e,r){const s=e.url.toLowerCase();if("GET"===e.method||"HEAD"===e.method||s.startsWith("http://")||s.startsWith("https://"))return r.handle(e);const o=this.tokenService.getToken();return null!==o&&!e.headers.has(this.headerName)&&(e=e.clone({headers:e.headers.set(this.headerName,o)})),r.handle(e)}}return n.\u0275fac=function(e){return new(e||n)(Nt(vz),Nt(YI))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})(),ENe=(()=>{class n{constructor(e,r){this.backend=e,this.injector=r,this.chain=null}handle(e){if(null===this.chain){const r=this.injector.get(yz,[]);this.chain=r.reduceRight((s,o)=>new gz(s,o),this.backend)}return this.chain.handle(e)}}return n.\u0275fac=function(e){return new(e||n)(Nt(uz),Nt(oa))},n.\u0275prov=Qe({token:n,factory:n.\u0275fac}),n})(),DNe=(()=>{class n{static disable(){return{ngModule:n,providers:[{provide:QI,useClass:NNe}]}}static withOptions(e={}){return{ngModule:n,providers:[e.cookieName?{provide:ZI,useValue:e.cookieName}:[],e.headerName?{provide:YI,useValue:e.headerName}:[]]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({providers:[QI,{provide:yz,useExisting:QI,multi:!0},{provide:vz,useClass:_Ne},{provide:ZI,useValue:"XSRF-TOKEN"},{provide:YI,useValue:"X-XSRF-TOKEN"}]}),n})(),kNe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({providers:[mz,{provide:lz,useClass:ENe},bz,{provide:uz,useExisting:bz}],imports:[DNe.withOptions({cookieName:"XSRF-TOKEN",headerName:"X-XSRF-TOKEN"})]}),n})();class dm{_httpClient;isModelReady;classArray=[];_isModelReady$;_baseModel;_model;_trainingData={outputs:[],inputs:[]};_classIndex={};constructor(t){this._httpClient=t,this._isModelReady$=new Ki(!1),this.isModelReady=this._isModelReady$.asObservable(),this._loadMobileNetFeatureModel().then(()=>{this._isModelReady$.next(!0)})}get datasetStatus(){return{total:this._trainingData.outputs.length,class:Object.keys(this._classIndex).sort((t,e)=>this._classIndex[t]-this._classIndex[e]),trainingData:this._trainingData}}_loadMobileNetFeatureModel(){var t=this;return J(function*(){t._baseModel=yield GT("https://tfhub.dev/google/tfjs-model/imagenet/mobilenet_v3_small_100_224/feature_vector/5/default/1",{fromTFHub:!0,onProgress:function(r){console.log(r)}}),H(()=>{let r=t._baseModel.predict(ar([1,224,224,3]));console.log("============== Warm up... "),console.log(r.shape)}),console.log("============== Loaded MobileNet successfully...")})()}_initialVGG16Cnn(){const t=vT({name:"vgg16-sequential"});return t.add(this._conv2d(64,"block1_conv2")),t.add(this._maxPool2d("block1_pool")),t.add(this._conv2d(128,"block2_conv1")),t.add(this._conv2d(128,"block2_conv2")),t.add(this._maxPool2d("block2_pool")),t.add(this._conv2d(256,"block3_conv1")),t.add(this._conv2d(256,"block3_conv2")),t.add(this._conv2d(256,"block3_conv3")),t.add(this._maxPool2d("block3_pool")),t.add(this._conv2d(512,"block4_conv1")),t.add(this._conv2d(512,"block4_conv2")),t.add(this._conv2d(512,"block4_conv3")),t.add(this._maxPool2d("block4_pool")),t.add(this._conv2d(512,"block5_conv1")),t.add(this._conv2d(512,"block5_conv2")),t.add(this._conv2d(512,"block5_conv3")),t.add(this._maxPool2d("block5_pool")),t.add(function Hie(n){return new U4(n)}({name:"flatten"})),t.add(Bp({units:4096,activation:"relu",name:"fc1"})),t.add(Bp({units:4096,activation:"relu",name:"fc2"})),t.compile({optimizer:"adam",loss:"binaryCrossentropy",metrics:["accuracy"]}),t}_conv2d(t,e,r){let s={filters:t,kernelSize:[3,3],padding:"same",activation:"relu",name:e};return r&&(s.inputShape=r),function Wie(n){return new TT(n)}(s)}_maxPool2d(t){return function Kie(n){return new aL(n)}({poolSize:[2,2],name:t,strides:[2,2]})}_initialHeaderModel(t){this._model=vT(),this._model.add(Bp({inputShape:[1024],units:128,activation:"relu"})),this._model.add(Bp({units:t,activation:"softmax"})),console.log("============== Header model initial..."),this._model.summary(),this._model.compile({optimizer:"adam",loss:2===t?"binaryCrossentropy":"categoricalCrossentropy",metrics:["accuracy"]}),console.log("============== Header model compiled...")}_saveToLocalStorage(){var t=this;return J(function*(){console.log(t.classArray);let e=[];for(let l=0;l<t._trainingData.inputs.length;l++){const u=t._trainingData.inputs[l],c=yield u.data(),d=Array.from(c),h=JSON.stringify({data:d,shape:u.shape,dtype:u.dtype});e.push(h)}const s="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify({inputData:e,outputData:t._trainingData.outputs,class:t.classArray})),o=document.createElement("a");var i=document.createElement("a");o.href=s,o.target="_blank",o.download=`training_data_${(new Date).getTime()}.json`,i.setAttribute("href",s),i.setAttribute("download",`training_data_${(new Date).getTime()}.json`);let a=new MouseEvent("click");o.dispatchEvent(a),console.log("============== Save data successfully")})()}gatherData(t,e,r){let s=-1;if(!this._classIndex.hasOwnProperty(t)){console.log(`Add ${t}`);const o=Object.keys(this._classIndex).length;this._classIndex[t]=o}if(s=typeof this._classIndex[t]<"u"?this._classIndex[t]:-1,s>=0){let o=H(()=>{let i=U0(e),l=Ur.resizeBilinear(i,[224,224],!0).div(255);return this._baseModel.predict(l.expandDims()).squeeze()});this._trainingData.inputs.push(o),this._trainingData.outputs.push(s)}r&&r()}trainData(t=!0,e){var r=this;return J(function*(){console.log("============== Start training...");const s=Object.keys(r._classIndex).length;if(s<2)return console.log(`Number of class is not enougth (${s})`),void(e&&e());r._initialHeaderModel(s),function EK(n,t){if(n.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${t.length}`);let e=n.length,r=0;for(;e>0;)r=Math.random()*e|0,e--,Qa(n,e,r),Qa(t,e,r)}(r._trainingData.inputs,r._trainingData.outputs);let o=Qn(r._trainingData.outputs,"int32"),i=r1(o,s),a=_s(r._trainingData.inputs),l=yield r._model.fit(a,i,{shuffle:!0,batchSize:5,epochs:10,callbacks:{onEpochEnd:(u,c)=>{console.log("Data for epoch "+u,c)}}});console.log(l),o.dispose(),i.dispose(),a.dispose(),r.classArray=r.datasetStatus.class,t&&r._saveToLocalStorage(),e&&e()})()}predict(t,e){H(()=>{let r=U0(t).div(255),s=Ur.resizeBilinear(r,[224,224],!0),o=this._baseModel.predict(s.expandDims()),i=this._model.predict(o).squeeze(),a=i.argMax().arraySync(),l=i.arraySync();const u=this.classArray[a],c=Math.floor(100*l[a]);console.log(`Prediction: ${u} with ${c}% confidence'`),e&&e(u,c)})}reset(t){this.classArray=[],this._classIndex={},this._model=null,this._trainingData.inputs=[],this._trainingData.outputs=[],t&&t()}loadSavedData(t){if(t){const e=JSON.parse(t);return this.classArray=[...e.class],this._classIndex=this.classArray.reduce((r,s,o)=>({...r,[s]:o}),{}),this._trainingData.outputs=[...e.outputData],this._trainingData.inputs=[...e.inputData.map(r=>{const s=JSON.parse(r);return ko(s.data,s.shape,s.dtype)})],console.log(this.classArray,this._trainingData),console.log("============== Loaded Dataset successfully..."),!0}return!1}exportDataset(){this._saveToLocalStorage()}static \u0275fac=function(e){return new(e||dm)(Nt(mz))};static \u0275prov=Qe({token:dm,factory:dm.\u0275fac,providedIn:"root"})}const ANe=["container"],RNe=["videoStream"],ONe=["objectDetection"];function FNe(n,t){if(1&n&&(pn(0,"div",13)(1,"div",14),ua(2,"div",15),Zt()()),2&n){const e=ni();sr(2),mx("width",e.loadingModelStatus.progress,"%")}}function MNe(n,t){1&n&&(pn(0,"p",16)(1,"span",17),_r(2,"\u2714"),Zt(),_r(3," Helmet"),Zt())}function PNe(n,t){1&n&&(pn(0,"p",16)(1,"span",17),_r(2,"\u2714"),Zt(),_r(3," Vest"),Zt())}function LNe(n,t){1&n&&(pn(0,"div",18)(1,"p"),_r(2,"PASS"),Zt()())}class Hb{_doc;_webCameraService;_tfModelService;loadingModelStatus={loading:!1,progress:0};isHelmetDetected=!1;isVestDetected=!1;_container={};_videoStream={};_objectDetection={};_videoElement=null;_lastPerformance=0;_unsubscribeAll$;_freeze=!1;constructor(t,e,r){this._doc=t,this._webCameraService=e,this._tfModelService=r,this._unsubscribeAll$=new Go}ngOnInit(){this._tfModelService.loadingModelProgress.pipe(PB(this._unsubscribeAll$)).subscribe(t=>{this.loadingModelStatus={loading:t.loading,progress:100*t.progress}}),this._tfModelService.objectDetectStatus.pipe(PB(this._unsubscribeAll$)).subscribe(t=>{const e=new Set(t);this.isHelmetDetected=e.has("Hemlet")&&!e.has("Head"),this.isVestDetected=e.has("Vest"),this.isVestDetected&&this.isHelmetDetected&&(this._freeze=!0,setTimeout(()=>{this._freeze=!1},2e3))}),this._tfModelService.loadTFModel("assets/models/best_web_model/model.json")}ngOnDestroy(){this._unsubscribeAll$.next(null),this._unsubscribeAll$.complete()}_streaming(){const t=performance.now(),e=this._videoStream.nativeElement,r=e.getContext("2d");if(r&&this._videoElement)if(this._freeze)requestAnimationFrame(()=>this._streaming());else{r.clearRect(0,0,e.width,e.height),r.drawImage(this._videoElement,0,0,e.width,e.height);let s=Math.floor(this._lastPerformance?1e3/(t-this._lastPerformance):0);this._lastPerformance=t,r.font="16px Georgia",r.fillText(`FPS: ${s.toString()}`,e.width-80,e.height-20),this._tfModelService.currentModel.pipe(Eb(o=>null!=o),EI(1)).subscribe(o=>{this._tfModelService.detectHelmetVest(e,o,this._objectDetection.nativeElement,()=>{requestAnimationFrame(()=>this._streaming())})})}}_clearCanvas(t){const e=t.nativeElement,r=e.getContext("2d");r&&r.clearRect(0,0,e.width,e.height),e.width=0,e.height=0}startStreaming(){if(this._videoElement)return;this._webCameraService.currentSream.pipe(Eb(s=>null!=s),EI(1)).subscribe({next:s=>{this._videoElement=this._doc.createElement("video"),this._videoElement.autoplay=!0,this._videoElement.srcObject=s,this._videoElement.addEventListener("loadeddata",()=>{if(this._videoElement){const o=this._videoStream.nativeElement;o.width=this._videoElement.videoWidth,o.height=this._videoElement.videoHeight;const i=this._objectDetection.nativeElement;i.width=this._videoElement.videoWidth,i.height=this._videoElement.videoHeight,this._streaming()}})}});const t=this._container.nativeElement;this._webCameraService.startCamera(t.clientHeight,t.clientWidth)}stopStreaming(){this._clearCanvas(this._videoStream),this._clearCanvas(this._objectDetection),this._videoElement=null,this._webCameraService.stopCamera()}static \u0275fac=function(e){return new(e||Hb)(be(To),be(Wd),be(lm))};static \u0275cmp=gh({type:Hb,selectors:[["view-port"]],viewQuery:function(e,r){if(1&e&&(Xa(ANe,5),Xa(RNe,5),Xa(ONe,5)),2&e){let s;Ka(s=Ja())&&(r._container=s.first),Ka(s=Ja())&&(r._videoStream=s.first),Ka(s=Ja())&&(r._objectDetection=s.first)}},decls:16,vars:6,consts:[[1,"view-port"],["container",""],["id","video-stream"],["videoStream",""],["id","object-detection"],["objectDetection",""],[1,"tool-bar"],["type","button",1,"control-button","primary",3,"disabled","click"],["type","button",1,"control-button","secondary",3,"disabled","click"],["class","loading-bar-container",4,"ngIf"],[1,"status-bar"],["class","status verified",4,"ngIf"],["class","pass-cover",4,"ngIf"],[1,"loading-bar-container"],[1,"loading-bar"],[1,"progress"],[1,"status","verified"],[1,"icon"],[1,"pass-cover"]],template:function(e,r){1&e&&(pn(0,"div",0,1),ua(2,"canvas",2,3)(4,"canvas",4,5),pn(6,"div",6)(7,"button",7),zn("click",function(){return r.startStreaming()}),_r(8,"Start"),Zt(),pn(9,"button",8),zn("click",function(){return r.stopStreaming()}),_r(10,"Stop"),Zt()(),ti(11,FNe,3,2,"div",9),pn(12,"div",10),ti(13,MNe,4,0,"p",11),ti(14,PNe,4,0,"p",11),Zt(),ti(15,LNe,3,0,"div",12),Zt()),2&e&&(sr(7),Tr("disabled",r.loadingModelStatus.loading),sr(2),Tr("disabled",r.loadingModelStatus.loading),sr(2),Tr("ngIf",r.loadingModelStatus.loading),sr(2),Tr("ngIf",r.isHelmetDetected),sr(1),Tr("ngIf",r.isVestDetected),sr(1),Tr("ngIf",r.isHelmetDetected&&r.isVestDetected))},dependencies:[uC],styles:[".view-port[_ngcontent-%COMP%]{max-width:640px;width:min(90vh - 16.142rem,100%);margin:auto;background:#000;position:relative;aspect-ratio:1/1}.view-port[_ngcontent-%COMP%]   canvas#video-stream[_ngcontent-%COMP%]{z-index:50}.view-port[_ngcontent-%COMP%]   canvas#object-detection[_ngcontent-%COMP%]{z-index:75;position:absolute;top:0;left:0}.view-port[_ngcontent-%COMP%]   .tool-bar[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:60px;z-index:100;display:flex;justify-content:center;align-items:center}.view-port[_ngcontent-%COMP%]   .loading-bar-container[_ngcontent-%COMP%]{position:absolute;bottom:0;left:0;width:100%;z-index:100}.view-port[_ngcontent-%COMP%]   .loading-bar-container[_ngcontent-%COMP%]   .loading-bar[_ngcontent-%COMP%]{width:100%;height:6px;background-color:#e4e4e4;position:relative}.view-port[_ngcontent-%COMP%]   .loading-bar-container[_ngcontent-%COMP%]   .loading-bar[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{height:6px;background-color:#9292d9;position:absolute;top:0;left:0;z-index:120;transition:width .5s linear!important}.view-port[_ngcontent-%COMP%]   .status-bar[_ngcontent-%COMP%]{position:absolute;top:0;right:0;width:20%;height:60px;z-index:100}.view-port[_ngcontent-%COMP%]   .status-bar[_ngcontent-%COMP%]   p.status[_ngcontent-%COMP%]{text-align:right;padding:5px}.view-port[_ngcontent-%COMP%]   .status-bar[_ngcontent-%COMP%]   p.status.verified[_ngcontent-%COMP%]{color:#66cda3}.view-port[_ngcontent-%COMP%]   .pass-cover[_ngcontent-%COMP%]{position:absolute;top:0;right:0;width:100%;height:100%;z-index:150;background:rgba(102,205,163,.3803921569);display:flex;align-items:center;justify-content:center}.view-port[_ngcontent-%COMP%]   .pass-cover[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#66cda3;font-size:4rem;font-weight:600;font-family:cursive}"]})}const{isArray:$Ne}=Array,{getPrototypeOf:VNe,prototype:BNe,keys:zNe}=Object;function wz(n){if(1===n.length){const t=n[0];if($Ne(t))return{args:t,keys:null};if(function UNe(n){return n&&"object"==typeof n&&VNe(n)===BNe}(t)){const e=zNe(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:WNe}=Array;function xz(n){return Si(t=>function HNe(n,t){return WNe(t)?n(...t):n(t)}(n,t))}function Cz(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}function Sz(n,t,e){n?wo(e,n,t):t()}let Nz=(()=>{class n{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=s=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return n.\u0275fac=function(e){return new(e||n)(be(nu),be(Yo))},n.\u0275dir=yt({type:n}),n})(),Hu=(()=>{class n extends Nz{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=es(n)))(r||n)}}(),n.\u0275dir=yt({type:n,features:[sn]}),n})();const Xi=new dt("NgValueAccessor"),XNe={provide:Xi,useExisting:un(()=>jb),multi:!0},ZNe=new dt("CompositionEventMode");let jb=(()=>{class n extends Nz{constructor(e,r,s){super(e,r),this._compositionMode=s,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function JNe(){const n=uu()?uu().getUserAgent():"";return/android (\d+)/.test(n.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return n.\u0275fac=function(e){return new(e||n)(be(nu),be(Yo),be(ZNe,8))},n.\u0275dir=yt({type:n,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,r){1&e&&zn("input",function(o){return r._handleInput(o.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(o){return r._compositionEnd(o.target.value)})},features:[Fn([XNe]),sn]}),n})();const fs=new dt("NgValidators"),Fl=new dt("NgAsyncValidators");function Mz(n){return null!=n}function Pz(n){return Ug(n)?Gl(n):n}function Lz(n){let t={};return n.forEach(e=>{t=null!=e?{...t,...e}:t}),0===Object.keys(t).length?null:t}function $z(n,t){return t.map(e=>e(n))}function Vz(n){return n.map(t=>function eTe(n){return!n.validate}(t)?t:e=>t.validate(e))}function n_(n){return null!=n?function Bz(n){if(!n)return null;const t=n.filter(Mz);return 0==t.length?null:function(e){return Lz($z(e,t))}}(Vz(n)):null}function r_(n){return null!=n?function zz(n){if(!n)return null;const t=n.filter(Mz);return 0==t.length?null:function(e){return function qNe(...n){const t=zm(n),{args:e,keys:r}=wz(n),s=new Gn(o=>{const{length:i}=e;if(!i)return void o.complete();const a=new Array(i);let l=i,u=i;for(let c=0;c<i;c++){let d=!1;Zs(e[c]).subscribe(ps(o,h=>{d||(d=!0,u--),a[c]=h},()=>l--,void 0,()=>{(!l||!d)&&(u||o.next(r?Cz(r,a):a),o.complete())}))}});return t?s.pipe(xz(t)):s}($z(e,t).map(Pz)).pipe(Si(Lz))}}(Vz(n)):null}function Uz(n,t){return null===n?[t]:Array.isArray(n)?[...n,t]:[n,t]}function s_(n){return n?Array.isArray(n)?n:[n]:[]}function qb(n,t){return Array.isArray(n)?n.includes(t):n===t}function jz(n,t){const e=s_(t);return s_(n).forEach(s=>{qb(e,s)||e.push(s)}),e}function Gz(n,t){return s_(t).filter(e=>!qb(n,e))}class qz{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=n_(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=r_(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}class As extends qz{get formDirective(){return null}get path(){return null}}class Ml extends qz{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}let o_=(()=>{class n extends class Kz{constructor(t){this._cd=t}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(be(Ml,2))},n.\u0275dir=yt({type:n,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,r){2&e&&Wg("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[sn]}),n})();const hm="VALID",Xb="INVALID",Hd="PENDING",fm="DISABLED";function Jz(n){return Array.isArray(n)?n_(n):n||null}function Zz(n){return Array.isArray(n)?r_(n):n||null}function Jb(n){return null!=n&&!Array.isArray(n)&&"object"==typeof n}function pm(n,t){(function h_(n,t){const e=function Wz(n){return n._rawValidators}(n);null!==t.validator?n.setValidators(Uz(e,t.validator)):"function"==typeof e&&n.setValidators([e]);const r=function Hz(n){return n._rawAsyncValidators}(n);null!==t.asyncValidator?n.setAsyncValidators(Uz(r,t.asyncValidator)):"function"==typeof r&&n.setAsyncValidators([r]);const s=()=>n.updateValueAndValidity();Qb(t._rawValidators,s),Qb(t._rawAsyncValidators,s)})(n,t),t.valueAccessor.writeValue(n.value),n.disabled&&t.valueAccessor.setDisabledState?.(!0),function cTe(n,t){t.valueAccessor.registerOnChange(e=>{n._pendingValue=e,n._pendingChange=!0,n._pendingDirty=!0,"change"===n.updateOn&&t6(n,t)})}(n,t),function hTe(n,t){const e=(r,s)=>{t.valueAccessor.writeValue(r),s&&t.viewToModelUpdate(r)};n.registerOnChange(e),t._registerOnDestroy(()=>{n._unregisterOnChange(e)})}(n,t),function dTe(n,t){t.valueAccessor.registerOnTouched(()=>{n._pendingTouched=!0,"blur"===n.updateOn&&n._pendingChange&&t6(n,t),"submit"!==n.updateOn&&n.markAsTouched()})}(n,t),function uTe(n,t){if(t.valueAccessor.setDisabledState){const e=r=>{t.valueAccessor.setDisabledState(r)};n.registerOnDisabledChange(e),t._registerOnDestroy(()=>{n._unregisterOnDisabledChange(e)})}}(n,t)}function Qb(n,t){n.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function t6(n,t){n._pendingDirty&&n.markAsDirty(),n.setValue(n._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(n._pendingValue),n._pendingChange=!1}function o6(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}function i6(n){return"object"==typeof n&&null!==n&&2===Object.keys(n).length&&"value"in n&&"disabled"in n}const wTe={provide:Ml,useExisting:un(()=>tv)},c6=(()=>Promise.resolve())();let tv=(()=>{class n extends Ml{constructor(e,r,s,o,i){super(),this._changeDetectorRef=i,this.control=new class extends class e6{constructor(t,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=t,this._rawAsyncValidators=e,this._composedValidatorFn=Jz(this._rawValidators),this._composedAsyncValidatorFn=Zz(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===hm}get invalid(){return this.status===Xb}get pending(){return this.status==Hd}get disabled(){return this.status===fm}get enabled(){return this.status!==fm}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._rawValidators=t,this._composedValidatorFn=Jz(t)}setAsyncValidators(t){this._rawAsyncValidators=t,this._composedAsyncValidatorFn=Zz(t)}addValidators(t){this.setValidators(jz(t,this._rawValidators))}addAsyncValidators(t){this.setAsyncValidators(jz(t,this._rawAsyncValidators))}removeValidators(t){this.setValidators(Gz(t,this._rawValidators))}removeAsyncValidators(t){this.setAsyncValidators(Gz(t,this._rawAsyncValidators))}hasValidator(t){return qb(this._rawValidators,t)}hasAsyncValidator(t){return qb(this._rawAsyncValidators,t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=Hd,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=fm,this.errors=null,this._forEachChild(r=>{r.disable({...t,onlySelf:!0})}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=hm,this._forEachChild(r=>{r.enable({...t,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}getRawValue(){return this.value}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===hm||this.status===Hd)&&this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?fm:hm}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=Hd,this._hasOwnPendingAsyncValidator=!0;const e=Pz(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){let e=t;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,s)=>r&&r._find(s),this)}getError(t,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new rs,this.statusChanges=new rs}_calculateStatus(){return this._allControlsDisabled()?fm:this.errors?Xb:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(Hd)?Hd:this._anyControlsHaveStatus(Xb)?Xb:hm}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){Jb(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(t){return null}}{constructor(t=null,e,r){super(function u_(n){return(Jb(n)?n.validators:n)||null}(e),function c_(n,t){return(Jb(t)?t.asyncValidators:n)||null}(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),Jb(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=i6(t)?t.value:t)}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=this.defaultValue,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){o6(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){o6(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){i6(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}},this._registered=!1,this.update=new rs,this._parent=e,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=function p_(n,t){if(!t)return null;let e,r,s;return Array.isArray(t),t.forEach(o=>{o.constructor===jb?e=o:function mTe(n){return Object.getPrototypeOf(n.constructor)===Hu}(o)?r=o:s=o}),s||r||e||null}(0,o)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),function f_(n,t){if(!n.hasOwnProperty("model"))return!1;const e=n.model;return!!e.isFirstChange()||!Object.is(t,e.currentValue)}(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){pm(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){c6.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,s=0!==r&&function Qx(n){return"boolean"==typeof n?n:null!=n&&"false"!==n}(r);c6.then(()=>{s&&!this.control.disabled?this.control.disable():!s&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?function Zb(n,t){return[...t.path,n]}(e,this._parent):[e]}}return n.\u0275fac=function(e){return new(e||n)(be(As,9),be(fs,10),be(Fl,10),be(Xi,10),be(o3,8))},n.\u0275dir=yt({type:n,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[Fn([wTe]),sn,Qi]}),n})(),h6=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({}),n})();const ATe={provide:Xi,useExisting:un(()=>nv),multi:!0};function v6(n,t){return null==n?`${t}`:(t&&"object"==typeof t&&(t="Object"),`${n}: ${t}`.slice(0,50))}let nv=(()=>{class n extends Hu{constructor(){super(...arguments),this._optionMap=new Map,this._idCounter=0,this._compareWith=Object.is}set compareWith(e){this._compareWith=e}writeValue(e){this.value=e;const s=v6(this._getOptionId(e),e);this.setProperty("value",s)}registerOnChange(e){this.onChange=r=>{this.value=this._getOptionValue(r),e(this.value)}}_registerOption(){return(this._idCounter++).toString()}_getOptionId(e){for(const r of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(r),e))return r;return null}_getOptionValue(e){const r=function RTe(n){return n.split(":")[0]}(e);return this._optionMap.has(r)?this._optionMap.get(r):e}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=es(n)))(r||n)}}(),n.\u0275dir=yt({type:n,selectors:[["select","formControlName","",3,"multiple",""],["select","formControl","",3,"multiple",""],["select","ngModel","",3,"multiple",""]],hostBindings:function(e,r){1&e&&zn("change",function(o){return r.onChange(o.target.value)})("blur",function(){return r.onTouched()})},inputs:{compareWith:"compareWith"},features:[Fn([ATe]),sn]}),n})(),w6=(()=>{class n{constructor(e,r,s){this._element=e,this._renderer=r,this._select=s,this._select&&(this.id=this._select._registerOption())}set ngValue(e){null!=this._select&&(this._select._optionMap.set(this.id,e),this._setElementValue(v6(this.id,e)),this._select.writeValue(this._select.value))}set value(e){this._setElementValue(e),this._select&&this._select.writeValue(this._select.value)}_setElementValue(e){this._renderer.setProperty(this._element.nativeElement,"value",e)}ngOnDestroy(){this._select&&(this._select._optionMap.delete(this.id),this._select.writeValue(this._select.value))}}return n.\u0275fac=function(e){return new(e||n)(be(Yo),be(nu),be(nv,9))},n.\u0275dir=yt({type:n,selectors:[["option"]],inputs:{ngValue:"ngValue",value:"value"}}),n})();const OTe={provide:Xi,useExisting:un(()=>v_),multi:!0};function x6(n,t){return null==n?`${t}`:("string"==typeof t&&(t=`'${t}'`),t&&"object"==typeof t&&(t="Object"),`${n}: ${t}`.slice(0,50))}let v_=(()=>{class n extends Hu{constructor(){super(...arguments),this._optionMap=new Map,this._idCounter=0,this._compareWith=Object.is}set compareWith(e){this._compareWith=e}writeValue(e){let r;if(this.value=e,Array.isArray(e)){const s=e.map(o=>this._getOptionId(o));r=(o,i)=>{o._setSelected(s.indexOf(i.toString())>-1)}}else r=(s,o)=>{s._setSelected(!1)};this._optionMap.forEach(r)}registerOnChange(e){this.onChange=r=>{const s=[],o=r.selectedOptions;if(void 0!==o){const i=o;for(let a=0;a<i.length;a++){const u=this._getOptionValue(i[a].value);s.push(u)}}else{const i=r.options;for(let a=0;a<i.length;a++){const l=i[a];if(l.selected){const u=this._getOptionValue(l.value);s.push(u)}}}this.value=s,e(s)}}_registerOption(e){const r=(this._idCounter++).toString();return this._optionMap.set(r,e),r}_getOptionId(e){for(const r of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(r)._value,e))return r;return null}_getOptionValue(e){const r=function FTe(n){return n.split(":")[0]}(e);return this._optionMap.has(r)?this._optionMap.get(r)._value:e}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=es(n)))(r||n)}}(),n.\u0275dir=yt({type:n,selectors:[["select","multiple","","formControlName",""],["select","multiple","","formControl",""],["select","multiple","","ngModel",""]],hostBindings:function(e,r){1&e&&zn("change",function(o){return r.onChange(o.target)})("blur",function(){return r.onTouched()})},inputs:{compareWith:"compareWith"},features:[Fn([OTe]),sn]}),n})(),C6=(()=>{class n{constructor(e,r,s){this._element=e,this._renderer=r,this._select=s,this._select&&(this.id=this._select._registerOption(this))}set ngValue(e){null!=this._select&&(this._value=e,this._setElementValue(x6(this.id,e)),this._select.writeValue(this._select.value))}set value(e){this._select?(this._value=e,this._setElementValue(x6(this.id,e)),this._select.writeValue(this._select.value)):this._setElementValue(e)}_setElementValue(e){this._renderer.setProperty(this._element.nativeElement,"value",e)}_setSelected(e){this._renderer.setProperty(this._element.nativeElement,"selected",e)}ngOnDestroy(){this._select&&(this._select._optionMap.delete(this.id),this._select.writeValue(this._select.value))}}return n.\u0275fac=function(e){return new(e||n)(be(Yo),be(nu),be(v_,9))},n.\u0275dir=yt({type:n,selectors:[["option"]],inputs:{ngValue:"ngValue",value:"value"}}),n})(),WTe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({imports:[h6]}),n})(),R6=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Ko({type:n}),n.\u0275inj=ft({imports:[WTe]}),n})();const jTe=["container"],GTe=["videoStream"],qTe=["objectDetection"],KTe=["corpingImage"];function XTe(n,t){if(1&n&&(pn(0,"div",13)(1,"p"),_r(2),Zt()()),2&n){const e=ni();sr(2),yx(e.isModelLoading)}}function JTe(n,t){if(1&n&&(pn(0,"span"),_r(1),Zt()),2&n){const e=ni(2);sr(1),Gh("Sample: ",e.gatherCounting,"")}}function ZTe(n,t){if(1&n){const e=function Ak(){return de()}();ou(0),pn(1,"div",14)(2,"input",15),zn("ngModelChange",function(s){return za(e),Ua(ni().className=s)}),Zt()(),pn(3,"div",14)(4,"button",16),zn("click",function(){return za(e),Ua(ni().toggleGather())}),_r(5," Gather"),ti(6,JTe,2,1,"span",12),Zt(),pn(7,"button",17),zn("click",function(){return za(e),Ua(ni().train())}),_r(8," Train"),Zt(),pn(9,"button",18),zn("click",function(){return za(e),Ua(ni().reset())}),_r(10," Reset"),Zt()(),pn(11,"div",14)(12,"button",8),zn("click",function(){return za(e),Ua(function Dk(n){return function cc(n,t){return n[t]}(function lU(){return pt.lFrame.contextLView}(),22+n)}(15).click())}),_r(13," Import "),Zt(),pn(14,"input",19,20),zn("change",function(s){return za(e),Ua(ni().fileChanged(s))}),Zt(),pn(16,"button",8),zn("click",function(){return za(e),Ua(ni().exportDataset())}),_r(17," Export "),Zt()(),iu()}if(2&n){const e=ni();sr(2),Tr("ngModel",e.className)("placeholder","Class Name"),sr(2),Tr("disabled",""===e.className),sr(2),Tr("ngIf",e.gatherCounting)}}class rv{_doc;_webCameraService;_mediapipeService;_faceRecognitionService;isModelLoading="Loading Model...";className="";gatherCounting=0;_container={};_videoStream={};_objectDetection={};_corpingImage={};_videoElement=null;_lastPerformance=0;_unsubscribeAll$;_freeze=!1;_doGathering=!1;constructor(t,e,r,s){this._doc=t,this._webCameraService=e,this._mediapipeService=r,this._faceRecognitionService=s,this._unsubscribeAll$=new Go}ngOnInit(){(function jNe(...n){const t=ah(n),e=zm(n),{args:r,keys:s}=wz(n);if(0===r.length)return Gl([],t);const o=new Gn(function GNe(n,t,e=bo){return r=>{Sz(t,()=>{const{length:s}=n,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)Sz(t,()=>{const u=Gl(n[l],t);let c=!1;u.subscribe(ps(r,d=>{o[l]=d,c||(c=!0,a--),a||r.next(e(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,t,s?i=>Cz(s,i):bo));return e?o.pipe(xz(e)):o})([this._mediapipeService.isModelReady,this._faceRecognitionService.isModelReady]).subscribe(t=>{if(this.isModelLoading=t[0]&&t[1]?"":"Loading Model...",t[0]&&t[1]){const e=this._faceRecognitionService.datasetStatus;console.log(`Total: ${e.total} samples, and class`,e.class)}})}ngOnDestroy(){this._unsubscribeAll$.next(null),this._unsubscribeAll$.complete()}_drawDetectResults(t,e,r){const s=this._objectDetection.nativeElement,o=s.getContext("2d");o&&(o.clearRect(0,0,s.width,s.height),t.forEach(i=>{const a=i.box;if(o.fillStyle="#2C99A833",o.fillRect(a.xMin,a.yMin,a.width,a.height),e){const u=Math.floor(a.height/12),c=a.yMin-u-5;o.fillStyle="#2C99A833",o.fillRect(a.xMin,c,a.width,u);const d=`${u}px Arial`;o.font=d,o.textBaseline="top",o.fillStyle=r&&r>=98?"#28c76f":"#ffffff",o.font=d,o.fillText(r&&r>=98?`${e} with ${r}% confidence`:"Stranger",a.xMin,c)}}))}_streaming(){var t=this;return J(function*(){const e=performance.now(),r=t._videoStream.nativeElement,s=r.getContext("2d");if(s&&t._videoElement)if(t._freeze)requestAnimationFrame(()=>t._streaming());else{s.clearRect(0,0,r.width,r.height),s.drawImage(t._videoElement,0,0,r.width,r.height);let o=Math.floor(t._lastPerformance?1e3/(e-t._lastPerformance):0);t._lastPerformance=e,s.font="16px Georgia",s.fillText(`FPS: ${o.toString()}`,r.width-80,r.height-20);const i=yield t._mediapipeService.detect(r);if(i.length>0){const a=i[0].box,l=document.createElement("canvas");l.width=224,l.height=224;const u=l.getContext("2d");u&&t._videoElement&&(u.drawImage(r,a.xMin,a.yMin,a.width,a.height,0,0,224,224),t._doGathering&&t._faceRecognitionService.gatherData(t.className,l,()=>{t.gatherCounting++}),t._faceRecognitionService.classArray.length>0?t._faceRecognitionService.predict(l,(c,d)=>{t._drawDetectResults(i,c,d)}):t._drawDetectResults(i)),requestAnimationFrame(()=>t._streaming())}else t._drawDetectResults(i),requestAnimationFrame(()=>t._streaming())}})()}_clearCanvas(t){const e=t.nativeElement,r=e.getContext("2d");r&&r.clearRect(0,0,e.width,e.height),e.width=0,e.height=0}startStreaming(){if(this._videoElement)return;this._webCameraService.currentSream.pipe(Eb(s=>null!=s),EI(1)).subscribe({next:s=>{this._videoElement=this._doc.createElement("video"),this._videoElement.autoplay=!0,this._videoElement.srcObject=s,this._videoElement.addEventListener("loadeddata",()=>{if(this._videoElement){const o=this._videoStream.nativeElement;o.width=this._videoElement.videoWidth,o.height=this._videoElement.videoHeight;const i=this._objectDetection.nativeElement;i.width=this._videoElement.videoWidth,i.height=this._videoElement.videoHeight,this._streaming()}})}});const t=this._container.nativeElement;this._webCameraService.startCamera(t.clientHeight,t.clientWidth)}stopStreaming(){this._clearCanvas(this._videoStream),this._clearCanvas(this._objectDetection),this._clearCanvas(this._corpingImage),this._videoElement=null,this._webCameraService.stopCamera()}toggleGather(){this._doGathering?this.stopGatherData():this.startGatherData()}startGatherData(){null!==this._videoElement?(console.log("start gathering"),this._doGathering=!0):console.log("No Streaming")}stopGatherData(){this._doGathering=!1,console.log(`Collect ${this.gatherCounting} samples for ${this.className}.`);const t=this._faceRecognitionService.datasetStatus;console.log(`Total: ${t.total} samples, and class`,t.class),console.log(t.trainingData),this.gatherCounting=0,this.className=""}train(){this.stopStreaming(),this.isModelLoading="Training Model...",this._faceRecognitionService.trainData(!1,()=>{this.isModelLoading="",console.log("============== Done training...")})}reset(){this.stopStreaming(),this.isModelLoading="Reset Model...",this._faceRecognitionService.reset(()=>{this.isModelLoading="",console.log("============== Done reseting...")})}fileChanged(t){const e=t.target;if(e.files&&e.files.length>0){const s=e.files[0],o=`.${s.name.split(".").pop()}`;if(![".json"].includes(o))return void console.log("Not json file");this.isModelLoading="Loading Dataset...";try{const a=new FileReader;a.onload=()=>{const l=JSON.parse(a.result);l.hasOwnProperty("class")&&l.hasOwnProperty("inputData")&&l.hasOwnProperty("outputData")?(this._faceRecognitionService.loadSavedData(a.result),this.isModelLoading=""):(this.isModelLoading="",console.log("Json format is invalid"))},a.readAsText(s)}catch{return console.log("Fail to parse the json file"),void(this.isModelLoading="")}}}exportDataset(){this._faceRecognitionService.exportDataset()}static \u0275fac=function(e){return new(e||rv)(be(To),be(Wd),be(um),be(dm))};static \u0275cmp=gh({type:rv,selectors:[["face-recognition"]],viewQuery:function(e,r){if(1&e&&(Xa(jTe,5),Xa(GTe,5),Xa(qTe,5),Xa(KTe,5)),2&e){let s;Ka(s=Ja())&&(r._container=s.first),Ka(s=Ja())&&(r._videoStream=s.first),Ka(s=Ja())&&(r._objectDetection=s.first),Ka(s=Ja())&&(r._corpingImage=s.first)}},decls:15,vars:2,consts:[[1,"face-recognition"],["container",""],["id","video-stream"],["videoStream",""],["id","object-detection"],["objectDetection",""],[1,"tool-bar"],["type","button",1,"control-button","primary",3,"click"],["type","button",1,"control-button","secondary",3,"click"],["class","blocker",4,"ngIf"],["id","corping"],["corpingImage",""],[4,"ngIf"],[1,"blocker"],[1,"training-zone"],["type","text",1,"text-input",3,"ngModel","placeholder","ngModelChange"],["type","button",1,"control-button","secondary",3,"disabled","click"],["type","button",1,"control-button","success",3,"click"],["type","button",1,"control-button","danger",3,"click"],["type","file","id","upload",2,"display","none",3,"change"],["uploadFileButton",""]],template:function(e,r){1&e&&(pn(0,"div",0,1),ua(2,"canvas",2,3)(4,"canvas",4,5),pn(6,"div",6)(7,"button",7),zn("click",function(){return r.startStreaming()}),_r(8,"Start"),Zt(),pn(9,"button",8),zn("click",function(){return r.stopStreaming()}),_r(10,"Stop"),Zt()(),ti(11,XTe,3,1,"div",9),ua(12,"canvas",10,11),Zt(),ti(14,ZTe,18,4,"ng-container",12)),2&e&&(sr(11),Tr("ngIf",r.isModelLoading),sr(3),Tr("ngIf",!r.isModelLoading))},dependencies:[uC,jb,o_,tv],styles:[".face-recognition[_ngcontent-%COMP%]{max-width:640px;width:min(90vh - 16.142rem,100%);margin:auto;background:#000;position:relative;aspect-ratio:1/1}.face-recognition[_ngcontent-%COMP%]   canvas#video-stream[_ngcontent-%COMP%]{z-index:50}.face-recognition[_ngcontent-%COMP%]   canvas#object-detection[_ngcontent-%COMP%]{z-index:75;position:absolute;top:0;left:0}.face-recognition[_ngcontent-%COMP%]   canvas#corping[_ngcontent-%COMP%]{position:absolute;bottom:0;left:0;z-index:250}.face-recognition[_ngcontent-%COMP%]   .tool-bar[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:60px;z-index:100;display:flex;justify-content:center;align-items:center}.face-recognition[_ngcontent-%COMP%]   .blocker[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(255,255,255,.6705882353);z-index:9999999;display:flex}.face-recognition[_ngcontent-%COMP%]   .blocker[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:auto;font-size:2rem;font-family:system-ui;font-weight:600;color:#696969}.training-zone[_ngcontent-%COMP%]{max-width:640px;width:min(90vh - 16.142rem,100%);margin:auto;position:relative;padding:.5rem 0;display:flex;align-items:center;justify-content:center}.training-zone[_ngcontent-%COMP%]   .text-input[_ngcontent-%COMP%]{max-width:100%}"]})}function YTe(n,t){if(1&n&&(pn(0,"option",10),_r(1),Zt()),2&n){const e=t.$implicit;Tr("value",e.value),sr(1),Gh(" ",e.name," ")}}function QTe(n,t){1&n&&(ou(0),ua(1,"face-recognition"),iu())}function eIe(n,t){1&n&&(ou(0),ua(1,"view-port"),iu())}class sv{aiModule=Wu.HELMET_AND_VEST_DETECTION;aiModuleOption=[{name:"Face Recognition",value:Wu.FACE_RECOGNITION},{name:"Helmet And Vest Detection",value:Wu.HELMET_AND_VEST_DETECTION}];constructor(){}get AiModule(){return Wu}ngOnInit(){}_run(){const t=vT();t.add(Bp({units:1,inputShape:[1]})),t.compile({loss:"meanSquaredError",optimizer:"sgd"});const e=Pi([-1,0,1,2,3,4],[6,1]),r=Pi([-3,-1,1,3,5,7],[6,1]);t.fit(e,r).then(()=>{t.predict(Pi([5],[1,1])).print()})}static \u0275fac=function(e){return new(e||sv)};static \u0275cmp=gh({type:sv,selectors:[["app-root"]],decls:12,vars:6,consts:[[1,"app-container"],[1,"logo-bar"],["src","assets/images/logo-white.png","alt","logo"],[1,"content"],[1,"tool-bar"],[1,"select-input",3,"id","ngModel","ngModelChange"],["value","","disabled",""],[3,"value",4,"ngFor","ngForOf"],[3,"ngSwitch"],[4,"ngSwitchCase"],[3,"value"]],template:function(e,r){1&e&&(pn(0,"div",0)(1,"div",1),ua(2,"img",2),Zt(),pn(3,"div",3)(4,"div",4)(5,"select",5),zn("ngModelChange",function(o){return r.aiModule=o}),pn(6,"option",6),_r(7,"Please select an AI Module"),Zt(),ti(8,YTe,2,2,"option",7),Zt()(),ou(9,8),ti(10,QTe,2,0,"ng-container",9),ti(11,eIe,2,0,"ng-container",9),iu(),Zt()()),2&e&&(sr(5),Tr("id","module-select")("ngModel",r.aiModule),sr(3),Tr("ngForOf",r.aiModuleOption),sr(1),Tr("ngSwitch",r.aiModule),sr(1),Tr("ngSwitchCase",r.AiModule.FACE_RECOGNITION),sr(1),Tr("ngSwitchCase",r.AiModule.HELMET_AND_VEST_DETECTION))},dependencies:[I3,py,D3,Hb,rv,w6,C6,nv,o_,tv],styles:[".app-container[_ngcontent-%COMP%]{background-color:#2c2c2c;width:100vw;height:100vh}.app-container[_ngcontent-%COMP%]   .logo-bar[_ngcontent-%COMP%]{width:100vw;height:6rem;padding:1rem;display:flex}.app-container[_ngcontent-%COMP%]   .logo-bar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin:auto;height:3rem}.app-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{width:90vw;height:6rem;padding:1rem;margin:auto}.app-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .tool-bar[_ngcontent-%COMP%]{display:flex;justify-content:center;padding:0 0 1rem}"]})}class ov{static \u0275fac=function(e){return new(e||ov)};static \u0275mod=Ko({type:ov});static \u0275inj=ft({imports:[R3,R6]})}class iv{static \u0275fac=function(e){return new(e||iv)};static \u0275mod=Ko({type:iv,bootstrap:[sv]});static \u0275inj=ft({imports:[gK,ov,R6,kNe]})}(function $9(){n3=!1})(),mK().bootstrapModule(iv).catch(n=>console.error(n))},658:Ze=>{Ze.exports=ee;var At=null;try{At=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function ee(re,O,Ie){this.low=0|re,this.high=0|O,this.unsigned=!!Ie}function Ye(re){return!0===(re&&re.__isLong__)}Object.defineProperty(ee.prototype,"__isLong__",{value:!0}),ee.isLong=Ye;var en={},je={};function hn(re,O){var Ie,Ne,wt;return O?(wt=0<=(re>>>=0)&&re<256)&&(Ne=je[re])?Ne:(Ie=We(re,(0|re)<0?-1:0,!0),wt&&(je[re]=Ie),Ie):(wt=-128<=(re|=0)&&re<128)&&(Ne=en[re])?Ne:(Ie=We(re,re<0?-1:0,!1),wt&&(en[re]=Ie),Ie)}function Xe(re,O){if(isNaN(re))return O?_t:Ht;if(O){if(re<0)return _t;if(re>=fe)return Bt}else{if(re<=-Me)return zt;if(re+1>=Me)return Ct}return re<0?Xe(-re,O).neg():We(re%ce|0,re/ce|0,O)}function We(re,O,Ie){return new ee(re,O,Ie)}ee.fromInt=hn,ee.fromNumber=Xe,ee.fromBits=We;var gt=Math.pow;function Ae(re,O,Ie){if(0===re.length)throw Error("empty string");if("NaN"===re||"Infinity"===re||"+Infinity"===re||"-Infinity"===re)return Ht;if("number"==typeof O?(Ie=O,O=!1):O=!!O,(Ie=Ie||10)<2||36<Ie)throw RangeError("radix");var Ne;if((Ne=re.indexOf("-"))>0)throw Error("interior hyphen");if(0===Ne)return Ae(re.substring(1),O,Ie).neg();for(var wt=Xe(gt(Ie,8)),xt=Ht,Ut=0;Ut<re.length;Ut+=8){var Kt=Math.min(8,re.length-Ut),An=parseInt(re.substring(Ut,Ut+Kt),Ie);if(Kt<8){var nr=Xe(gt(Ie,Kt));xt=xt.mul(nr).add(Xe(An))}else xt=(xt=xt.mul(wt)).add(Xe(An))}return xt.unsigned=O,xt}function j(re,O){return"number"==typeof re?Xe(re,O):"string"==typeof re?Ae(re,O):We(re.low,re.high,"boolean"==typeof O?O:re.unsigned)}ee.fromString=Ae,ee.fromValue=j;var ce=4294967296,fe=ce*ce,Me=fe/2,Le=hn(1<<24),Ht=hn(0);ee.ZERO=Ht;var _t=hn(0,!0);ee.UZERO=_t;var Vn=hn(1);ee.ONE=Vn;var Rs=hn(1,!0);ee.UONE=Rs;var Gr=hn(-1);ee.NEG_ONE=Gr;var Ct=We(-1,2147483647,!1);ee.MAX_VALUE=Ct;var Bt=We(-1,-1,!0);ee.MAX_UNSIGNED_VALUE=Bt;var zt=We(0,-2147483648,!1);ee.MIN_VALUE=zt;var le=ee.prototype;le.toInt=function(){return this.unsigned?this.low>>>0:this.low},le.toNumber=function(){return this.unsigned?(this.high>>>0)*ce+(this.low>>>0):this.high*ce+(this.low>>>0)},le.toString=function(O){if((O=O||10)<2||36<O)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(zt)){var Ie=Xe(O),Ne=this.div(Ie),wt=Ne.mul(Ie).sub(this);return Ne.toString(O)+wt.toInt().toString(O)}return"-"+this.neg().toString(O)}for(var xt=Xe(gt(O,6),this.unsigned),Ut=this,Kt="";;){var An=Ut.div(xt),vn=(Ut.sub(An.mul(xt)).toInt()>>>0).toString(O);if((Ut=An).isZero())return vn+Kt;for(;vn.length<6;)vn="0"+vn;Kt=""+vn+Kt}},le.getHighBits=function(){return this.high},le.getHighBitsUnsigned=function(){return this.high>>>0},le.getLowBits=function(){return this.low},le.getLowBitsUnsigned=function(){return this.low>>>0},le.getNumBitsAbs=function(){if(this.isNegative())return this.eq(zt)?64:this.neg().getNumBitsAbs();for(var O=0!=this.high?this.high:this.low,Ie=31;Ie>0&&0==(O&1<<Ie);Ie--);return 0!=this.high?Ie+33:Ie+1},le.isZero=function(){return 0===this.high&&0===this.low},le.eqz=le.isZero,le.isNegative=function(){return!this.unsigned&&this.high<0},le.isPositive=function(){return this.unsigned||this.high>=0},le.isOdd=function(){return 1==(1&this.low)},le.isEven=function(){return 0==(1&this.low)},le.equals=function(O){return Ye(O)||(O=j(O)),(this.unsigned===O.unsigned||this.high>>>31!=1||O.high>>>31!=1)&&this.high===O.high&&this.low===O.low},le.eq=le.equals,le.notEquals=function(O){return!this.eq(O)},le.neq=le.notEquals,le.ne=le.notEquals,le.lessThan=function(O){return this.comp(O)<0},le.lt=le.lessThan,le.lessThanOrEqual=function(O){return this.comp(O)<=0},le.lte=le.lessThanOrEqual,le.le=le.lessThanOrEqual,le.greaterThan=function(O){return this.comp(O)>0},le.gt=le.greaterThan,le.greaterThanOrEqual=function(O){return this.comp(O)>=0},le.gte=le.greaterThanOrEqual,le.ge=le.greaterThanOrEqual,le.compare=function(O){if(Ye(O)||(O=j(O)),this.eq(O))return 0;var Ie=this.isNegative(),Ne=O.isNegative();return Ie&&!Ne?-1:!Ie&&Ne?1:this.unsigned?O.high>>>0>this.high>>>0||O.high===this.high&&O.low>>>0>this.low>>>0?-1:1:this.sub(O).isNegative()?-1:1},le.comp=le.compare,le.negate=function(){return!this.unsigned&&this.eq(zt)?zt:this.not().add(Vn)},le.neg=le.negate,le.add=function(O){Ye(O)||(O=j(O));var vn=0,wn=0,xn=0,Cr=0;return xn+=(Cr+=(65535&this.low)+(65535&O.low))>>>16,wn+=(xn+=(this.low>>>16)+(O.low>>>16))>>>16,vn+=(wn+=(65535&this.high)+(65535&O.high))>>>16,vn+=(this.high>>>16)+(O.high>>>16),We((xn&=65535)<<16|(Cr&=65535),(vn&=65535)<<16|(wn&=65535),this.unsigned)},le.subtract=function(O){return Ye(O)||(O=j(O)),this.add(O.neg())},le.sub=le.subtract,le.multiply=function(O){if(this.isZero())return Ht;if(Ye(O)||(O=j(O)),At)return We(At.mul(this.low,this.high,O.low,O.high),At.get_high(),this.unsigned);if(O.isZero())return Ht;if(this.eq(zt))return O.isOdd()?zt:Ht;if(O.eq(zt))return this.isOdd()?zt:Ht;if(this.isNegative())return O.isNegative()?this.neg().mul(O.neg()):this.neg().mul(O).neg();if(O.isNegative())return this.mul(O.neg()).neg();if(this.lt(Le)&&O.lt(Le))return Xe(this.toNumber()*O.toNumber(),this.unsigned);var wt=65535&this.high,xt=this.low>>>16,Ut=65535&this.low,An=65535&O.high,nr=O.low>>>16,vn=65535&O.low,wn=0,xn=0,Cr=0,xi=0;return Cr+=(xi+=Ut*vn)>>>16,xn+=(Cr+=xt*vn)>>>16,Cr&=65535,xn+=(Cr+=Ut*nr)>>>16,wn+=(xn+=wt*vn)>>>16,xn&=65535,wn+=(xn+=xt*nr)>>>16,xn&=65535,wn+=(xn+=Ut*An)>>>16,wn+=(this.high>>>16)*vn+wt*nr+xt*An+Ut*(O.high>>>16),We((Cr&=65535)<<16|(xi&=65535),(wn&=65535)<<16|(xn&=65535),this.unsigned)},le.mul=le.multiply,le.divide=function(O){if(Ye(O)||(O=j(O)),O.isZero())throw Error("division by zero");var Ne,wt,xt;if(At)return this.unsigned||-2147483648!==this.high||-1!==O.low||-1!==O.high?We((this.unsigned?At.div_u:At.div_s)(this.low,this.high,O.low,O.high),At.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?_t:Ht;if(this.unsigned){if(O.unsigned||(O=O.toUnsigned()),O.gt(this))return _t;if(O.gt(this.shru(1)))return Rs;xt=_t}else{if(this.eq(zt))return O.eq(Vn)||O.eq(Gr)?zt:O.eq(zt)?Vn:(Ne=this.shr(1).div(O).shl(1)).eq(Ht)?O.isNegative()?Vn:Gr:(wt=this.sub(O.mul(Ne)),xt=Ne.add(wt.div(O)));if(O.eq(zt))return this.unsigned?_t:Ht;if(this.isNegative())return O.isNegative()?this.neg().div(O.neg()):this.neg().div(O).neg();if(O.isNegative())return this.div(O.neg()).neg();xt=Ht}for(wt=this;wt.gte(O);){Ne=Math.max(1,Math.floor(wt.toNumber()/O.toNumber()));for(var Kt=Math.ceil(Math.log(Ne)/Math.LN2),An=Kt<=48?1:gt(2,Kt-48),nr=Xe(Ne),vn=nr.mul(O);vn.isNegative()||vn.gt(wt);)vn=(nr=Xe(Ne-=An,this.unsigned)).mul(O);nr.isZero()&&(nr=Vn),xt=xt.add(nr),wt=wt.sub(vn)}return xt},le.div=le.divide,le.modulo=function(O){return Ye(O)||(O=j(O)),At?We((this.unsigned?At.rem_u:At.rem_s)(this.low,this.high,O.low,O.high),At.get_high(),this.unsigned):this.sub(this.div(O).mul(O))},le.mod=le.modulo,le.rem=le.modulo,le.not=function(){return We(~this.low,~this.high,this.unsigned)},le.and=function(O){return Ye(O)||(O=j(O)),We(this.low&O.low,this.high&O.high,this.unsigned)},le.or=function(O){return Ye(O)||(O=j(O)),We(this.low|O.low,this.high|O.high,this.unsigned)},le.xor=function(O){return Ye(O)||(O=j(O)),We(this.low^O.low,this.high^O.high,this.unsigned)},le.shiftLeft=function(O){return Ye(O)&&(O=O.toInt()),0==(O&=63)?this:O<32?We(this.low<<O,this.high<<O|this.low>>>32-O,this.unsigned):We(0,this.low<<O-32,this.unsigned)},le.shl=le.shiftLeft,le.shiftRight=function(O){return Ye(O)&&(O=O.toInt()),0==(O&=63)?this:O<32?We(this.low>>>O|this.high<<32-O,this.high>>O,this.unsigned):We(this.high>>O-32,this.high>=0?0:-1,this.unsigned)},le.shr=le.shiftRight,le.shiftRightUnsigned=function(O){if(Ye(O)&&(O=O.toInt()),0==(O&=63))return this;var Ie=this.high;return O<32?We(this.low>>>O|Ie<<32-O,Ie>>>O,this.unsigned):We(32===O?Ie:Ie>>>O-32,0,this.unsigned)},le.shru=le.shiftRightUnsigned,le.shr_u=le.shiftRightUnsigned,le.toSigned=function(){return this.unsigned?We(this.low,this.high,!1):this},le.toUnsigned=function(){return this.unsigned?this:We(this.low,this.high,!0)},le.toBytes=function(O){return O?this.toBytesLE():this.toBytesBE()},le.toBytesLE=function(){var O=this.high,Ie=this.low;return[255&Ie,Ie>>>8&255,Ie>>>16&255,Ie>>>24,255&O,O>>>8&255,O>>>16&255,O>>>24]},le.toBytesBE=function(){var O=this.high,Ie=this.low;return[O>>>24,O>>>16&255,O>>>8&255,255&O,Ie>>>24,Ie>>>16&255,Ie>>>8&255,255&Ie]},ee.fromBytes=function(O,Ie,Ne){return Ne?ee.fromBytesLE(O,Ie):ee.fromBytesBE(O,Ie)},ee.fromBytesLE=function(O,Ie){return new ee(O[0]|O[1]<<8|O[2]<<16|O[3]<<24,O[4]|O[5]<<8|O[6]<<16|O[7]<<24,Ie)},ee.fromBytesBE=function(O,Ie){return new ee(O[4]<<24|O[5]<<16|O[6]<<8|O[7],O[0]<<24|O[1]<<16|O[2]<<8|O[3],Ie)}},340:(Ze,At,ee)=>{var Ye=ee(471),en=ee(992),je=ee(657),hn=ee(583),Xe=ee(929),We=ee(83),gt=ee(818);gt.alea=Ye,gt.xor128=en,gt.xorwow=je,gt.xorshift7=hn,gt.xor4096=Xe,gt.tychei=We,Ze.exports=gt},471:function(Ze,At,ee){var Ye;!function(en,je,hn){function Xe(j){var ge=this,Se=function Ae(){var j=4022871197;return function(Se){Se=String(Se);for(var ce=0;ce<Se.length;ce++){var fe=.02519603282416938*(j+=Se.charCodeAt(ce));fe-=j=fe>>>0,j=(fe*=j)>>>0,j+=4294967296*(fe-=j)}return 2.3283064365386963e-10*(j>>>0)}}();ge.next=function(){var ce=2091639*ge.s0+2.3283064365386963e-10*ge.c;return ge.s0=ge.s1,ge.s1=ge.s2,ge.s2=ce-(ge.c=0|ce)},ge.c=1,ge.s0=Se(" "),ge.s1=Se(" "),ge.s2=Se(" "),ge.s0-=Se(j),ge.s0<0&&(ge.s0+=1),ge.s1-=Se(j),ge.s1<0&&(ge.s1+=1),ge.s2-=Se(j),ge.s2<0&&(ge.s2+=1),Se=null}function We(j,ge){return ge.c=j.c,ge.s0=j.s0,ge.s1=j.s1,ge.s2=j.s2,ge}function gt(j,ge){var Se=new Xe(j),ce=ge&&ge.state,fe=Se.next;return fe.int32=function(){return 4294967296*Se.next()|0},fe.double=function(){return fe()+11102230246251565e-32*(2097152*fe()|0)},fe.quick=fe,ce&&("object"==typeof ce&&We(ce,Se),fe.state=function(){return We(Se,{})}),fe}je&&je.exports?je.exports=gt:ee.amdD&&ee.amdO?void 0!==(Ye=function(){return gt}.call(At,ee,At,je))&&(je.exports=Ye):this.alea=gt}(0,Ze=ee.nmd(Ze))},83:function(Ze,At,ee){var Ye;!function(en,je,hn){function Xe(Ae){var j=this,ge="";j.next=function(){var ce=j.b,fe=j.c,Me=j.d,Le=j.a;return ce=ce<<25^ce>>>7^fe,fe=fe-Me|0,Me=Me<<24^Me>>>8^Le,Le=Le-ce|0,j.b=ce=ce<<20^ce>>>12^fe,j.c=fe=fe-Me|0,j.d=Me<<16^fe>>>16^Le,j.a=Le-ce|0},j.a=0,j.b=0,j.c=-1640531527,j.d=1367130551,Ae===Math.floor(Ae)?(j.a=Ae/4294967296|0,j.b=0|Ae):ge+=Ae;for(var Se=0;Se<ge.length+20;Se++)j.b^=0|ge.charCodeAt(Se),j.next()}function We(Ae,j){return j.a=Ae.a,j.b=Ae.b,j.c=Ae.c,j.d=Ae.d,j}function gt(Ae,j){var ge=new Xe(Ae),Se=j&&j.state,ce=function(){return(ge.next()>>>0)/4294967296};return ce.double=function(){do{var Le=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ce.int32=ge.next,ce.quick=ce,Se&&("object"==typeof Se&&We(Se,ge),ce.state=function(){return We(ge,{})}),ce}je&&je.exports?je.exports=gt:ee.amdD&&ee.amdO?void 0!==(Ye=function(){return gt}.call(At,ee,At,je))&&(je.exports=Ye):this.tychei=gt}(0,Ze=ee.nmd(Ze))},992:function(Ze,At,ee){var Ye;!function(en,je,hn){function Xe(Ae){var j=this,ge="";j.x=0,j.y=0,j.z=0,j.w=0,j.next=function(){var ce=j.x^j.x<<11;return j.x=j.y,j.y=j.z,j.z=j.w,j.w^=j.w>>>19^ce^ce>>>8},Ae===(0|Ae)?j.x=Ae:ge+=Ae;for(var Se=0;Se<ge.length+64;Se++)j.x^=0|ge.charCodeAt(Se),j.next()}function We(Ae,j){return j.x=Ae.x,j.y=Ae.y,j.z=Ae.z,j.w=Ae.w,j}function gt(Ae,j){var ge=new Xe(Ae),Se=j&&j.state,ce=function(){return(ge.next()>>>0)/4294967296};return ce.double=function(){do{var Le=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ce.int32=ge.next,ce.quick=ce,Se&&("object"==typeof Se&&We(Se,ge),ce.state=function(){return We(ge,{})}),ce}je&&je.exports?je.exports=gt:ee.amdD&&ee.amdO?void 0!==(Ye=function(){return gt}.call(At,ee,At,je))&&(je.exports=Ye):this.xor128=gt}(0,Ze=ee.nmd(Ze))},929:function(Ze,At,ee){var Ye;!function(en,je,hn){function Xe(Ae){var j=this;j.next=function(){var Me,Le,Se=j.w,ce=j.X,fe=j.i;return j.w=Se=Se+1640531527|0,Le=ce[fe+34&127],Me=ce[fe=fe+1&127],Le^=Le<<13,Me^=Me<<17,Le=ce[fe]=(Le^=Le>>>15)^(Me^=Me>>>12),j.i=fe,Le+(Se^Se>>>16)|0},function ge(Se,ce){var fe,Me,Le,Ht,_t,Vn=[],Rs=128;for(ce===(0|ce)?(Me=ce,ce=null):(ce+="\0",Me=0,Rs=Math.max(Rs,ce.length)),Le=0,Ht=-32;Ht<Rs;++Ht)ce&&(Me^=ce.charCodeAt((Ht+32)%ce.length)),0===Ht&&(_t=Me),Me^=Me<<10,Me^=Me>>>15,Me^=Me<<4,Me^=Me>>>13,Ht>=0&&(Le=0==(fe=Vn[127&Ht]^=Me+(_t=_t+1640531527|0))?Le+1:0);for(Le>=128&&(Vn[127&(ce&&ce.length||0)]=-1),Le=127,Ht=512;Ht>0;--Ht)Me=Vn[Le+34&127],fe=Vn[Le=Le+1&127],Me^=Me<<13,fe^=fe<<17,Vn[Le]=(Me^=Me>>>15)^(fe^=fe>>>12);Se.w=_t,Se.X=Vn,Se.i=Le}(j,Ae)}function We(Ae,j){return j.i=Ae.i,j.w=Ae.w,j.X=Ae.X.slice(),j}function gt(Ae,j){null==Ae&&(Ae=+new Date);var ge=new Xe(Ae),Se=j&&j.state,ce=function(){return(ge.next()>>>0)/4294967296};return ce.double=function(){do{var Le=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ce.int32=ge.next,ce.quick=ce,Se&&(Se.X&&We(Se,ge),ce.state=function(){return We(ge,{})}),ce}je&&je.exports?je.exports=gt:ee.amdD&&ee.amdO?void 0!==(Ye=function(){return gt}.call(At,ee,At,je))&&(je.exports=Ye):this.xor4096=gt}(0,Ze=ee.nmd(Ze))},583:function(Ze,At,ee){var Ye;!function(en,je,hn){function Xe(Ae){var j=this;j.next=function(){var fe,Me,Se=j.x,ce=j.i;return fe=Se[ce],Me=(fe^=fe>>>7)^fe<<24,Me^=(fe=Se[ce+1&7])^fe>>>10,Me^=(fe=Se[ce+3&7])^fe>>>3,Me^=(fe=Se[ce+4&7])^fe<<7,fe=Se[ce+7&7],Se[ce]=Me^=(fe^=fe<<13)^fe<<9,j.i=ce+1&7,Me},function ge(Se,ce){var fe,Le=[];if(ce===(0|ce))Le[0]=ce;else for(ce=""+ce,fe=0;fe<ce.length;++fe)Le[7&fe]=Le[7&fe]<<15^ce.charCodeAt(fe)+Le[fe+1&7]<<13;for(;Le.length<8;)Le.push(0);for(fe=0;fe<8&&0===Le[fe];++fe);for(8==fe&&(Le[7]=-1),Se.x=Le,Se.i=0,fe=256;fe>0;--fe)Se.next()}(j,Ae)}function We(Ae,j){return j.x=Ae.x.slice(),j.i=Ae.i,j}function gt(Ae,j){null==Ae&&(Ae=+new Date);var ge=new Xe(Ae),Se=j&&j.state,ce=function(){return(ge.next()>>>0)/4294967296};return ce.double=function(){do{var Le=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ce.int32=ge.next,ce.quick=ce,Se&&(Se.x&&We(Se,ge),ce.state=function(){return We(ge,{})}),ce}je&&je.exports?je.exports=gt:ee.amdD&&ee.amdO?void 0!==(Ye=function(){return gt}.call(At,ee,At,je))&&(je.exports=Ye):this.xorshift7=gt}(0,Ze=ee.nmd(Ze))},657:function(Ze,At,ee){var Ye;!function(en,je,hn){function Xe(Ae){var j=this,ge="";j.next=function(){var ce=j.x^j.x>>>2;return j.x=j.y,j.y=j.z,j.z=j.w,j.w=j.v,(j.d=j.d+362437|0)+(j.v=j.v^j.v<<4^ce^ce<<1)|0},j.x=0,j.y=0,j.z=0,j.w=0,j.v=0,Ae===(0|Ae)?j.x=Ae:ge+=Ae;for(var Se=0;Se<ge.length+64;Se++)j.x^=0|ge.charCodeAt(Se),Se==ge.length&&(j.d=j.x<<10^j.x>>>4),j.next()}function We(Ae,j){return j.x=Ae.x,j.y=Ae.y,j.z=Ae.z,j.w=Ae.w,j.v=Ae.v,j.d=Ae.d,j}function gt(Ae,j){var ge=new Xe(Ae),Se=j&&j.state,ce=function(){return(ge.next()>>>0)/4294967296};return ce.double=function(){do{var Le=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ce.int32=ge.next,ce.quick=ce,Se&&("object"==typeof Se&&We(Se,ge),ce.state=function(){return We(ge,{})}),ce}je&&je.exports?je.exports=gt:ee.amdD&&ee.amdO?void 0!==(Ye=function(){return gt}.call(At,ee,At,je))&&(je.exports=Ye):this.xorwow=gt}(0,Ze=ee.nmd(Ze))},818:function(Ze,At,ee){var Ye;!function(en,je,hn){var fe,Xe=256,j=hn.pow(Xe,6),ge=hn.pow(2,52),Se=2*ge;function Me(Ct,Bt,zt){var le=[],re=Vn(_t((Bt=1==Bt?{entropy:!0}:Bt||{}).entropy?[Ct,Gr(je)]:Ct??function Rs(){try{var Ct;return fe&&(Ct=fe.randomBytes)?Ct=Ct(Xe):(Ct=new Uint8Array(Xe),(en.crypto||en.msCrypto).getRandomValues(Ct)),Gr(Ct)}catch{var Bt=en.navigator,zt=Bt&&Bt.plugins;return[+new Date,en,zt,en.screen,Gr(je)]}}(),3),le),O=new Le(le),Ie=function(){for(var Ne=O.g(6),wt=j,xt=0;Ne<ge;)Ne=(Ne+xt)*Xe,wt*=Xe,xt=O.g(1);for(;Ne>=Se;)Ne/=2,wt/=2,xt>>>=1;return(Ne+xt)/wt};return Ie.int32=function(){return 0|O.g(4)},Ie.quick=function(){return O.g(4)/4294967296},Ie.double=Ie,Vn(Gr(O.S),je),(Bt.pass||zt||function(Ne,wt,xt,Ut){return Ut&&(Ut.S&&Ht(Ut,O),Ne.state=function(){return Ht(O,{})}),xt?(hn.random=Ne,wt):Ne})(Ie,re,"global"in Bt?Bt.global:this==hn,Bt.state)}function Le(Ct){var Bt,zt=Ct.length,le=this,re=0,O=le.i=le.j=0,Ie=le.S=[];for(zt||(Ct=[zt++]);re<Xe;)Ie[re]=re++;for(re=0;re<Xe;re++)Ie[re]=Ie[O=255&O+Ct[re%zt]+(Bt=Ie[re])],Ie[O]=Bt;(le.g=function(Ne){for(var wt,xt=0,Ut=le.i,Kt=le.j,An=le.S;Ne--;)wt=An[Ut=255&Ut+1],xt=xt*Xe+An[255&(An[Ut]=An[Kt=255&Kt+wt])+(An[Kt]=wt)];return le.i=Ut,le.j=Kt,xt})(Xe)}function Ht(Ct,Bt){return Bt.i=Ct.i,Bt.j=Ct.j,Bt.S=Ct.S.slice(),Bt}function _t(Ct,Bt){var re,zt=[],le=typeof Ct;if(Bt&&"object"==le)for(re in Ct)try{zt.push(_t(Ct[re],Bt-1))}catch{}return zt.length?zt:"string"==le?Ct:Ct+"\0"}function Vn(Ct,Bt){for(var le,zt=Ct+"",re=0;re<zt.length;)Bt[255&re]=255&(le^=19*Bt[255&re])+zt.charCodeAt(re++);return Gr(Bt)}function Gr(Ct){return String.fromCharCode.apply(0,Ct)}if(Vn(hn.random(),je),Ze.exports){Ze.exports=Me;try{fe=ee(42)}catch{}}else void 0!==(Ye=function(){return Me}.call(At,ee,At,Ze))&&(Ze.exports=Ye)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},Ze=>{Ze(Ze.s=785)}]);